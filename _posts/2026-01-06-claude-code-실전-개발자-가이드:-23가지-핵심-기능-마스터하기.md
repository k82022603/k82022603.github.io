---
title: "Claude Code 실전 개발자 가이드: 23가지 핵심 기능 마스터하기"
date: 2026-01-06 21:00:00 +0900
categories: [AI,  Claude Code]
mermaid: [True]
tags: [AI,  claude-code,  Developer,  Guide,  Claude.write]
---

## 목차
- [시작하기 전에](#시작하기-전에)
- [기본 워크플로우 최적화](#기본-워크플로우-최적화)
- [컨텍스트 및 메모리 관리](#컨텍스트-및-메모리-관리)
- [세션 및 상태 관리](#세션-및-상태-관리)
- [고급 자동화 기능](#고급-자동화-기능)
- [확장성 및 커스터마이징](#확장성-및-커스터마이징)
- [실전 프로젝트 실습](#실전-프로젝트-실습)

---

## 시작하기 전에

### 환경 설정

이 가이드의 모든 실습을 따라하기 위해 다음 환경을 준비합니다:

```bash
# Claude Code 설치 확인
claude --version

# 실습용 디렉토리 생성
mkdir claude-code-practice
cd claude-code-practice

# Git 저장소 초기화
git init
```

### 학습 목표

이 가이드를 완료하면 다음을 할 수 있습니다:
- Claude Code의 23가지 핵심 기능을 실제 개발 워크플로우에 적용
- 토큰 사용량을 최적화하고 작업 효율성 극대화
- 반복 작업을 자동화하고 재사용 가능한 워크플로우 구축
- 팀 협업을 위한 설정 공유 및 표준화

---

## 기본 워크플로우 최적화

### 1. ! 프리픽스로 터미널 즉시 실행

**개념**: `!` 프리픽스를 사용하면 Claude의 추론 과정 없이 bash 명령을 직접 실행하여 대기 시간과 토큰을 절약합니다.

**실습 1-1: 기본 명령어 실행**

```bash
# 일반적인 방법 (비효율적)
"git status를 확인해줘"

# 최적화된 방법
!git status

# 여러 명령어 연속 실행
!git status
!git log --oneline -5
!ls -la
```

**실습 1-2: 개발 워크플로우에 적용**

```bash
# package.json 생성
!npm init -y

# 의존성 설치
!npm install express

# 개발 서버 상태 확인
!ps aux | grep node

# 빌드 결과 확인
!npm run build
!ls -R dist/
```

**토큰 절약 효과**: 명령어 하나당 약 50-100 토큰 절약, 하루 100번 사용 시 5,000-10,000 토큰 절약

---

### 2. Esc 두 번으로 이전 상태 되돌리기

**개념**: 실험적인 시도 중 문제가 발생했을 때 Esc를 두 번 눌러 대화, 코드 또는 둘 다를 이전 상태로 되돌립니다.

**실습 2-1: 되돌리기 옵션 이해하기**

Claude Code 실행 중:
1. 여러 파일을 수정하는 작업 진행
2. Esc 두 번 누르기
3. 되돌리기 옵션 선택:
   - **대화만 되돌리기**: 코드는 유지하고 대화 히스토리만 제거
   - **코드만 되돌리기**: 대화는 유지하고 파일 변경사항만 되돌림
   - **둘 다 되돌리기**: 완전히 이전 체크포인트로 복귀

**실습 2-2: 실험적 코드 작성 연습**

```bash
# 1단계: 새 기능 추가 시도
"Express 서버에 JWT 인증을 추가해줘"

# 2단계: 복잡해지면 Esc Esc
# 3단계: "대화만 되돌리기" 선택
# 4단계: 더 간단한 접근 방법 요청
"먼저 기본 인증 미들웨어만 추가해줘"
```

**활용 팁**: 
- 아키텍처 결정을 고민할 때 여러 방향 시도
- A/B 테스트처럼 두 가지 구현 방법 비교
- 리팩토링 실험 후 원복

---

### 3. Extended Thinking으로 깊은 추론

**개념**: Tab 키를 눌러 Extended Thinking을 활성화하면 Claude가 복잡한 문제에 대해 더 깊이 사고합니다.

**실습 3-1: Extended Thinking 활용**

```bash
# Tab 키로 활성화
[Tab]  # "Thinking on" 표시

# 복잡한 설계 문제
"마이크로서비스 아키텍처와 모놀리스 중 선택해야 하는데, 
우리 팀 규모는 5명, 사용자는 10만명, 빠른 출시가 중요해.
어떤 아키텍처가 적합할까?"

# Claude가 내부적으로 추론 과정을 거친 후 답변

# 다시 비활성화
[Tab]  # "Thinking off" 표시
```

**실습 3-2: 권장 사용 사례**

```bash
# 아키텍처 결정
[Tab]
"데이터베이스 샤딩 전략을 설계해줘"

# 성능 최적화
[Tab]
"이 알고리즘의 시간 복잡도를 O(n²)에서 O(n log n)으로 개선해줘"

# 보안 분석
[Tab]
"이 인증 시스템의 취약점을 분석하고 대응 방안 제시해줘"
```


---

## 세션 및 상태 관리

### 4. --continue와 --resume으로 세션 이어가기

**개념**: 터미널을 닫거나 작업을 중단해도 이전 세션을 복원하여 컨텍스트를 유지합니다.

**실습 4-1: 기본 세션 복원**

```bash
# 작업 중 터미널 종료됨
# (예: 노트북 배터리 방전, 실수로 창 닫기)

# 다음 날 작업 재개
claude --continue
# → 가장 최근 세션을 자동으로 복원
```

**실습 4-2: 여러 프로젝트 관리**

```bash
# 프로젝트 A 작업
cd ~/projects/api-server
claude
"Express API 서버 구축 중..."
# 세션 이름 지정
/rename api-server-dev

# 프로젝트 B 작업
cd ~/projects/frontend
claude
"React 앱 개발 중..."
/rename frontend-refactor

# 프로젝트 C 작업
cd ~/projects/ml-model
claude
"머신러닝 모델 학습 중..."
/rename ml-training

# 나중에 특정 프로젝트로 복귀
cd ~/projects/api-server
claude --resume api-server-dev
# → 정확히 중단했던 지점부터 이어서 작업
```

**실습 4-3: 세션 목록 관리**

```bash
# 모든 세션 확인
/resume
# 또는
claude --resume

# 출력 예시:
# 1. api-server-dev (2시간 전)
# 2. frontend-refactor (어제)
# 3. ml-training (3일 전)
# 4. bugfix-auth (일주일 전)

# 선택하여 복원
# → 2 입력하여 frontend-refactor 복원
```

**실습 4-4: 세션 이름 변경 및 정리**

```bash
# 세션 이름 변경
/rename production-deployment

# 오래된 세션 정리 (수동)
# CLAUDE.md나 세션 파일 백업 후 삭제

# 작업 패턴 예시:
# - 단기 작업: --continue 사용
# - 장기 프로젝트: 의미 있는 이름으로 --resume 관리
```



---

## 컨텍스트 및 메모리 관리

### 5. # 프리픽스로 메모리 즉시 저장

**개념**: `#`으로 시작하는 메시지는 CLAUDE.md 파일에 자동 저장되어 향후 모든 대화에서 참조됩니다.

**실습 5-1: 프로젝트 규칙 설정**

```bash
# 패키지 매니저 선호도
# Always use bun instead of npm

# 코드 스타일
# Use TypeScript strict mode for all new files

# 테스트 프레임워크
# Prefer Vitest over Jest

# 아키텍처 원칙
# Follow clean architecture: entities, use-cases, adapters
```

**실습 5-2: 팀 컨벤션 저장**

```bash
# API 응답 포맷은 항상 { success: boolean, data: any, error?: string } 형식 사용

# 에러 핸들링은 custom AppError 클래스 사용

# 데이터베이스 마이그레이션은 Prisma 사용

# 환경변수는 .env.example에 문서화
```

**실습 5-3: 메모리 확인 및 수정**

```bash
# 저장된 메모리 확인
!cat CLAUDE.md

# 또는 Claude에게 요청
"현재 저장된 프로젝트 규칙 보여줘"

# 메모리 업데이트
# Jest 대신 Vitest 사용하도록 변경됨 - 기존 규칙 제거
```

---

### 6. /vim으로 프롬프트 편집

**개념**: `/vim` 명령으로 vim 에디터를 열어 키보드만으로 프롬프트를 효율적으로 편집합니다.

**실습 6-1: 기본 vim 명령**

```bash
# /vim 실행 후 사용할 수 있는 명령어들

# 이동
h j k l        # 좌/하/상/우
w b            # 단어 단위 이동
0 $            # 줄 시작/끝
gg G           # 문서 시작/끝

# 편집
i              # 삽입 모드
a              # 커서 뒤 삽입
o              # 아래 줄 삽입
Esc            # 명령 모드

# 삭제/변경
dd             # 줄 삭제
dw             # 단어 삭제
ciw            # 단어 변경
cc             # 줄 변경

# 저장/종료
:wq            # 저장하고 종료
:q!            # 저장 안 하고 종료
```

**실습 6-2: 실전 편집 시나리오**

```bash
# 긴 프롬프트 작성 중
"Express 서버를 만들어줘. 요구사항:
- PostgreSQL 연결
- JWT 인증
- RESTful API
- Swagger 문서
"

# /vim 입력하여 편집 모드 진입

# vim에서 수정
# 1. gg로 맨 위 이동
# 2. o로 줄 추가: "- TypeScript 사용"
# 3. G로 맨 아래 이동
# 4. o로 줄 추가: "- 에러 핸들링"
# 5. :wq로 저장

# 최종 프롬프트:
"Express 서버를 만들어줘. 요구사항:
- TypeScript 사용
- PostgreSQL 연결
- JWT 인증
- RESTful API
- Swagger 문서
- 에러 핸들링
"
```


---

## 고급 자동화 기능

### 7. -p 옵션으로 Headless 모드 사용

**개념**: `-p` 플래그로 대화형 UI 없이 명령어처럼 실행하여 스크립트나 CI/CD에 통합합니다.

**실습 7-1: 기본 Headless 실행**

```bash
# 간단한 코드 생성
claude -p "Express Hello World 서버 만들어줘" > server.js

# Git 커밋 메시지 생성
git diff | claude -p "이 변경사항에 대한 커밋 메시지 작성해줘"

# 코드 리뷰
claude -p "$(cat src/app.ts)" "이 코드의 잠재적 버그를 찾아줘" > review.md
```

**실습 7-2: CI/CD 파이프라인 통합**

```yaml
# .github/workflows/code-review.yml
name: AI Code Review
on: [pull_request]

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Review Changes
        run: |
          git diff origin/main...HEAD | \
          claude -p "변경된 코드를 리뷰하고 개선 사항을 제안해줘" \
          > ai-review.md
          
      - name: Post Comment
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const review = fs.readFileSync('ai-review.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: review
            });
```

**실습 7-3: 자동화 스크립트 작성**

```bash
# auto-doc.sh - 코드 변경 시 자동 문서화
#!/bin/bash

echo "문서 업데이트 중..."

# 변경된 파일 분석
changed_files=$(git diff --name-only HEAD~1)

# Claude로 문서 생성
echo "$changed_files" | while read file; do
  if [[ $file == *.ts ]] || [[ $file == *.js ]]; then
    claude -p "$(cat $file)" "이 파일의 API 문서를 마크다운으로 작성해줘" \
      > "docs/$(basename $file .ts).md"
  fi
done

echo "문서 업데이트 완료"
```

**실습 7-4: 배치 작업 처리**

```bash
# batch-refactor.sh
#!/bin/bash

# 여러 파일 일괄 리팩토링
find src -name "*.js" | while read file; do
  echo "Processing $file..."
  claude -p "$(cat $file)" "TypeScript로 변환하고 타입 안정성 개선해줘" \
    > "${file%.js}.ts"
done
```

---

### 8. /context로 토큰 사용 내역 확인

**개념**: `/context` 명령으로 컨텍스트 창에 무엇이 로드되어 있는지 확인하고 최적화합니다.

**실습 8-1: 컨텍스트 분석**

```bash
# 현재 컨텍스트 확인
/context

# 출력 예시 분석:
# - System Prompt: 5,000 tokens
# - CLAUDE.md: 2,000 tokens
# - MCP Server (PostgreSQL): 3,000 tokens
# - Active Files: 15,000 tokens
# - Conversation History: 25,000 tokens
# Total: 50,000 tokens
```

**실습 8-2: 토큰 최적화 전략**

```bash
# 1. 불필요한 파일 제거

# 2. MCP 서버 선택적 활성화

# 3. 대화 히스토리 정리
/clear  # 또는 새 세션 시작

# 4. 다시 확인
/context
# Total: 30,000 tokens (20,000 절약)
```

**실습 8-3: 장기 프로젝트 토큰 관리**

```bash
# 체크포인트 생성 (중요한 시점마다)
/checkpoint "인증 시스템 완성"

# 새 기능 시작 시 새 세션
claude --continue  # 간단한 이어하기
# 또는
claude --resume auth-feature  # 특정 세션 복원

# 토큰 한도 근접 시
/context  # 확인
# → 불필요한 요소 제거
# → 또는 새 세션에서 요약본으로 시작
```

---

### 9. --teleport로 웹과 터미널 오가기

**개념**: `--teleport` 명령으로 웹에서 시작한 세션을 로컬 터미널로 가져올 수 있습니다.

**실습 9-1: 웹에서 로컬로 가져오기**

```bash
# 1. 웹 브라우저에서 claude.ai/code 접속
# 2. 작업 시작 후 "Open in CLI" 버튼 클릭
# 3. 표시된 명령어 복사

# 4. 로컬 터미널에서 실행
claude --teleport abc123xyz

# 세션이 로컬로 이동하여 계속 작업 가능
"이제 로컬에서 작업 이어가기"
```

**실습 9-2: 모바일에서 시작, 데스크톱에서 완료**

```bash
# 출퇴근 중 모바일에서 시작
# → Claude iOS/Android 앱에서 작업 시작

# 사무실 도착 후
claude --teleport mobile-session-123

# 모바일에서 시작한 작업 이어가기
"이제 큰 화면에서 코드 확인하면서 작업"
```

**실습 9-3: 장시간 작업 패턴**

```bash
# 웹에서 30시간 이상 걸리는 대규모 작업 시작
# → claude.ai/code에서 "전체 모놀리스를 마이크로서비스로 분해"

# 주기적으로 로컬에서 확인
claude --teleport monolith-to-micro
/status  # 진행 상황 확인

# 필요시 개입
"데이터베이스 분할 전에 백업 스크립트 먼저 만들어줘"
```


---

## 확장성 및 커스터마이징

### 10. /stats로 사용 기록 보기

**개념**: `/stats` 명령으로 Claude Code 사용 패턴과 통계를 확인합니다.

**실습 10-1: 기본 통계 확인**

```bash
/stats

# 출력 예시:
# Claude Code 사용 통계
# =====================
# 총 세션: 156
# 총 프롬프트: 2,847
# 총 토큰 사용: 4,523,901
# 
# 이번 주:
#   세션: 23
#   프롬프트: 421
#   토큰: 687,234
#
# 오늘:
#   세션: 3
#   프롬프트: 47
#   토큰: 72,156
#
# 가장 많이 사용한 명령:
#   1. /context (89회)
#   2. !git status (67회)
#   3. /resume (45회)
```

**실습 10-2: 효율성 분석**

```bash
/stats --efficiency

# 효율성 지표
# ===========
# 평균 세션 길이: 38분
# 평균 프롬프트/세션: 18.2
# 평균 토큰/프롬프트: 1,589
# 
# 가장 생산적인 시간대:
#   오전 10-12시: 평균 25 프롬프트/세션
#   오후 2-4시:   평균 22 프롬프트/세션
#   저녁 8-10시:  평균 19 프롬프트/세션
#
# 권장사항:
#   - 오전 시간대에 복잡한 작업 배치
#   - 점심 후 컨텍스트 정리 (/context)
#   - 저녁에는 짧은 세션으로 작업
```

---

### 11. 세션에 이름 붙여서 관리하기

**개념**: `/rename` 명령으로 세션에 의미 있는 이름을 부여하여 나중에 쉽게 찾을 수 있습니다.

**실습 11-1: 네이밍 컨벤션**

```bash
# 기능별 네이밍
/rename feature-user-authentication
/rename bugfix-memory-leak
/rename refactor-database-layer

# 날짜 포함 네이밍
/rename 2024-12-api-migration
/rename sprint-23-tasks

# 프로젝트-작업 형식
/rename ecommerce-payment-integration
/rename blog-cms-upgrade
```

**실습 11-2: 체계적인 세션 관리 워크플로우**

```bash
# 1. 새 작업 시작 시 즉시 이름 지정
claude
"새로운 인증 시스템을 만들어보자"
/rename auth-system-v2

# 2. 작업 진행 중 체크포인트
/checkpoint "기본 로그인 완성"
/checkpoint "OAuth 통합 완료"
/checkpoint "테스트 추가"

# 3. 다른 작업으로 전환
claude --resume frontend-redesign

# 4. 다시 돌아오기
claude --resume auth-system-v2
"체크포인트부터 계속 진행"
```

**실습 11-3: 팀 협업을 위한 네이밍**

```bash
# 작업자 포함
/rename @jinyong-api-optimization

# 티켓 번호 포함
/rename TICKET-1234-database-migration

# 브랜치명과 동기화
/rename feature/user-profile-update
```

---

### 12. Ctrl+B로 백그라운드 작업 실행

**개념**: Claude가 명령을 실행할 때 Ctrl+B를 눌러 백그라운드로 전환하고 다른 작업을 계속할 수 있습니다.

**실습 12-1: 장기 실행 작업 백그라운드화**

```bash
# 1. 빌드 시작
"프로덕션 빌드 실행해줘"

# 2. Claude가 명령 실행 시작
# → Bash 도구 호출 중

# 3. Ctrl+B 입력
# → 백그라운드로 전환됨 (bash_1)

# 4. 다른 작업 계속
"새로운 API 엔드포인트 만들어줘"
```

**실습 12-2: 여러 작업 병렬 처리**

```bash
# 개발 서버 시작
"npm run dev 실행해줘"
[Ctrl+B]  # bash_1: 개발 서버 (백그라운드)

# 테스트 실행
"테스트 실행해줘"
[Ctrl+B]  # bash_2: 테스트 (백그라운드)

# 린팅
"eslint 실행해줘"
[Ctrl+B]  # bash_3: 린팅 (백그라운드)

# 모든 작업 상태 확인
/bashes
```

**실습 12-3: 백그라운드 작업 모니터링**

```bash
# 백그라운드 작업 목록 확인
/bashes

# 출력 예시:
# bash_1: npm run dev (running)
# bash_2: npm test (completed)
# bash_3: eslint . (failed)

# 특정 작업 출력 확인
"bash_1의 로그 보여줘"

# 작업 종료
"bash_1 종료해줘"
```

---

### 13. 프롬프트 임시 저장하기

**개념**: Ctrl+S로 작성 중인 프롬프트를 저장하여 다른 작업 후에도 복원할 수 있습니다.

**실습 13-1: 긴 프롬프트 작성**

```bash
# 1. 복잡한 요청 작성 시작
"다음 요구사항으로 REST API를 만들어줘:
- 사용자 인증 (JWT)
- 역할 기반 권한 관리
- "

# 2. 갑자기 긴급한 버그 수정 필요
Ctrl+S  # 프롬프트 저장

# 3. 긴급 작업
"지금 발생한 메모리 누수 버그 고쳐줘"

# 4. 긴급 작업 완료 후 자동 복원
# → 저장했던 프롬프트가 자동으로 다시 나타남
# → 이어서 작성:
"- 페이지네이션
- 에러 로깅
- API 문서 자동 생성"
```

**실습 13-2: 멀티태스킹 워크플로우**

```bash
# 시나리오: 리뷰 중 여러 개선 사항 발견

# 개선 사항 1 작성
"데이터베이스 쿼리를 최적화해줘:
1. N+1 쿼리 제거
2. 인덱스 추가
"
Ctrl+S  # 저장

# 개선 사항 2 처리
"먼저 이 타입 에러 고쳐줘"
# 완료

# 개선 사항 1 복원 및 완성
# (자동 복원됨)
"3. 쿼리 캐싱
4. 커넥션 풀 설정"
```

---

### 14. /statusline으로 하단 정보 바 꾸미기

**개념**: `/statusline` 명령으로 작업에 필요한 정보만 모아 보는 상태 바를 커스터마이즈합니다.

**실습 14-1: 기본 상태 바 설정**

```bash
# /statusline 실행하여 설정 열기
/statusline

# 표시할 정보 선택:
☑ Git branch
☑ Git status (clean/dirty)
☑ Current model
☑ Token usage
☑ Session name
☐ Time
☑ Project path

# 상태 바 예시:
# main ✓ | Sonnet 4.5 | 15K/200K | api-server | ~/projects/api
```

**실습 14-2: 작업 유형별 상태 바**

```bash
# 프론트엔드 작업용
☑ Git branch
☑ npm/yarn version
☑ Node version
☑ Dev server status
☑ Build status

# 백엔드 작업용
☑ Git branch
☑ Database connection
☑ API server status
☑ Test coverage
☑ Docker containers

# DevOps 작업용
☑ Kubernetes context
☑ AWS profile
☑ Terraform workspace
☑ CI/CD pipeline status
```

---

### 15. YOLO 모드로 빠른 실행

**개념**: `--dangerously-skip-permissions` 플래그로 권한 확인 없이 모든 명령을 즉시 실행합니다.

**⚠️ 주의**: 이 모드는 위험한 작업도 확인 없이 실행하므로 매우 조심해서 사용해야 합니다.

**실습 15-1: 안전한 환경에서 테스트**

```bash
# 테스트 환경 준비
mkdir -p /tmp/yolo-test
cd /tmp/yolo-test
git init

# YOLO 모드 실행
claude --dangerously-skip-permissions

# 빠른 프로토타이핑
"Express + MongoDB + JWT 인증 완전한 백엔드 만들어줘"
# → 권한 묻지 않고 즉시 실행:
#   - npm init
#   - 패키지 설치
#   - 파일 생성
#   - 서버 실행
```

**실습 15-2: CI/CD에서 사용**

```yaml
# .github/workflows/auto-update.yml
name: Auto Documentation Update

on:
  push:
    branches: [main]

jobs:
  update-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Update Documentation
        run: |
          # YOLO 모드로 자동 문서화
          claude --dangerously-skip-permissions -p \
            "모든 변경된 파일의 문서를 업데이트하고 커밋해줘"
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
```

**실습 15-3: 안전장치 추가**

```json
// YOLO 모드와 Hooks 조합
// .claude/settings.json
{
  "dangerousMode": {
    "enabled": true,
    "safeguards": [
      {
        "pattern": "rm.*node_modules",
        "action": "allow"
      },
      {
        "pattern": "rm.*-rf.*",
        "action": "block"  // 강제 삭제는 차단
      },
      {
        "pattern": "git push.*--force",
        "action": "block"
      }
    ]
  }
}
```


---

### 16. Hooks로 실행 흐름 제어하기

**개념**: 특정 시점에 자동으로 실행되는 쉘 명령으로, 위험한 작업 방지나 알림 발송 등을 자동화합니다.

**실습 16-1: 안전장치 설정**

```json
// .claude/settings.json
{
  "hooks": {
    "before_command": [
      {
        "pattern": "rm -rf",
        "action": "confirm",
        "message": "정말로 삭제하시겠습니까?"
      },
      {
        "pattern": "git push.*--force",
        "action": "block",
        "message": "force push는 허용되지 않습니다"
      }
    ]
  }
}
```

**실습 16-2: 자동 백업 Hook**

```json
{
  "hooks": {
    "before_file_write": [
      {
        "pattern": "src/critical/.*",
        "action": "exec",
        "command": "cp $FILE $FILE.backup-$(date +%s)"
      }
    ],
    "after_file_write": [
      {
        "pattern": "package.json",
        "action": "exec",
        "command": "npm install"
      }
    ]
  }
}
```

**실습 16-3: 알림 Hook**

```json
{
  "hooks": {
    "after_session_end": [
      {
        "action": "exec",
        "command": "osascript -e 'display notification \"Claude Code 세션 종료\" with title \"작업 완료\"'"
      }
    ],
    "on_error": [
      {
        "action": "exec",
        "command": "echo '오류 발생: $ERROR_MESSAGE' | mail -s 'Claude Code Error' you@example.com"
      }
    ]
  }
}
```

**실습 16-4: 품질 검사 Hook**

```json
{
  "hooks": {
    "before_git_commit": [
      {
        "action": "exec",
        "command": "npm test",
        "on_failure": "block"
      },
      {
        "action": "exec",
        "command": "npm run lint",
        "on_failure": "warn"
      },
      {
        "action": "exec",
        "command": "npm run type-check",
        "on_failure": "block"
      }
    ]
  }
}
```

---

### 17. @ 멘션으로 컨텍스트 빠르게 추가

**개념**: `@` 기호로 파일, 디렉토리, MCP 서버를 즉시 컨텍스트에 추가합니다.

**실습 17-1: 파일 및 디렉토리 참조**

```bash
# 특정 파일 참조

# 디렉토리 전체 참조

# 여러 파일 동시 참조
```

**실습 17-2: MCP 서버 활성화/비활성화**

```bash
# MCP 서버 켜기

# 작업 후 서버 끄기

# 필요할 때만 서브에이전트 활성화
```

**실습 17-3: 효율적인 컨텍스트 관리 패턴**

```bash
# 불필요한 컨텍스트 제거
/context  # 현재 컨텍스트 확인

# 필요한 것만 추가
```

---

### 18. 다음 프롬프트 자동 제안 받기

**개념**: 작업 완료 후 Claude가 다음 단계를 회색 글씨로 제안하며, Tab으로 수정하거나 Enter로 즉시 실행할 수 있습니다.

**실습 18-1: 제안 활용 워크플로우**

```bash
# 1단계: API 엔드포인트 생성
"사용자 등록 API를 만들어줘"

# Claude 작업 완료 후 제안 예시:
# → "이제 로그인 API를 만들어볼까요?"  (Tab으로 수정 가능)
# → "테스트 코드를 작성해드릴까요?"    (Enter로 즉시 실행)

# 2단계: 제안 수락 또는 수정
[Tab 누르기] → "로그인 API와 토큰 갱신 API를 함께 만들어줘"
```

**실습 18-2: 연속 작업 흐름 만들기**

```bash
"간단한 Todo 앱 백엔드를 만들어줘"
# → 제안: "프론트엔드도 만들어드릴까요?"

[Enter]
# → 제안: "Docker 설정을 추가해드릴까요?"

[Tab] → "Docker Compose로 PostgreSQL까지 설정해줘"
# → 제안: "README 문서를 작성해드릴까요?"

[Enter]
```

**팁**: 제안을 무시하고 새 요청을 입력하면 제안이 사라지고 새 프롬프트가 우선됩니다.




---

### 19. /chrome으로 브라우저 제어

**개념**: `/chrome` 명령으로 Claude가 브라우저를 직접 제어하여 UI 테스트와 디버깅을 자동화합니다.

**실습 19-1: 기본 브라우저 제어**

```bash
# Chrome 제어 시작
/chrome

# 페이지 열기
"localhost:3000 열어줘"

# 요소 클릭
"로그인 버튼 클릭해줘"

# 폼 입력
"사용자명 입력란에 'testuser' 입력해줘"
"비밀번호는 'test1234'"
"로그인 버튼 클릭"

# 결과 확인
"화면에 'Welcome testuser' 텍스트가 있는지 확인해줘"
```

**실습 19-2: E2E 테스트 자동화**

```bash
/chrome

"다음 시나리오를 테스트해줘:
1. localhost:3000 접속
2. '회원가입' 링크 클릭
3. 이메일, 비밀번호, 이름 입력
4. '가입하기' 버튼 클릭
5. '가입 완료' 메시지 확인
6. 자동으로 로그인되는지 확인
7. 대시보드가 로드되는지 확인
8. 스크린샷 저장"
```

**실습 19-3: 반응형 디자인 테스트**

```bash
/chrome

"반응형 디자인 테스트:
1. localhost:3000 열기
2. 뷰포트를 375x667 (iPhone SE)로 설정
3. 스크린샷 저장
4. 뷰포트를 768x1024 (iPad)로 설정
5. 스크린샷 저장
6. 뷰포트를 1920x1080 (Desktop)로 설정
7. 스크린샷 저장
8. 세 화면을 비교하여 레이아웃 문제 찾기"
```

---

### 20. Agent Skills로 작업 방식 재사용

**개념**: Agent Skills는 특정 작업 방법을 폴더로 패키징하여 여러 프로젝트에서 재사용 가능하게 만듭니다.

**실습 20-1: 첫 번째 Skill 만들기**

```bash
# 1. Skill 디렉토리 생성
mkdir -p ~/.claude/skills/code-review

# 2. SKILL.md 작성
cat > ~/.claude/skills/code-review/SKILL.md << 'EOF'
# Code Review Skill

이 스킬은 코드 리뷰를 체계적으로 수행합니다.

## 리뷰 체크리스트
1. 코드 스타일 및 컨벤션
2. 잠재적 버그 및 에러 핸들링
3. 성능 최적화 기회
4. 보안 취약점
5. 테스트 커버리지
6. 문서화 수준

## 출력 형식
- 심각도별 분류 (Critical/Major/Minor)
- 구체적인 개선 제안
- 코드 예시 포함
EOF

# 3. 사용하기
claude
```

**실습 20-2: API 설계 Skill**

```bash
mkdir -p ~/.claude/skills/api-design

cat > ~/.claude/skills/api-design/SKILL.md << 'EOF'
# API Design Skill

RESTful API 설계 Best Practices를 적용합니다.

## 설계 원칙
1. 리소스 기반 URL 구조
2. 적절한 HTTP 메서드 사용
3. 일관된 응답 형식
4. 적절한 상태 코드
5. 페이지네이션 및 필터링
6. API 버저닝
7. 에러 핸들링 표준

## 검증 항목
- URL 명명 규칙 (kebab-case)
- 복수형 리소스명 사용
- 하이퍼미디어 링크 포함
- Rate limiting 고려
- 문서화 (OpenAPI/Swagger)
EOF

# 사용 예시
```

---

### 21. 플러그인으로 설정 공유

**개념**: 명령어, 에이전트, 스킬, 훅, MCP 설정을 하나의 플러그인으로 패키징하여 팀원과 공유하거나 다른 머신에서 재사용합니다.

**실습 21-1: 플러그인 만들기**

```bash
# 1. 플러그인 디렉토리 구조 생성
mkdir -p my-dev-setup
cd my-dev-setup

# 2. 플러그인 메타데이터
cat > plugin.json << 'EOF'
{
  "name": "my-dev-setup",
  "version": "1.0.0",
  "description": "나의 개발 환경 설정",
  "author": "JinYong",
  "includes": [
    "skills",
    "hooks",
    "mcp-servers",
    "commands",
    "settings"
  ]
}
EOF

# 3. Skills 추가
mkdir -p skills
cp -r ~/.claude/skills/code-review skills/

# 4. 패키징
tar -czf my-dev-setup.tar.gz *
```

**실습 21-2: 플러그인 설치 및 사용**

```bash
# 다른 머신이나 프로젝트에서 설치
/plugin install my-dev-setup.tar.gz

# 설치된 플러그인 확인
/plugin list

# 플러그인 업데이트
/plugin update my-dev-setup
```


---

### 22. Ctrl+R로 이전 프롬프트 재사용

**개념**: Ctrl+R을 눌러 과거 프롬프트를 역방향 검색하고 재사용합니다.

**실습 22-1: 명령어 히스토리 검색**

```bash
# 1단계: 여러 작업 수행
"Express 서버 설정해줘"
"PostgreSQL 연결 추가해줘"
"JWT 인증 미들웨어 만들어줘"
"API 문서 생성해줘"

# 2단계: Ctrl+R 누르고 검색
Ctrl+R → "postgres" 입력
# → "PostgreSQL 연결 추가해줘" 자동 검색

# 3단계: 재사용 옵션
[Enter]  # 그대로 실행
[Tab]    # 수정 후 실행 → "PostgreSQL 연결 풀 설정 최적화해줘"
```

**실습 22-2: 반복 작업 패턴**

```bash
# 자주 사용하는 명령어 패턴
"@src/ 전체 코드에서 TODO 주석 찾아줘"
# 나중에 Ctrl+R → "TODO" 검색하여 재사용

"!git diff | 변경사항 요약해줘"
# Ctrl+R → "git diff" 검색하여 반복 사용

"테스트 커버리지 80% 이상 되도록 테스트 추가해줘"
# Ctrl+R → "테스트" 검색하여 다른 모듈에 적용
```

---

### 23. Shift+Tab으로 권한 모드 전환

**개념**: Shift+Tab을 눌러 Auto-Accept, Plan Mode, Normal Mode 사이를 전환합니다.

**실습 23-1: 모드 전환 이해하기**

```bash
# Normal Mode (기본값)
# → 모든 변경사항을 확인하고 승인

# Shift+Tab 한 번
# → Plan Mode
# → 계획만 세우고 실행 안 함

# Shift+Tab 두 번
# → Auto-Accept Mode
# → 모든 변경사항 자동 승인

# Shift+Tab 세 번
# → 다시 Normal Mode로 복귀
```

**실습 23-2: Plan Mode로 안전하게 계획 수립**

```bash
# Plan Mode 활성화
[Shift+Tab] [Shift+Tab]  # Plan Mode 표시

# 복잡한 리팩토링 계획
"전체 인증 시스템을 JWT에서 OAuth2로 마이그레이션해줘"

# Claude가 계획만 수립:
# 1. 현재 JWT 구현 분석
# 2. OAuth2 프로바이더 선택 (Google, GitHub 등)
# 3. 마이그레이션 단계별 계획
# 4. 롤백 전략
# 5. 테스트 계획

# 계획 검토 후 실행 결정
[Shift+Tab]  # Normal Mode로 전환
"계획대로 실행해줘"
```

**실습 23-3: Auto-Accept Mode로 빠른 실행**

```bash
# Auto-Accept Mode 활성화
[Shift+Tab]  # Auto-Accept Mode 표시

# 신뢰할 수 있는 작업 실행
"모든 파일에 prettier 적용하고 커밋해줘"

# Claude가 자동으로:
# - 모든 파일 포맷팅
# - git add
# - commit 생성
# - 모두 승인 없이 실행

# 작업 완료 후 일반 모드로 복귀
[Shift+Tab] [Shift+Tab]  # Normal Mode
```

**실습 23-4: 모드별 활용 전략**

```bash
# Normal Mode 사용 시기:
# - 처음 시도하는 작업
# - 중요한 파일 수정
# - 프로덕션 코드 변경

# Plan Mode 사용 시기:
# - 대규모 리팩토링 전
# - 아키텍처 변경 검토
# - 복잡한 마이그레이션 계획

# Auto-Accept Mode 사용 시기:
# - 반복적인 단순 작업
# - 포맷팅, 린팅
# - 자동화된 테스트 실행
# - 문서 생성
```

---

## 실전 프로젝트 실습

### 프로젝트 1: 풀스택 Todo 앱 구축

**목표**: Claude Code의 핵심 기능을 조합하여 완전한 웹 애플리케이션을 만듭니다.

**실습 1-1: 프로젝트 초기화**

```bash
# 새 프로젝트 시작
mkdir fullstack-todo
cd fullstack-todo
claude

# 세션 이름 지정
/rename fullstack-todo-project

# 프로젝트 규칙 설정
# TypeScript + React + Express + PostgreSQL 스택 사용
# TDD 방식으로 개발
# REST API 설계 원칙 준수
# Prettier + ESLint 자동 적용

# 프로젝트 구조 생성
"풀스택 Todo 앱을 위한 모노레포 구조를 만들어줘:
- apps/frontend (React + Vite)
- apps/backend (Express + TypeScript)
- packages/shared (공통 타입)
- Docker Compose 설정"
```

**실습 1-2: 백엔드 개발 (Plan Mode 활용)**

```bash
# Plan Mode로 전환
[Shift+Tab] [Shift+Tab]

# 백엔드 아키텍처 계획
"백엔드 API 설계 계획을 세워줘:
- RESTful 엔드포인트
- 데이터베이스 스키마
- 인증/인가
- 에러 핸들링"

# 계획 검토 후 실행
[Shift+Tab]
"계획대로 구현해줘"

# 백그라운드로 테스트 실행
"백엔드 테스트 실행해줘"
[Ctrl+B]  # bash_1: 테스트 (백그라운드)
```

**실습 1-3: 프론트엔드 개발 (Skill 활용)**

```bash
# React 최적화 Skill 생성
!mkdir -p ~/.claude/skills/react-best-practices

# Skill 사용

# 개발 서버 백그라운드 실행
"프론트엔드 개발 서버 실행해줘"
[Ctrl+B]  # bash_2: dev server

# Chrome으로 UI 테스트
/chrome
"localhost:3000 열어서 Todo 추가/삭제/완료 기능 테스트해줘"
```

**실습 1-4: 통합 및 배포 (Hooks 활용)**

```bash
# 커밋 전 자동 검사 Hook 설정
!cat > .claude/settings.json << 'EOF'
{
  "hooks": {
    "before_git_commit": [
      { "action": "exec", "command": "npm test", "on_failure": "block" },
      { "action": "exec", "command": "npm run lint", "on_failure": "block" },
      { "action": "exec", "command": "npm run type-check", "on_failure": "block" }
    ]
  }
}
EOF

# Docker 배포 설정
"Docker Compose로 전체 스택 배포 설정 만들어줘"

# 체크포인트 생성
/checkpoint "배포 준비 완료"
```

---

### 프로젝트 2: CI/CD 파이프라인 구축

**목표**: Headless 모드와 자동화 기능을 활용하여 완전한 CI/CD 파이프라인을 만듭니다.

**실습 2-1: GitHub Actions 워크플로우**

```bash
# 새 세션
claude
/rename cicd-pipeline-setup

# Headless 모드로 워크플로우 생성
claude -p "GitHub Actions 워크플로우를 만들어줘:
1. PR 시 자동 코드 리뷰
2. 테스트 실행 및 커버리지 체크
3. 린팅 및 타입 체크
4. main 브랜치 머지 시 자동 배포
5. Slack 알림" > .github/workflows/ci.yml
```

**실습 2-2: 자동 문서화 파이프라인**

```bash
# 문서 자동 생성 스크립트
cat > .github/workflows/docs.yml << 'EOF'
name: Auto Documentation

on:
  push:
    paths:
      - 'src/**/*.ts'
      - 'src/**/*.tsx'

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Generate Documentation
        run: |
          claude --dangerously-skip-permissions -p \
            "@src/ 모든 파일의 API 문서를 생성하고 docs/ 폴더에 저장해줘"
      
      - name: Commit Documentation
        run: |
          git config user.name "Claude Bot"
          git config user.email "bot@claude.ai"
          git add docs/
          git commit -m "docs: 자동 생성된 API 문서" || true
          git push
EOF
```

---

### 프로젝트 3: 레거시 코드 마이그레이션

**목표**: 대규모 레거시 프로젝트를 현대적인 스택으로 마이그레이션합니다.

**실습 3-1: 분석 및 계획**

```bash
# 새 세션
claude
/rename legacy-migration

# Extended Thinking으로 분석
[Tab]  # Thinking on

"이 레거시 jQuery 프로젝트를 React + TypeScript로 마이그레이션하는 
단계별 계획을 세워줘. 리스크와 대응 방안도 포함해줘."

# 분석 결과를 메모리에 저장
# 마이그레이션 전략: 점진적 리팩토링 (Strangler Fig 패턴)
# 우선순위: 핵심 비즈니스 로직 > UI 컴포넌트 > 유틸리티
```

**실습 3-2: 점진적 마이그레이션**

```bash
# Skill 생성
mkdir -p ~/.claude/skills/legacy-migration

# Plan Mode로 단계별 실행
[Shift+Tab] [Shift+Tab]  # Plan Mode

"첫 번째 단계: 공통 유틸리티 함수를 TypeScript로 변환해줘"

# 계획 검토
# Auto-Accept Mode로 실행
[Shift+Tab]  # Auto-Accept

"계획대로 실행해줘"

# 다음 단계
/checkpoint "유틸리티 마이그레이션 완료"

# 백그라운드로 테스트
"기존 테스트 모두 실행해줘"
[Ctrl+B]
```

**실습 3-3: 품질 보증**

```bash
# Hook으로 자동 검증
!cat > .claude/settings.json << 'EOF'
{
  "hooks": {
    "after_file_write": [
      {
        "pattern": ".*\\.tsx?$",
        "action": "exec",
        "command": "tsc --noEmit $FILE && eslint $FILE"
      }
    ],
    "before_git_commit": [
      {
        "action": "exec",
        "command": "npm test -- --changed",
        "on_failure": "block"
      }
    ]
  }
}
EOF

# 마이그레이션 완료 보고서
"마이그레이션 완료 보고서를 마크다운으로 작성해줘:
- 변경된 파일 목록
- 테스트 커버리지 변화
- 성능 개선 사항
- 남은 작업"
```

---

### 프로젝트 4: 팀 플러그인 배포

**목표**: 팀 전체가 사용할 표준 개발 환경 플러그인을 만들고 배포합니다.

**실습 4-1: 플러그인 설계**

```bash
# 새 플러그인 프로젝트
mkdir team-standards-plugin
cd team-standards-plugin

claude
/rename team-plugin-development

# 플러그인 구조
"다음을 포함하는 팀 플러그인을 만들어줘:
1. 코드 리뷰 Skill
2. API 설계 Skill
3. 데이터베이스 마이그레이션 Skill
4. 안전 Hooks (위험한 명령 차단)
5. 자동 포맷팅 Hooks
6. Slack, PostgreSQL, AWS MCP 설정
7. 커스텀 slash commands"
```

**실습 4-2: Skill 패키징**

```bash
# 코드 리뷰 Skill
mkdir -p skills/code-review
cat > skills/code-review/SKILL.md << 'EOF'
# 팀 코드 리뷰 표준

## 체크리스트
1. 코딩 컨벤션 (Airbnb style guide)
2. TypeScript strict mode 사용
3. 테스트 커버리지 80% 이상
4. 에러 핸들링 (try-catch 또는 Result 타입)
5. 보안 (SQL injection, XSS 방지)
6. 성능 (불필요한 렌더링, N+1 쿼리 방지)
7. 접근성 (WCAG 2.1 AA 기준)

## 출력 형식
Markdown 표 형식으로 심각도별 분류
EOF

# API 설계 Skill
mkdir -p skills/api-design
# ... (이전 예제 참조)

# 데이터베이스 Skill
mkdir -p skills/database
# ... (이전 예제 참조)
```

**실습 4-3: Hook 설정**

```bash
# 안전 Hooks
mkdir -p hooks
cat > hooks/safety.json << 'EOF'
{
  "before_command": [
    {
      "pattern": "rm -rf /",
      "action": "block",
      "message": "루트 디렉토리 삭제는 허용되지 않습니다"
    },
    {
      "pattern": "git push.*--force",
      "action": "confirm",
      "message": "force push하시겠습니까? 다른 팀원의 작업이 손실될 수 있습니다"
    },
    {
      "pattern": "npm publish",
      "action": "confirm",
      "message": "패키지를 배포하시겠습니까?"
    }
  ],
  "after_file_write": [
    {
      "pattern": ".*\\.(ts|tsx|js|jsx)$",
      "action": "exec",
      "command": "prettier --write $FILE && eslint --fix $FILE"
    }
  ]
}
EOF
```

**실습 4-4: 플러그인 배포**

```bash
# 플러그인 메타데이터
cat > plugin.json << 'EOF'
{
  "name": "team-standards",
  "version": "2.0.0",
  "description": "팀 개발 표준 및 베스트 프랙티스",
  "author": "Engineering Team",
  "repository": "https://github.com/company/team-standards-plugin",
  "includes": ["skills", "hooks", "mcp-servers", "commands"]
}
EOF

# README 생성
"이 플러그인의 README.md를 작성해줘:
- 설치 방법
- 포함된 기능 설명
- 사용 예시
- 문제 해결 가이드"

# 패키징 및 배포
tar -czf team-standards-v2.0.0.tar.gz *

# GitHub Release로 배포
!gh release create v2.0.0 team-standards-v2.0.0.tar.gz
```

**실습 4-5: 팀원 온보딩**

```bash
# 팀원들은 간단히 설치
/plugin install https://github.com/company/team-standards-plugin/releases/latest/download/team-standards.tar.gz

# 설치 확인
/plugin list

# 즉시 사용 가능
```

---

## 베스트 프랙티스 요약

### 효율성 극대화

1. **! 프리픽스** - 간단한 명령은 직접 실행
2. **@ 멘션** - 필요한 컨텍스트만 선택적 추가
3. **/context** - 주기적으로 토큰 사용량 확인
4. **Ctrl+R** - 반복 작업은 히스토리에서 재사용
5. **백그라운드 작업** - 장기 실행 작업은 Ctrl+B

### 품질 보증

1. **Plan Mode** - 복잡한 작업은 계획 먼저
2. **Hooks** - 위험한 작업 자동 차단
3. **Skills** - 표준화된 품질 기준 적용
4. **체크포인트** - 중요 시점마다 저장
5. **/chrome** - UI는 실제로 테스트

### 팀 협업

1. **CLAUDE.md** - Git으로 팀 지식 공유
2. **플러그인** - 설정과 워크플로우 표준화
3. **세션 네이밍** - 일관된 이름 규칙 사용
4. **-p 모드** - CI/CD 파이프라인 통합
5. **MCP 공유** - .mcp.json 체크인

### 토큰 최적화

1. **# 메모리** - 반복 지시사항은 한 번만
2. **Slash commands** - 자주 쓰는 프롬프트 자동화
3. **! 직접 실행** - Claude 추론 건너뛰기
4. **컨텍스트 관리** - 불필요한 파일 제거
5. **/clear** - 긴 대화는 정리 후 재시작

---

## 문제 해결 가이드

### 토큰 한도 초과

```bash
# 문제: "Context window exceeded" 에러

# 해결 1: 컨텍스트 정리
/context

# 해결 2: 새 세션 시작
/checkpoint "현재까지 작업"
/clear
"이전 작업 요약: [간단히 설명]"

# 해결 3: Subagent 사용
# 독립적인 작업은 별도 세션으로 분리
```

### 세션 복원 실패

```bash
# 문제: --resume이 작동하지 않음

# 해결 1: 세션 목록 확인
/resume

# 해결 2: 세션 파일 확인
!ls ~/.claude/sessions/

# 해결 3: 최근 세션 복원
claude --continue
```

### Hook 실행 안 됨

```bash
# 문제: Hook이 트리거되지 않음

# 해결 1: 설정 파일 확인
!cat .claude/settings.json

# 해결 2: Hook 재로드
/reload-hooks

# 해결 3: 권한 확인
!chmod +x .claude/hooks/*.sh
```

---

## 다음 단계

### 고급 주제 학습

1. **MCP 서버 개발** - 커스텀 도구 통합
2. **Subagent 고급 활용** - 복잡한 워크플로우 자동화
3. **플러그인 배포** - NPM 또는 GitHub Packages
4. **성능 최적화** - 대규모 프로젝트 관리

### 커뮤니티 참여

1. **공식 문서** - [code.claude.com/docs](https://code.claude.com/docs)
2. **GitHub Discussions** - 질문과 아이디어 공유
3. **Discord** - 실시간 도움말
4. **플러그인 마켓플레이스** - 유용한 플러그인 탐색

---

## 부록

### 단축키 치트시트

| 단축키 | 기능 | 섹션 |
|--------|------|------|
| `!` | 직접 명령 실행 | [1](#1-프리픽스로-터미널-즉시-실행) |
| `Esc Esc` | 되돌리기 | [2](#2-esc-두-번으로-이전-상태-되돌리기) |
| `Tab` | Extended Thinking | [3](#3-extended-thinking으로-깊은-추론) |
| `#` | 메모리 저장 | [5](#5-프리픽스로-메모리-즉시-저장) |
| `@` | 컨텍스트 추가 | [17](#17-멘션으로-컨텍스트-빠르게-추가) |
| `Ctrl+R` | 히스토리 검색 | [22](#22-ctrlr로-이전-프롬프트-재사용) |
| `Ctrl+S` | 프롬프트 저장 | [13](#13-프롬프트-임시-저장하기) |
| `Ctrl+B` | 백그라운드 실행 | [12](#12-ctrlb로-백그라운드-작업-실행) |
| `Shift+Tab` | 권한 모드 전환 | [23](#23-shifttab으로-권한-모드-전환) |

### 명령어 치트시트

| 명령어 | 기능 | 섹션 |
|--------|------|------|
| `/context` | 컨텍스트 확인 | [8](#8-context로-토큰-사용-내역-확인) |
| `/clear` | 대화 정리 | - |
| `/checkpoint` | 체크포인트 생성 | - |
| `/resume` | 세션 복원 | [4](#4-continue와-resume으로-세션-이어가기) |
| `/rename` | 세션 이름 변경 | [11](#11-세션에-이름-붙여서-관리하기) |
| `/vim` | Vim 편집기 | [6](#6-vim으로-프롬프트-편집) |
| `/chrome` | 브라우저 제어 | [19](#19-chrome으로-브라우저-제어) |
| `/stats` | 사용 통계 | [10](#10-stats로-사용-기록-보기) |
| `/statusline` | 상태 바 설정 | [14](#14-statusline으로-하단-정보-바-꾸미기) |
| `/bashes` | 백그라운드 작업 목록 | [12](#12-ctrlb로-백그라운드-작업-실행) |

---

**버전**: 1.0.0  
**최종 업데이트**: 2026-01-06  
**작성자**: Claude Code 개발팀  

**라이선스**: MIT  
**기여**: [GitHub에서 기여하기](https://github.com/anthropics/claude-code)