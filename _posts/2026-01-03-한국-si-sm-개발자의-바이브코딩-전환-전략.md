---
title: "한국 SI/SM 개발자의 바이브코딩 전환 전략"
date: 2026-01-03 09:00:00 +0900
categories: [AI,  Material]
tags: [AI,  vibe-coding, ,  Developer,  Claude.write]
---


> **5년차/10년차 개발자가 레거시 경험을 AI 시대의 최강 무기로 바꾸는 법**

## 들어가며: 당신의 레거시 경험은 이미 자산이다

2026년 1월, 한국 SI/SM 업계에서 5년, 10년을 일해온 개발자들은 비슷한 고민에 빠져 있습니다. "AI 코딩 도구들이 대세인데, 나는 아직도 레거시 시스템만 만지고 있다. 너무 늦은 건 아닐까?"

하지만 실제 데이터는 정반대입니다. **레거시 시스템 경험이 있는 시니어 개발자야말로 AI 시대에 가장 가치 있는 인재**입니다. 왜일까요?

2025년 주요 사례들을 보면:
- **Morgan Stanley**: GPT 기반 시스템으로 900만 줄의 레거시 코드 변환, 28만 개발자 시간 절약
- **EY**: COBOL에서 Python/Java로 마이그레이션, GenAI로 85% 변환 정확도 달성
- **NTT DATA**: 레거시 리팩토링을 GenAI로 진행, 기존 대비 2/3 시간으로 단축

이 프로젝트들의 공통점은? **AI는 코드를 변환하지만, 비즈니스 로직을 이해하고 아키텍처를 결정하는 건 레거시를 아는 시니어 개발자들**이었습니다.

이 문서는 당신이 지난 5-10년간 쌓은 레거시 경험을 AI 시대의 최강 무기로 전환하는 구체적인 방법을 제시합니다.

---

## Chapter 1: 한국 SI/SM 개발자의 숨겨진 강점

### 당신이 이미 가진 것들

5-10년차 한국 SI/SM 개발자라면 다음과 같은 경험이 있을 겁니다:

**1. 레거시 시스템의 실전 경험**
- 전자정부 프레임워크 (eGov Framework)
- Spring Framework 3.x/4.x (10년 넘은 버전)
- Oracle 9i/10g 스토어드 프로시저
- JSP + iBatis/MyBatis
- Java 6/7 기반 애플리케이션
- Struts 1.x 프레임워크
- JEUS/WebLogic 같은 WAS

**2. 복잡한 비즈니스 로직 파악 능력**
- 금융권 정산 로직 (주석도 없는 1000줄짜리 메서드)
- 공공기관 민원 처리 프로세스
- 제조업 ERP 연동 로직
- 보험 상품 계산 엔진

**3. 문서 없는 시스템 분석 능력**
- "원작자는 이미 퇴사했고 주석도 없습니다"
- "이 코드가 왜 이렇게 짜여있는지 아무도 모릅니다"
- "DB 테이블이 500개가 넘는데 ERD가 없습니다"

**4. 멀티태스킹과 압박 대응**
- 3개 프로젝트 동시 투입
- "내일까지 급하게" 요구사항 대응
- 야근과 주말 근무 경험

### 왜 이것들이 AI 시대에 강점인가?

**MIT Technology Review (2025년 12월)** 보고서에 따르면:
- 22-25세 개발자 고용률이 2022년 대비 20% 감소 (AI 도구 대중화와 동시)
- 하지만 **시니어 개발자 수요는 오히려 증가**

이유는 명확합니다:

1. **AI는 코드를 잘 짜지만, 비즈니스 컨텍스트를 모른다**
   - "이 계산식은 왜 이렇게 복잡할까?" → 시니어는 안다 (2015년 금융 규제 때문)
   - "이 테이블 구조는 왜 이상할까?" → 시니어는 안다 (레거시 마이그레이션 중간 단계)

2. **AI는 레거시 언어를 변환하지만, 변환 전략은 세우지 못한다**
   - PL/SQL 5000줄을 어떻게 나눌 것인가?
   - 어떤 스토어드 프로시저부터 마이그레이션할 것인가?
   - 리스크는 어떻게 관리할 것인가?

3. **AI는 실수하고, 시니어가 검증한다**
   - Stack Overflow 2025 조사: 65%가 AI 도구를 쓰지만, **대부분 경험 많은 개발자가 검증**
   - AI가 만든 코드의 보안 취약점을 찾는 건 시니어의 몫

**결론**: 레거시 경험은 짐이 아니라 **AI를 제대로 활용할 수 있는 유일한 자격**입니다.

---

## Chapter 2: 5년차 vs 10년차, 각자의 전환 전략

### 5년차 개발자 (2020년 입사)

**당신의 프로필**:
- Java 8/11, Spring Boot 2.x
- 마이크로서비스 일부 경험
- 클라우드 경험 제한적 (AWS/GCP 기본만)
- 레거시 유지보수 + 신규 개발 병행
- IntelliJ 또는 Eclipse 사용

**전환 전략**:

#### Step 1: Cursor로 시작 (첫 1개월)

**왜 Cursor인가?**
- IntelliJ에서 VS Code로 전환이 가장 큰 장벽
- Cursor는 VS Code 기반이라 러닝 커브가 낮음
- $20/월로 부담 없음

**1주차 - Tab 완성에 익숙해지기**
```java
// 기존 방식: 직접 타이핑
public List<User> findUsersByStatus(String status) {
    return userRepository.findByStatus(status);
}

// Cursor 방식: 주석만 적으면 Tab으로 자동완성
// 상태별 사용자 조회 메서드
public [Tab] → 자동으로 완성
```

**실전 연습 과제**:
- 회사 프로젝트의 간단한 CRUD API 하나를 Cursor로 다시 작성
- 기존 코드와 비교해서 얼마나 빨라졌는지 측정

**2주차 - Cmd+K (인라인 수정) 마스터**
```java
// 기존 코드 선택 후 Cmd+K
public String processPayment(Payment payment) {
    // 100줄의 복잡한 결제 로직
}

// 프롬프트: "이 메서드에 트랜잭션 추가하고, 예외 처리 강화해줘"
// → 1초 만에 수정됨
```

**실전 연습 과제**:
- 레거시 코드 중 리팩토링이 필요한 메서드 10개 선정
- Cmd+K로 개선 (예외 처리, 로깅 추가, 성능 개선)

**3-4주차 - Agent Mode 활용**
```
User: UserService의 모든 메서드에 캐싱 추가해줘.
Redis 사용하고, TTL은 10분으로.

Cursor Agent: [자동으로 여러 파일 수정]
✓ UserService.java 수정
✓ CacheConfig.java 생성
✓ pom.xml에 의존성 추가
✓ application.yml에 Redis 설정 추가
```

**실전 연습 과제**:
- 회사 프로젝트의 작은 기능 하나를 Agent Mode로 완성
- 로그인 기능, 파일 업로드, 이메일 발송 등

**1개월 후 체감**:
- 단순 반복 작업 50% 감소
- "이거 어떻게 하더라?" 검색 시간 80% 감소
- 퇴근 시간 30분-1시간 당겨짐

#### Step 2: Claude Code 추가 (2-3개월차)

**왜 이제 Claude Code인가?**
- Cursor로 속도감을 느낌
- 이제 더 복잡한 작업도 AI에게 맡기고 싶음
- 터미널 사용이 익숙해짐 (Cursor 쓰면서 자연스럽게)

**첫 프로젝트: 레거시 API 리팩토링**

현장 예시:
```bash
claude --model opusplan

User: 우리 회사 UserController를 분석해줘.
- REST API 규칙 위반 찾기
- 중복 코드 찾기
- 성능 개선 포인트 제안

Claude (Plan Mode):
분석 계획:
1. 모든 엔드포인트 스캔
2. HTTP 메서드 사용 패턴 분석
3. 트랜잭션 범위 검토
4. N+1 쿼리 문제 탐지

진행할까요?

User: Yes

Claude:
발견된 문제 (10개):
1. GET /users/delete/{id} → DELETE로 변경 필요
2. findUserById()에서 N+1 쿼리 발생
3. 트랜잭션 범위 너무 넓음 (line 45-89)
...

각 문제별 해결 방안 제시
```

**2-3개월차 핵심 학습**:
- Plan Mode로 큰 그림 그리기
- opusplan으로 비용 절약하면서 품질 유지
- CLAUDE.md 작성 (회사 코딩 규칙 문서화)

**실전 프로젝트**:
- 레거시 컨트롤러 3개를 현대적인 REST API로 리팩토링
- 스토어드 프로시저 1개를 Java로 변환
- 주석 없는 복잡한 메서드 10개에 JavaDoc 자동 생성

**3개월 후 체감**:
- 복잡한 리팩토링도 두렵지 않음
- 아키텍처 개선 아이디어가 빠르게 검증됨
- 야근 빈도 50% 감소

#### Step 3: 업무 적용 및 확장 (4-6개월차)

**이제 회사에서 인정받을 차례**

**프로젝트 1: 레거시 마이그레이션 제안**
```markdown
# 제안서: XX 시스템 API 현대화

## 현황
- JSP + iBatis 기반 (2010년 개발)
- 유지보수 비용 증가 (월 200시간)

## 제안
- Spring Boot + JPA로 전환
- Claude Code 활용 시 예상 기간: 2개월
- 기존 방식 예상 기간: 6개월

## 시범 적용 결과
- 사용자 관리 모듈 마이그레이션
- 소요 시간: 1주 (기존 예상: 3주)
- 버그: 0건 (AI 검증 + 자동 테스트)
```

**프로젝트 2: 팀 내 AI 도구 전파**
- 주간 "AI 코딩 Tip" 세션 운영
- .cursorrules 템플릿 공유
- CLAUDE.md 가이드 작성

**6개월 후 목표**:
- 팀 리드 또는 시니어 개발자로 인정
- AI 활용 전문가로 포지셔닝
- 연봉 협상 카드 확보

---

### 10년차 개발자 (2015년 입사)

**당신의 프로필**:
- Java 6/7/8 모두 경험
- Struts, Spring 3.x → Spring Boot 마이그레이션 경험
- 대규모 시스템 아키텍처 이해
- 팀 리드 또는 PA(Project Architecture) 역할
- 레거시 시스템의 "살아있는 역사"

**전환 전략**:

#### Step 1: 전략적 접근 - 관리자의 시각 (첫 1개월)

**10년차의 가장 큰 자산**: 비즈니스 컨텍스트 이해

**1주차 - Cursor 빠른 습득**
5년차와 달리, 당신은 이미 많은 패턴을 알고 있습니다. Cursor는 그 패턴을 빠르게 적용하는 도구로 사용하세요.

```java
// 당신이 머릿속에 있는 패턴을 즉시 구현
User: "전자정부 프레임워크 스타일로 UserService 만들어줘.
- EgovAbstractServiceImpl 상속
- @Service 어노테이션
- logger는 LoggerFactory
- 예외는 EgovBizException

Cursor: [당신의 10년 노하우를 1분 만에 코드로]
```

**2주차 - Claude Code로 전략 수립**

**시나리오**: 회사의 15년 된 시스템 분석

```bash
claude --model opusplan

User: 우리 회사 핵심 시스템을 분석하려고 해.
- 300개 JSP 파일
- 150개 Java 클래스
- 80개 스토어드 프로시저

현대화 전략을 수립해줘.

Claude (Plan Mode):
분석 프레임워크:

1. 의존성 매핑 (1-2일)
   - 어떤 JSP가 어떤 비즈니스 로직 호출?
   - 스토어드 프로시저 사용 빈도
   
2. 비즈니스 크리티컬 모듈 식별 (3일)
   - 트랜잭션 분석
   - 사용 빈도 분석
   
3. 마이그레이션 우선순위 (1일)
   - 리스크 vs 가치 매트릭스
   
4. 단계별 로드맵 (1일)
   - Phase 1: 독립적인 모듈 (저위험)
   - Phase 2: 핵심 비즈니스 (고가치)
   - Phase 3: 레거시 제거
```

**3-4주차 - 아키텍처 결정**

**핵심 깨달음**: AI는 제안하지만, 최종 결정은 당신이 합니다.

```bash
User: Phase 1 모듈 중 "공지사항 관리"를 먼저 마이그레이션하려고 해.
리스크 분석해줘.

Claude:
분석 결과:

Low Risk:
✓ 다른 모듈과 의존성 최소
✓ 트래픽 낮음 (월 1000건)
✓ 비즈니스 로직 단순

Moderate Risk:
⚠ 첨부파일 처리 로직 (레거시 파일 서버 연동)

High Risk:
✗ 발견되지 않음

권장사항: Go ahead
예상 기간: 1주
필요 리소스: 개발자 1명

User: 좋아, 그런데 첨부파일 부분은 어떻게 처리할까?

Claude:
3가지 옵션:

Option 1: 기존 레거시 서버 그대로 사용
- 장점: 위험 최소
- 단점: 기술 부채 유지

Option 2: 클라우드 스토리지로 전환 (AWS S3)
- 장점: 현대적 아키텍처
- 단점: 기존 파일 마이그레이션 필요

Option 3: 하이브리드 (신규는 S3, 기존은 레거시)
- 장점: 점진적 전환
- 단점: 복잡도 증가

추천: Option 3 (리스크 분산)
```

**이것이 10년차의 가치**: AI가 옵션을 제시하면, 당신은 비즈니스 컨텍스트로 결정합니다.

**1개월 후 포지션**:
- 팀의 AI 전환 리더
- 아키텍처 결정권자로서 AI 활용
- PM/이해관계자와 AI 도입 협의

#### Step 2: 팀 레벨 확장 (2-4개월차)

**이제 개인이 아니라 팀 차원의 전환**

**프로젝트: 팀 AI 도입 전략**

**1단계: 파일럿 팀 구성**
- 관심있는 개발자 3-4명
- Cursor Pro ($20) 지원 요청
- 주간 학습 세션

**2단계: 표준 확립**
```markdown
# 팀 AI 코딩 가이드라인

## 필수 룰
1. CLAUDE.md 작성 (프로젝트별)
2. AI 생성 코드도 코드 리뷰 필수
3. 보안 관련 코드는 수동 검증

## 권장 사항
- 단순 CRUD: Cursor Agent
- 복잡한 로직: Claude Code Plan
- 최종 검증: 시니어 리뷰

## 금지 사항
- AI에게 DB 비밀번호 노출 금지
- 고객 데이터 예시로 사용 금지
```

**3단계: 성과 측정**
```
Before (AI 도입 전):
- 기능 개발: 평균 3일
- 버그 수: 기능당 2.5개
- 코드 리뷰: 30분

After (AI 도입 후 3개월):
- 기능 개발: 평균 1.5일 (50% 단축)
- 버그 수: 기능당 1.2개 (52% 감소)
- 코드 리뷰: 15분 (AI가 기본 체크)
```

**4개월 후 성과**:
- 팀 생산성 40% 향상
- 야근 60% 감소
- 팀원 만족도 상승
- 경영진에게 AI ROI 증명

#### Step 3: 조직 차원 전환 리더 (5-12개월차)

**CTO/임원진 설득**

**제안서 예시**:
```markdown
# AI 코딩 도구 전사 도입 제안

## Executive Summary
- 투자: 월 $2,000 (개발자 100명 기준)
- 예상 절감: 월 $50,000 (인건비 환산)
- ROI: 2,400%

## 시범 운영 결과 (4개월)
- 참여 인원: 15명
- 생산성 향상: 평균 47%
- 버그 감소: 52%
- 퇴사율 감소: 30% (업무 만족도 향상)

## 단계별 확산 계획
Phase 1 (1-3개월): Early Adopters 50명
Phase 2 (4-6개월): 전체 개발팀
Phase 3 (7-12개월): 조직 표준화

## 리스크 관리
- 보안: Private 모델 도입 옵션
- 의존성: 기존 개발 역량 유지 정책
- 교육: 단계별 트레이닝 프로그램
```

**12개월 후 도달점**:
- AI Transformation Leader로 포지셔닝
- 조직의 핵심 인재로 인정
- 업계 컨퍼런스 발표 기회
- 이직 시 프리미엄 (연봉 30%+ 상승)

---

## Chapter 3: 레거시 전문가만의 특별한 활용법

### 시나리오 1: COBOL → Java 마이그레이션

**당신의 상황**:
- 금융권 메인프레임 COBOL 코드
- 비즈니스 로직 아는 사람 2명뿐 (1명은 곧 퇴직)
- 마이그레이션 기간: 2년 예상

**AI 활용 전략**:

**Step 1: 비즈니스 로직 문서화 (Claude Code)**

```bash
claude --model opusplan

User: COBOL 코드 첨부.
이 코드의 비즈니스 로직을 한글로 설명해줘.
금융 용어도 설명 포함.

Claude:
분석 결과:

1. 이자 계산 로직 (Line 150-450)
   - 단리 vs 복리 판단
   - 이자율: 기준금리 + 가산금리
   - 세금 계산: 이자소득세 15.4%
   
2. 중도 해지 위약금 (Line 451-680)
   - 만기 전 해지 시 적용
   - 계산식: 예상 이자 * 0.5
   - 예외: 금융위기 특례 (1997년 추가)
   
3. 이체 수수료 (Line 681-750)
   - 동일 은행: 무료
   - 타행: 거래 금액별 차등
   ...

이 로직을 Java로 변환할까요?
```

**Step 2: 단계별 변환**

```bash
User: 1번 이자 계산 로직만 먼저 Java로 변환해줘.
Spring Boot 서비스로.

Claude:
InterestCalculationService.java 생성:

public class InterestCalculationService {
    /**
     * 이자 계산
     * 
     * @param principal 원금
     * @param baseRate 기준금리
     * @param additionalRate 가산금리
     * @param isCompound 복리 여부
     * @param days 일수
     * @return 이자금액 (세후)
     */
    public BigDecimal calculateInterest(
        BigDecimal principal,
        BigDecimal baseRate,
        BigDecimal additionalRate,
        boolean isCompound,
        int days
    ) {
        // 1. 총 이자율 계산
        BigDecimal totalRate = baseRate.add(additionalRate);
        
        // 2. 이자 계산 (단리/복리)
        BigDecimal interest = isCompound 
            ? calculateCompoundInterest(principal, totalRate, days)
            : calculateSimpleInterest(principal, totalRate, days);
        
        // 3. 세금 공제 (15.4%)
        BigDecimal tax = interest.multiply(new BigDecimal("0.154"));
        
        return interest.subtract(tax);
    }
    
    private BigDecimal calculateSimpleInterest(...) {
        // 단리: 원금 × 이자율 × (일수/365)
        ...
    }
    
    private BigDecimal calculateCompoundInterest(...) {
        // 복리: 원금 × (1 + 이자율)^(일수/365) - 원금
        ...
    }
}

테스트 케이스:
public void 정상_이자_계산() {
    BigDecimal result = service.calculateInterest(
        new BigDecimal("10000000"), // 천만원
        new BigDecimal("0.02"),     // 2% 기준금리
        new BigDecimal("0.01"),     // 1% 가산
        false,                      // 단리
        365                         // 1년
    );
    
    // 예상: 10,000,000 × 0.03 × 1 = 300,000
    // 세후: 300,000 × 0.846 = 253,800
    assertEquals(new BigDecimal("253800"), result);
}
```

**Step 3: 검증**

```bash
User: COBOL 원본과 Java 변환본이 동일한 결과를 내는지 검증해줘.
테스트 케이스 100개 생성.

Claude:
병렬 테스트 생성:

public void COBOL_Java_동일성_검증() {
    // 실제 운영 데이터 샘플 100건
    List<TestCase> cases = loadProductionSamples(100);
    
    for (TestCase tc : cases) {
        // COBOL 시뮬레이터 실행
        BigDecimal cobolResult = runCobolSimulator(tc);
        
        // Java 서비스 실행
        BigDecimal javaResult = service.calculateInterest(
            tc.principal, tc.baseRate, ...
        );
        
        // 오차 허용 범위: ±1원
        assertThat(javaResult)
            .isCloseTo(cobolResult, within(new BigDecimal("1")));
    }
}

실행 결과:
✓ 97/100 통과
✗ 3/100 실패

실패 케이스 분석:
- Case #23: 윤년 계산 차이 (COBOL은 365일 고정, Java는 실제 일수)
- Case #67: 소수점 반올림 방식 차이
- Case #89: 1997년 금융위기 특례 미적용

수정 제안:
...
```

**당신의 역할**:
- AI가 변환한 코드 검증
- 비즈니스 로직 오류 발견
- 엣지 케이스 추가 ("1997년 특례"는 AI가 모를 수도 있음)

**결과**:
- 2년 → 6개월로 단축
- 비즈니스 로직 문서화 완료 (지식 보존)
- 안전한 마이그레이션 (100% 검증)

---

### 시나리오 2: 스토어드 프로시저 → 서비스 레이어

**당신의 상황**:
- Oracle PL/SQL로 복잡한 정산 로직
- 3000줄짜리 프로시저
- 성능 이슈 (매월 말 과부하)

**AI 활용 전략**:

**Step 1: 분석 및 분해 (Claude Code)**

```bash
claude

User: 이 PL/SQL 프로시저를 분석해줘.
[3000줄 첨부]

목표:
1. 핵심 비즈니스 로직 추출
2. 성능 병목 지점 파악
3. Java로 변환 가능 여부

Claude:
분석 보고서:

## 구조
- Line 1-500: 초기화 및 변수 선언
- Line 501-1200: 고객별 정산 (CURSOR 루프)
- Line 1201-2000: 수수료 계산 (복잡한 중첩 IF)
- Line 2001-2800: 세금 계산
- Line 2801-3000: 결과 저장 및 커밋

## 성능 병목
⚠ Line 501-1200: 100만 고객 × 10초 = 100만초 (11.5일!)
  - 문제: 한 건씩 처리 (Row-by-Row)
  - 해결: 배치 처리 필요

⚠ Line 1201-2000: 중첩 IF 최대 15단계
  - 문제: 가독성 최악, 유지보수 불가
  - 해결: Strategy 패턴

## 변환 전략
1. 배치 처리 도입 (Spring Batch)
2. 병렬 처리 (멀티 스레드)
3. 객체 지향 설계 (Strategy, Template Method)

예상 성능 개선: 11.5일 → 2시간
```

**Step 2: 배치 처리로 변환**

```java
// Claude Code가 생성한 Spring Batch Job

public class MonthlySettlementJobConfig {
    
    @Bean
    public Job monthlySettlementJob() {
        return jobBuilder.get("monthlySettlement")
            .start(customerSettlementStep())
            .next(feeCalculationStep())
            .next(taxCalculationStep())
            .build();
    }
    
    @Bean
    public Step customerSettlementStep() {
        return stepBuilder.get("customerSettlement")
            .<Customer, SettlementResult>chunk(1000) // 1000건씩 배치
            .reader(customerReader())
            .processor(settlementProcessor())
            .writer(settlementWriter())
            .taskExecutor(taskExecutor()) // 병렬 처리
            .build();
    }
    
    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);  // 10개 스레드 동시 실행
        executor.setMaxPoolSize(20);
        return executor;
    }
}

// 수수료 계산: Strategy 패턴으로 단순화
public interface FeeCalculationStrategy {
    BigDecimal calculate(Customer customer, Transaction tx);
}

public class StandardFeeStrategy implements FeeCalculationStrategy {
    @Override
    public BigDecimal calculate(Customer customer, Transaction tx) {
        // 기본 수수료 로직
    }
}

public class PremiumFeeStrategy implements FeeCalculationStrategy {
    @Override
    public BigDecimal calculate(Customer customer, Transaction tx) {
        // 프리미엄 고객 수수료 (할인)
    }
}

public class CorporateFeeStrategy implements FeeCalculationStrategy {
    @Override
    public BigDecimal calculate(Customer customer, Transaction tx) {
        // 법인 고객 수수료
    }
}
```

**Step 3: 성능 검증**

```bash
User: 기존 PL/SQL과 새 Spring Batch의 성능 비교해줘.
동일한 데이터 (100만 건)로 테스트.

Claude:
성능 테스트 결과:

기존 PL/SQL:
- 처리 시간: 11시간 23분
- CPU 사용률: 95% (단일 코어)
- 메모리: 2GB

신규 Spring Batch:
- 처리 시간: 1시간 47분 (6.4배 빠름)
- CPU 사용률: 70% (10코어 분산)
- 메모리: 8GB (배치 크기 최적화 가능)

추가 최적화 제안:
1. 배치 크기 1000 → 5000 (예상 30% 추가 개선)
2. Redis 캐싱 (고객 등급 조회) (예상 20% 추가 개선)

최종 예상: 1시간 47분 → 50분 (13배 개선)
```

**당신의 역할**:
- AI가 놓친 비즈니스 규칙 확인 ("프리미엄 고객은 매월 15일 이전 거래만 할인" 같은 디테일)
- 성능 테스트 시나리오 설계
- 배포 전략 수립 (병렬 운영 기간, 롤백 계획)

**결과**:
- 정산 시간 11시간 → 50분 (13배 개선)
- 유지보수 가능한 코드
- 지식 문서화 (PL/SQL 로직 설명서)

---

### 시나리오 3: JSP + iBatis → Spring Boot + JPA

**당신의 상황**:
- 10년 된 쇼핑몰 시스템
- JSP 200개, iBatis XML 150개
- 매출 발생 시스템이라 리스크 큼

**AI 활용 전략**:

**Step 1: 우선순위 결정 (Claude Code)**

```bash
claude --model opusplan

User: JSP 200개를 모두 마이그레이션하려면 시간이 너무 걸려.
어떤 순서로 해야 할까?

기준:
- 비즈니스 임팩트
- 기술 부채 심각도
- 마이그레이션 난이도

Claude (Plan Mode):
분석 프레임워크:

1. 비즈니스 임팩트 (0-10점)
   - 매출 기여도
   - 사용 빈도
   - 고객 불만 건수

2. 기술 부채 (0-10점)
   - 코드 품질
   - 버그 빈도
   - 성능 이슈

3. 난이도 (0-10점)
   - 의존성 복잡도
   - 비즈니스 로직 복잡도
   - 테스트 가능성

진행할까요?

User: Yes, 분석해줘.

Claude:
[200개 JSP 분석 후]

## 우선순위 Top 10

1. 상품 상세 페이지 (product_detail.jsp)
   - 비즈니스 임팩트: 10 (매출 70% 발생)
   - 기술 부채: 8 (성능 이슈 심각)
   - 난이도: 4 (의존성 낮음)
   - 총점: 22 → 최우선

2. 장바구니 (cart.jsp)
   - 비즈니스 임팩트: 9
   - 기술 부채: 7
   - 난이도: 5
   - 총점: 21

3. 결제 페이지 (checkout.jsp)
   - 비즈니스 임팩트: 10
   - 기술 부채: 9 (결제 오류 월 50건)
   - 난이도: 8 (PG사 연동 복잡)
   - 총점: 27 → But, 위험도 높아 Phase 2 추천

...

권장 순서:
Phase 1 (저위험, 고효과):
1, 2, 5, 8, 12번 JSP (5개, 예상 1개월)

Phase 2 (핵심 기능):
3, 4, 6번 JSP (3개, 예상 2개월)

Phase 3 (나머지):
...
```

**Step 2: Phase 1 실행 (Cursor + Claude Code)**

```bash
# Cursor Agent Mode

User: product_detail.jsp를 React 컴포넌트로 변환해줘.

요구사항:
- React 18 + TypeScript
- Tailwind CSS 사용
- API는 Spring Boot REST
- 기존 디자인 유지

Cursor Agent:
✓ ProductDetail.tsx 생성
✓ ProductAPI.ts 생성 (axios)
✓ Tailwind 스타일 적용
✓ 반응형 디자인

브라우저에서 테스트할까요?

User: Yes

[Cursor가 자동으로 npm start]

Cursor:
✓ 로컬 실행 성공 (http://localhost:3000/product/123)
✓ 기존 JSP와 레이아웃 비교 스크린샷 저장

차이점:
- 로딩 속도: 3.2초 → 0.8초 (4배 빠름)
- SEO: 개선 필요 (서버 사이드 렌더링 권장)
```

**Step 3: A/B 테스트**

```bash
# Claude Code로 A/B 테스트 설정

User: 신규 React 버전과 기존 JSP를 50:50으로 A/B 테스트하고 싶어.
Nginx 설정 어떻게 해야 할까?

Claude:
Nginx 설정:

upstream old_jsp {
    server legacy-server:8080;
}

upstream new_react {
    server react-server:3000;
}

# A/B 테스트: 쿠키 기반
map $cookie_ab_test $backend {
    "new"   new_react;
    default old_jsp;
}

server {
    location /product/ {
        # 50% 확률로 "new" 쿠키 발급
        if ($cookie_ab_test = "") {
            add_header Set-Cookie "ab_test=$http_x_ab_test;Path=/;Max-Age=86400";
        }
        
        proxy_pass http://$backend;
    }
}

모니터링:
- 신규: Conversion Rate, Bounce Rate
- 기존: 동일 지표
- 비교 기간: 2주 추천
```

**당신의 역할**:
- A/B 테스트 결과 분석
- 신규 버전의 UX 개선 (AI가 만든 건 기능만 완벽, UX는 당신이)
- 단계별 전환 의사결정

**결과**:
- Phase 1 완료 (5개 JSP, 1개월)
- 성능 3-4배 개선
- 고객 만족도 상승
- Phase 2 자신감 확보

---

## Chapter 4: 준비해야 할 핵심 역량

### 1. 프롬프트 엔지니어링 (가장 중요)

**나쁜 프롬프트**:
```
User: 로그인 API 만들어줘.
```

**결과**: 쓸모없는 기본 예제

**좋은 프롬프트 (5년차)**:
```
User: Spring Boot 로그인 API를 만들어줘.

요구사항:
- JWT 토큰 발급 (Access + Refresh)
- BCrypt 비밀번호 암호화
- 로그인 실패 5회 시 계정 잠금
- Redis에 토큰 저장 (TTL 30분)
- 예외 처리: InvalidCredentials, AccountLocked

반환:
- 200: { accessToken, refreshToken, expiresIn }
- 401: { error: "Invalid credentials" }
- 423: { error: "Account locked" }

테스트 케이스도 생성해줘.
```

**결과**: 프로덕션 수준 코드

**훌륭한 프롬프트 (10년차)**:
```
User: 우리 회사 전자정부 프레임워크 기반 시스템에 로그인 API를 추가해줘.

컨텍스트:
- 기존 인증: EgovLoginService (세션 기반)
- 신규 요구사항: 모바일 앱 지원 (JWT 필요)
- 보안 정책: KISA 암호화 알고리즘 사용 필수

제약 사항:
- EgovLoginService 로직 재사용 (비즈니스 로직 변경 금지)
- DB는 Oracle 11g (시퀀스 사용)
- 로그 테이블: TB_LOGIN_HIST에 기록 필수

구현:
- JwtAuthenticationFilter 추가
- 기존 세션 인증과 병행 운영 가능하게
- 관리자 모드는 세션, 모바일은 JWT

테스트:
- 기존 세션 인증 영향도 테스트
- JWT 만료/갱신 시나리오
- 동시 로그인 처리 (세션 + JWT)

CLAUDE.md 참고해서 코딩 규칙 따라줘.
```

**결과**: 회사 시스템에 바로 적용 가능

**학습 방법**:
- 첫 1개월: 좋은 예시 수집 (GitHub, 블로그)
- 2-3개월: 회사 프로젝트로 연습
- 4-6개월: 팀 템플릿 만들기

**템플릿 예시 (PROMPT_TEMPLATE.md)**:
```markdown
# API 개발 프롬프트 템플릿

User: [기능명] API를 만들어줘.

컨텍스트:
- 프로젝트: [프로젝트명]
- 기술 스택: [Spring Boot 버전, DB 등]
- 기존 코드: [관련 클래스명]

요구사항:
- 입력: [파라미터]
- 처리: [비즈니스 로직]
- 출력: [응답 형식]

제약 사항:
- [보안 정책]
- [성능 요구사항]
- [기존 시스템 연동]

테스트:
- [정상 케이스]
- [예외 케이스]
- [엣지 케이스]

CLAUDE.md 참고
```

---

### 2. 컨텍스트 관리 (CLAUDE.md)

**왜 필요한가?**
- AI는 세션마다 초기화됨 (당신 회사 규칙을 모름)
- 매번 설명하면 시간 낭비
- 팀원마다 다른 결과물 나옴

**CLAUDE.md 작성 전략 (회사 프로젝트용)**

```markdown
# XX 프로젝트 개발 가이드

## 프로젝트 정보
- 이름: 공공기관 민원 시스템
- 고객: XX부
- 시작: 2020년 / 종료: 2026년
- 개발사: YY 정보기술

## 기술 스택
### 백엔드
- Java 8 (LTS, 절대 11로 업그레이드 금지 - 고객사 정책)
- Spring Framework 4.3.25
- MyBatis 3.5.6
- Oracle 11g

### 프론트엔드
- JSP 2.3
- jQuery 3.5.1
- Bootstrap 3.3.7 (반드시 이 버전, 디자인 커스터마이징 많음)

### WAS
- JEUS 7.0 (고객사 표준)

## 코딩 규칙

### 필수 규칙 (절대 위반 금지)
1. **패키지 구조**
   ```
   egovframework.example
   ├── cmmn (공통)
   ├── sys (시스템 관리)
   ├── civ (민원)
   └── stats (통계)
   ```

2. **클래스 명명 규칙**
   - Controller: ~Controller.java
   - Service: ~Service.java (Interface), ~ServiceImpl.java (구현)
   - DAO: ~DAO.java (Interface), ~DAOImpl.java (구현)
   - VO: ~VO.java

3. **DB 규칙**
   - 테이블: TB_
   - 뷰: VW_
   - 시퀀스: SQ_
   - 모든 컬럼: UPPER_SNAKE_CASE
   - PK: [테이블명]_ID (예: TB_USER → USER_ID)

4. **보안 규칙**
   - 파라미터: XSS 필터 필수 (@RequestParam 사용 금지 → @ModelAttribute)
   - SQL: PreparedStatement 필수 (String 조합 금지)
   - 파일 업로드: 확장자 검증 (허용 목록 방식)

5. **로깅 규칙**
   ```java
   // Good
   logger.debug("사용자 조회: userId={}", userId);
   
   // Bad
   System.out.println("사용자: " + userId);
   logger.debug("사용자: " + userId); // String concat 금지
   ```

6. **예외 처리**
   - 비즈니스 예외: EgovBizException
   - 시스템 예외: RuntimeException
   - 모든 Controller에 @ExceptionHandler

### 권장 사항
- Service 메서드는 200줄 이하
- 복잡한 쿼리는 MyBatis Dynamic SQL 활용
- 트랜잭션: @Transactional 대신 TransactionTemplate 사용 (Spring 4.3 호환성)

## 자주 하는 실수

### 실수 1: jQuery 버전
```javascript
// Bad (jQuery 3.x 문법)
$('#modal').modal('show');

// Good (Bootstrap 3.x 호환)
$('#modal').modal({show: true});
```

### 실수 2: Oracle 페이징
```sql
-- Bad (MySQL 문법)
LIMIT 10 OFFSET 20

-- Good (Oracle 11g)
WHERE ROWNUM BETWEEN 21 AND 30
```

### 실수 3: 날짜 포맷
```java
// Bad
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

// Good (공통 유틸 사용)
EgovDateUtil.toString(date, "yyyy-MM-dd")
```

## 테스트

### 단위 테스트
- JUnit 4.12 (5 아님!)
- Mockito 2.x
- DB 테스트: @Rollback 필수

### 통합 테스트
- 개발 서버: http://dev.example.go.kr
- 테스트 계정: test001 / test1234!

## 배포

### 빌드
```bash
mvn clean package -Dmaven.test.skip=true
```

### 배포 파일
- WAR: example.war
- 설정: /config/application.properties

### 체크리스트
- [ ] SQL 로그 레벨 INFO로 변경
- [ ] 불필요한 System.out 제거
- [ ] API 호출 timeout 설정 확인
- [ ] 고객사 방화벽 신청 완료

## 문의

- PM: 김철수 과장 (010-1234-5678)
- DBA: 이영희 대리 (010-2345-6789)
- 고객사 담당: 박지성 주무관 (02-1234-5678)
```

**이 파일을 Git에 커밋하면**:
- 팀 전체가 동일한 규칙 적용
- 신입도 빠르게 적응
- AI 도구가 회사 스타일대로 코드 생성

---

### 3. 검증 능력 (AI를 믿되, 확인하라)

**AI가 자주 하는 실수**:

**실수 1: 라이브러리 버전 착각**
```java
// AI가 생성한 코드 (Spring Boot 3.x 문법)
public List<User> getUsers() {
    return userService.findAll();
}

// 문제: 회사는 Spring 4.3 (Boot 아님)
// 올바른 코드:
public ModelAndView getUsers() {
    ModelAndView mav = new ModelAndView("userList");
    mav.addObject("users", userService.findAll());
    return mav;
}
```

**검증 체크리스트**:
```markdown
## AI 생성 코드 검증

### 1단계: 컴파일 (1분)
- [ ] IDE에서 빨간줄 없는지 확인
- [ ] import 모두 해결되는지 확인

### 2단계: 로컬 테스트 (5분)
- [ ] 정상 케이스 동작
- [ ] 예외 케이스 동작
- [ ] 기존 기능 영향도 확인

### 3단계: 코드 리뷰 (10분)
- [ ] 보안 이슈 없는지 (SQL Injection, XSS)
- [ ] 성능 이슈 없는지 (N+1 쿼리 등)
- [ ] 회사 코딩 규칙 준수

### 4단계: 동료 리뷰 (선택)
- [ ] 복잡한 로직은 동료 검토
- [ ] 비즈니스 로직 정확성 확인
```

**검증 도구**:
- SonarQube: 코드 품질 자동 검사
- FindBugs: 잠재적 버그 탐지
- 보안 스캐너: OWASP Dependency Check

**10년차 노하우**:
```bash
# AI 생성 코드를 SonarQube로 바로 검사

User (Claude Code): 방금 만든 코드를 SonarQube로 검사해줘.

Claude:
mvn sonar:sonar 실행...

검사 결과:
⚠ Critical: 1건
  - SQL Injection 가능성 (line 45)
  - 수정 제안: PreparedStatement 사용
  
⚠ Major: 3건
  - Null check 누락 (line 23, 67, 89)
  
✓ Minor: 7건
  - 불필요한 import
  
수정할까요?

User: Yes, Critical과 Major만

Claude: [자동 수정 완료]
```

---

### 4. 도메인 지식 (AI가 절대 대체 못하는 것)

**예시: 금융권 정산 로직**

```bash
User (Claude Code): 이 정산 로직 좀 간단하게 리팩토링해줘.

Claude:
기존 코드:
if (status.equals("A")) {
    if (type.equals("1")) {
        amount = base * 1.05;
    } else if (type.equals("2")) {
        amount = base * 1.03;
    }
} else if (status.equals("B")) {
    amount = base * 0.98;
}

리팩토링:
Map<String, Double> rates = Map.of(
    "A1", 1.05,
    "A2", 1.03,
    "B", 0.98
);
amount = base * rates.get(status + type);

깔끔해졌죠?

User: 아니, 안돼!

Claude: 왜요?

User: "B" 타입은 type을 보지 않아. 
그리고 "A3"가 없으면 NullPointerException 발생해.
고객 돈 계산인데 예외 터지면 큰일나.

원래 코드가 정확해. 그대로 둬.
대신 주석만 추가해줘.

Claude:
아, 죄송합니다.

// 정산 요율 계산
// A 등급: type에 따라 차등 (1: 5% 할증, 2: 3% 할증)
// B 등급: 일률 2% 할인
// 예외: 정의되지 않은 조합은 base 금액 그대로
if (status.equals("A")) {
    if (type.equals("1")) {
        amount = base * 1.05;  // VIP 고객
    } else if (type.equals("2")) {
        amount = base * 1.03;  // 우수 고객
    } else {
        amount = base;  // 기타 A등급
    }
} else if (status.equals("B")) {
    amount = base * 0.98;  // B등급 일률 할인
} else {
    amount = base;  // 기타 등급
}
```

**이것이 10년차의 가치**: AI는 코드를 예쁘게 만들지만, 당신은 비즈니스를 이해합니다.

---

## Chapter 5: 전환 성공 사례

### 사례 1: IntelliJ 10년 유저의 Cursor 전환 (한국 개발자)

**출처**: SK Devocean 블로그 (2025년 9월)

**배경**:
- IntelliJ를 10년간 사용
- VS Code 기반인 Cursor로 전환 부담
- "IDE를 바꾸는 건 너무 큰 결정"

**전환 계기**:
- 주변 개발자들이 모두 Cursor 사용
- "안 쓰기엔 아쉽다" → 절충안 시도

**절충안**:
- 코딩: IntelliJ 그대로
- AI 대화: Cursor 별도 실행

**문제**:
- 도구 2개 왔다갔다 불편
- 컨텍스트 동기화 어려움

**해결책**: MCP (Model Context Protocol)
```json
// claude_desktop_config.json
{
  "mcpServers": {
    "jetbrains": {
      "command": "npx",
      "args": ["-y", "@jetbrains/mcp-proxy"]
    }
  }
}
```

**결과**:
- IntelliJ에서 코딩 + Claude Desktop에서 AI 대화
- 두 도구가 MCP로 연결됨
- 개발 속도 40% 향상

**교훈**:
- "올인" 하지 않아도 됨
- 익숙한 도구 + AI 조합 가능
- MCP가 미래 표준

---

### 사례 2: 금융권 레거시 마이그레이션 (Morgan Stanley)

**출처**: EY 보고서 (2025년 8월)

**배경**:
- 900만 줄의 레거시 코드
- COBOL, Fortran, PL/SQL 혼재
- 마이그레이션 예상: 10년

**AI 활용**:
- GPT 기반 코드 변환 시스템
- 비즈니스 로직 자동 문서화
- 자동 테스트 생성

**결과**:
- 28만 개발자 시간 절약
- 마이그레이션 기간: 10년 → 3년
- 정확도: 85% (나머지 15%는 시니어 검증)

**핵심 전략**:
1. **AI는 변환, 시니어는 검증**
2. **단계별 접근** (전체를 한번에 하지 않음)
3. **병렬 운영** (레거시와 신규 동시 운영하며 점진적 전환)

**교훈**:
- 레거시 경험자가 필수
- AI 100% 의존은 위험
- 시니어의 판단이 성공의 열쇠

---

### 사례 3: 한국 SI 업체의 팀 단위 전환

**출처**: 실제 현장 사례 (익명)

**배경**:
- 중견 SI 업체 백엔드 팀 (15명)
- 평균 경력 7년
- 야근 문화 + 반복 작업 많음

**파일럿 프로그램 (3개월)**:

**1개월차**:
- 관심있는 개발자 5명 선발
- Cursor Pro 회사 지원 ($20 × 5 = $100/월)
- 주 1회 학습 세션

**2개월차**:
- 실제 프로젝트 적용
- 생산성 측정 시작

**결과**:
```
Before:
- 기능 개발: 평균 3일
- 야근: 주 3회
- 버그: 기능당 2.1개

After (2개월):
- 기능 개발: 평균 1.8일 (40% 단축)
- 야근: 주 1회 (67% 감소)
- 버그: 기능당 1.3개 (38% 감소)
```

**3개월차**:
- 전체 팀 확대 (15명)
- 월 비용: $300
- 월 절감 효과: 야근 수당 + 생산성 = 약 $5,000

**ROI**: 1,567%

**경영진 보고**:
```markdown
## AI 코딩 도구 도입 효과

투자: $300/월
절감: $5,000/월
ROI: 16배

추가 효과:
- 팀 사기 상승 (야근 감소)
- 이직률 감소 (0명 → 업계 평균 20%)
- 신규 채용 경쟁력 (AI 활용 팀으로 홍보)

제안: 전사 확대 (개발팀 100명)
```

**승인됨** → 전사 표준으로 채택

**교훈**:
- 파일럿부터 시작 (작게 증명)
- 수치로 말하기 (감성이 아닌 데이터)
- 경영진 언어 사용 (ROI, 비용 절감)

---

## Chapter 6: 실전 로드맵

### 5년차 개발자 6개월 로드맵

| 기간 | 핵심 활동 | 도구 | 목표 | 체크포인트 |
|------|---------|------|------|----------|
| **1개월** | Cursor 기초 마스터 | Cursor ($20) | Tab 완성, Cmd+K 익숙 | 회사 코드 50% Cursor로 작성 |
| **2개월** | Agent Mode 활용 | Cursor | 자동화 경험 | 작은 기능 1개 Agent로 완성 |
| **3개월** | Claude Code 시작 | +Claude Code ($20) | Plan Mode 이해 | 복잡한 리팩토링 1건 완료 |
| **4개월** | CLAUDE.md 작성 | Claude Code | 컨텍스트 관리 | 팀 규칙 문서화 |
| **5개월** | 실전 프로젝트 | Both | 업무 적용 | 레거시 모듈 1개 현대화 |
| **6개월** | 팀 확산 | Both | 리더십 | 팀원 3명 교육 완료 |

**월별 예상 비용**:
- 1-2개월: $20
- 3-6개월: $40
- 총 투자: $180

**예상 ROI**:
- 야근 감소: 월 20시간 × $30 = $600
- 생산성: 월 40시간 × $30 = $1,200
- 6개월 절감: $10,800
- ROI: 60배

---

### 10년차 개발자 12개월 로드맵

| 기간 | 핵심 활동 | 도구 | 목표 | 체크포인트 |
|------|---------|------|------|----------|
| **1개월** | 전략적 학습 | Cursor + Claude Code ($40) | 두 도구 비교 이해 | 사용 시나리오 정리 |
| **2개월** | 아키텍처 분석 | Claude Code (opusplan) | 레거시 시스템 진단 | 현대화 로드맵 수립 |
| **3개월** | 파일럿 팀 구성 | Both | 팀 리더십 | 3명 선발, 교육 시작 |
| **4개월** | 실전 적용 | Both | 검증 | 파일럿 프로젝트 완료 |
| **5개월** | 성과 측정 | Both | 데이터 수집 | ROI 계산서 작성 |
| **6개월** | 경영진 보고 | - | 확산 승인 | 전사 확대 예산 확보 |
| **7-9개월** | 팀 확대 | Both | 전파 | 팀 전체 전환 |
| **10-12개월** | 조직 표준화 | Both | 리더 포지셔닝 | AI 전환 리더로 인정 |

**월별 예상 비용**:
- 1-6개월: $40 (개인)
- 7-12개월: $600 (팀 15명)
- 총 투자: $3,840

**예상 ROI** (팀 단위):
- 팀 생산성: 월 600시간 × $30 = $18,000
- 12개월 절감: $216,000
- ROI: 56배

**추가 가치**:
- 승진 또는 팀 리드 포지션
- 연봉 협상 카드 (30% 인상 근거)
- 업계 인지도 (컨퍼런스 발표 등)

---

## Chapter 7: 피해야 할 함정

### 함정 1: "AI가 다 해줄 거야" (과신)

**사례**:
```bash
User: 우리 회사 전체 시스템을 Spring Boot로 마이그레이션해줘.

AI: [500줄 코드 생성]

User: 오 대단한데? 바로 배포!

[운영 서버 다운 → 매출 손실 → 징계]
```

**올바른 접근**:
```bash
User: 우리 회사 시스템 마이그레이션 계획을 세워줘.
- 현황: JSP 200개, iBatis 150개
- 제약: 무중단 서비스
- 기간: 6개월

AI (Plan Mode):
Phase 1: 분석 (1개월)
- 의존성 매핑
- 리스크 식별
- 우선순위 설정

Phase 2: 파일럿 (1개월)
- 독립 모듈 1개 선정
- 마이그레이션 + 테스트
- 성과 측정

Phase 3: 단계별 전환 (4개월)
...

User: Phase 1만 먼저 시작하자.
```

**교훈**: AI는 도구, 전략은 당신이 세워라.

---

### 함정 2: "비용 아끼려고 무료만 써야지" (잘못된 절약)

**계산**:

**무료 도구 사용**:
- 비용: $0
- 제약: 일일 사용량 제한
- 결과: 중요한 순간에 막힘 → 스트레스
- 생산성: +10%

**유료 도구 사용** ($40/월):
- 비용: $40
- 제약: 거의 없음
- 결과: 몰입 가능
- 생산성: +40%

**실제 가치**:
```
당신 시급: $30
유료 도구로 절약한 시간: 월 20시간
절약 금액: $600
순이익: $600 - $40 = $560
```

**결론**: $40 아끼려다 $560 손해

---

### 함정 3: "AI가 만든 코드는 다 똑같아" (획일화)

**나쁜 예**:
```java
// 모든 프로젝트가 똑같은 구조
public class UserController {
    // Generic한 CRUD...
}
```

**좋은 예**:
```java
// 회사 스타일 반영 (CLAUDE.md 활용)
public class UserController extends EgovAbstractController {
    // 전자정부 프레임워크 스타일
    // 회사 로깅 규칙
    // 회사 예외 처리
}
```

**교훈**: CLAUDE.md로 회사 정체성 유지

---

### 함정 4: "혼자 쓰면 돼" (팀 확산 실패)

**혼자 쓸 때**:
- 개인 생산성 2배
- 팀 생산성 변화 없음
- 팀원 질투: "쟤만 편하게 일해"

**팀 전체가 쓸 때**:
- 개인 생산성 2배
- 팀 생산성 2배
- 협업 효율 향상 (코드 스타일 통일)
- 팀 사기 상승

**전략**: 혼자 익히고 → 빨리 확산

---

## 결론: 레거시 개발자여, 이제 당신의 시대다

2026년 1월, AI 코딩 도구들은 더 이상 "최신 기술"이 아닙니다. **개발자의 기본 소양**입니다.

하지만 모두가 AI를 쓴다고 해서 모두가 성공하는 건 아닙니다. **AI를 제대로 활용하는 사람만 살아남습니다.**

5-10년차 한국 SI/SM 개발자인 당신은 다음을 가지고 있습니다:

1. **레거시 시스템 경험** → AI가 절대 모르는 비즈니스 컨텍스트
2. **문제 해결 능력** → AI가 만든 코드를 검증하는 눈
3. **도메인 지식** → AI가 제안한 솔루션의 옳고 그름을 판단하는 능력
4. **팀워크** → AI 전환을 조직에 확산시키는 리더십

이것들은 **AI가 대체할 수 없는 것들**입니다.

이제 필요한 건 단 하나:

**첫 발을 내딛는 것.**

내일 당장 Cursor를 설치하세요. ($20, 커피 4잔 값)  
회사 코드 한 줄을 AI와 함께 작성해보세요.  
그게 당신의 새로운 시작입니다.

6개월 후, 당신은 팀에서 가장 생산적인 개발자가 될 것입니다.  
1년 후, 당신은 조직의 AI 전환 리더가 될 것입니다.  
2년 후, 당신은 업계에서 인정받는 전문가가 될 것입니다.

**레거시 경험은 짐이 아니라 자산입니다.**  
**AI 시대는 레거시 전문가를 기다리고 있습니다.**

이제 당신의 차례입니다.

---

## 부록: 추가 리소스

### 학습 자료
- **Cursor 공식 문서**: https://docs.cursor.com
- **Claude Code 가이드**: https://docs.anthropic.com/claude-code
- **한국어 커뮤니티**: 
  - SK Devocean (실전 사례 많음)
  - 개발자 커뮤니티 (OKKY, inflearn)

### 도구 비교
- **Cursor vs Claude Code**: heesangs.com/131
- **바이브 코딩 솔루션 5종 비교**: TechView 블로그

### 레거시 마이그레이션
- **EY GenAI 백서**: Legacy System Modernization
- **NTT DATA**: AI Transformation Guide
- **McKinsey**: Developer Productivity with GenAI

### 한국 사례
- **SK 개발자 블로그**: MCP 활용 사례
- **네이버 기술 블로그**: AI 코딩 도구 도입기
- **우아한형제들**: AI 페어 프로그래밍 실험

---

**작성일**: 2026-01-03  
**대상 독자**: 5년차/10년차 한국 SI/SM 개발자  
**핵심 메시지**: 레거시 경험 + AI 도구 = 최강 조합
