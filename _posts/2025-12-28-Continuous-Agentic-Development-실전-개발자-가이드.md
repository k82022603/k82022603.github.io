---
title: "Continuous Agentic Development 실전 개발자 가이드"
date: 2025-12-28 09:00:00 +0900
categories: [AI,  Vibe Coding,  Guide]
tags: [AI,  Developer,  vibe-coding,  Guide,  Claude.write]
---

## 내일부터 바로 적용하는 20/80 개발 워크플로우

---

## 시작하기 전에: 준비물 체크리스트

### 필수 도구
- [ ] Claude Code 또는 유사한 AI 코딩 도구 설치
- [ ] 프로젝트 저장소 (Git)
- [ ] 개발 환경 설정 완료
- [ ] CLAUDE.md 파일 작성 (프로젝트 컨텍스트)

### 마인드셋 점검
- [ ] "나는 편집장이다" - 코더가 아닌 아키텍트로 생각하기
- [ ] AI를 신뢰하되 검증한다
- [ ] 방향 설정에 80% 집중할 준비
- [ ] 실패를 학습 기회로 받아들이기

---

## Week 1: 기초 워크플로우 마스터하기

### Day 1: 첫 AI 협업 세션

#### 아침 (30분): 환경 설정

**1단계: CLAUDE.md 파일 생성**

프로젝트 루트에 CLAUDE.md 파일을 만듭니다. 이것은 Claude가 프로젝트를 이해하는 가장 중요한 문서입니다.

```markdown
# 프로젝트 개요
주식 예측 시스템 - React + Spring Boot + PostgreSQL

## 기술 스택
- Backend: Spring Boot 3.2, MyBatis, Java 17
- Frontend: React 18, Axios
- Database: PostgreSQL 15
- Build: Maven, npm

## 코딩 규칙
- Java: CamelCase, Spring Boot 컨벤션 준수
- React: Functional Components, Hooks 사용
- SQL: 모든 쿼리는 Mapper XML에 작성
- Test: JUnit 5, 커버리지 80% 목표

## 브랜치 전략
- main: 프로덕션
- develop: 개발 통합
- feature/*: 기능 개발
- hotfix/*: 긴급 수정

## 중요 사항
- 모든 API는 에러 처리 필수
- 보안: SQL 인젝션 방지 (PreparedStatement)
- 성능: N+1 쿼리 절대 금지
```

**2단계: Claude Code 실행**

```bash
# 터미널에서 프로젝트 디렉토리로 이동
cd ~/projects/stock-prediction-system

# Claude Code 시작
claude

# 첫 인사
"안녕 Claude! 이 프로젝트를 함께 개발할 거야. 
CLAUDE.md를 먼저 읽어줘."
```

#### 오전 (2시간): 첫 기능 구현

**실습: 간단한 CRUD 기능 추가**

**프롬프트 템플릿:**
```
[목표 명확히]
주식 즐겨찾기 기능을 추가하고 싶어.

[요구사항 상세히]
백엔드:
- FavoriteStock 엔티티 생성 (user_id, stock_id, created_at)
- MyBatis Mapper 인터페이스와 XML 작성
- FavoriteService 비즈니스 로직
- FavoriteController REST API (CRUD)

프론트엔드:
- 주식 목록에 즐겨찾기 버튼 추가
- 즐겨찾기 목록 페이지
- API 연동

데이터베이스:
- favorite_stocks 테이블 스키마

[제약사항]
- 한 사용자당 최대 50개까지만 즐겨찾기 가능
- 중복 즐겨찾기 방지

[실행 방식]
단계별로 진행해줘. 각 단계 완료 후 내 확인을 받고 다음 단계로.
```

**예상 Claude 응답:**
```
알겠습니다. 즐겨찾기 기능을 단계별로 구현하겠습니다.

=== 1단계: 데이터베이스 스키마 ===

다음 SQL을 실행할까요?

CREATE TABLE favorite_stocks (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    stock_id BIGINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(user_id, stock_id),
    FOREIGN KEY (stock_id) REFERENCES stocks(id)
);

CREATE INDEX idx_favorite_user ON favorite_stocks(user_id);

진행할까요?
```

**당신의 답변:**
```
좋아. 진행해줘.
```

#### 오후 (2시간): 검토 및 개선

**검토 체크리스트:**

```markdown
## 코드 품질 체크리스트

### 비즈니스 로직
- [ ] 요구사항이 정확히 구현되었는가?
- [ ] 엣지 케이스가 처리되었는가? (중복, 제한 초과 등)
- [ ] 에러 메시지가 사용자 친화적인가?

### 보안
- [ ] SQL 인젝션 방지 (PreparedStatement 사용)?
- [ ] 인증/인가 처리가 되어있는가?
- [ ] 민감 정보 노출이 없는가?

### 성능
- [ ] N+1 쿼리가 없는가?
- [ ] 불필요한 데이터베이스 호출이 없는가?
- [ ] 인덱스가 적절히 설정되었는가?

### 테스트
- [ ] 단위 테스트가 작성되었는가?
- [ ] 주요 시나리오가 커버되는가?
- [ ] 테스트가 실제로 통과하는가?

### 코드 가독성
- [ ] 변수명이 명확한가?
- [ ] 주석이 필요한 복잡한 로직은 없는가?
- [ ] 코딩 컨벤션을 준수하는가?
```

**개선 프롬프트 예시:**
```
코드를 검토했어. 몇 가지 개선이 필요해:

1. FavoriteService의 add 메서드에서 이미 50개 즐겨찾기가 있을 때 
   예외 처리가 없어. LimitExceededException을 던지도록 수정해줘.

2. 프론트엔드의 즐겨찾기 버튼이 이미 즐겨찾기된 항목인지 
   시각적으로 표시가 안 돼. 아이콘 색상으로 구분해줘.

3. 단위 테스트를 추가해줘. 특히 중복 즐겨찾기와 
   50개 제한 테스트가 필요해.
```

#### 저녁 (30분): 일일 회고

**일일 회고 템플릿:**

```markdown
# 일일 회고 - 2025-12-28

## 오늘의 성과
- [ ] 즐겨찾기 기능 백엔드 완성
- [ ] 즐겨찾기 UI 구현
- [ ] 테스트 작성 및 통과

## Claude와의 협업
### 잘된 점
- 단계별 진행으로 각 단계를 검증할 수 있었음
- 구체적인 요구사항 전달로 원하는 결과를 빠르게 얻음

### 개선할 점
- 초기 프롬프트에 테스트 요구사항을 포함했으면 더 좋았을 것
- 에러 처리 전략을 미리 명시했어야 함

## 내일 계획
- [ ] 즐겨찾기 목록 정렬 기능
- [ ] 즐겨찾기 그룹화 기능
- [ ] 성능 테스트

## 학습한 프롬프트 패턴
- "단계별로 진행해줘" → 각 단계 확인 가능
- "제약사항" 섹션 → 비즈니스 규칙 명확히
```

---

### Day 2-3: 복잡한 기능 구현

#### 멀티 레이어 작업 프롬프트

```
프론트엔드와 백엔드 모두 수정이 필요한 작업:

[기능]
주식 포트폴리오 관리 시스템

[백엔드 변경]
1. Portfolio 엔티티 (name, user_id, created_at)
2. PortfolioStock 엔티티 (portfolio_id, stock_id, quantity, purchase_price)
3. REST API:
   - POST /api/portfolios (포트폴리오 생성)
   - GET /api/portfolios (목록 조회)
   - GET /api/portfolios/{id} (상세 조회 - 주식 목록 포함)
   - PUT /api/portfolios/{id}/stocks (주식 추가/수정)
   - DELETE /api/portfolios/{id}/stocks/{stockId} (주식 제거)
4. 포트폴리오별 수익률 계산 로직

[프론트엔드 변경]
1. 포트폴리오 목록 페이지
2. 포트폴리오 상세 페이지 (주식 목록, 수익률 차트)
3. 주식 추가 모달
4. Recharts로 수익률 시각화

[데이터베이스]
- portfolios 테이블
- portfolio_stocks 테이블 (many-to-many)

[우선순위]
1단계: 백엔드 API 완성
2단계: 기본 UI (목록, 상세)
3단계: 차트 및 고급 기능

각 단계가 완료되면 테스트 가능한 상태로 만들어줘.
문제가 있으면 멈추고 알려줘.
```

#### Stop Hooks 활용하기

**3시간 연속 작업 설정:**

```
오전 내내 이 작업에 집중할 거야. 다음과 같이 진행해줘:

[작업 범위]
포트폴리오 관리 시스템 전체 구현

[체크포인트]
- 30분마다 진행상황 요약
- 막히는 부분이 있으면 즉시 중단하고 보고
- 각 주요 마일스톤마다 Git commit

[자율성]
- 작은 구현 결정은 네가 판단해도 돼
- 아키텍처나 데이터 모델 변경은 반드시 확인 받기

[품질 기준]
- 모든 API는 에러 처리 포함
- 테스트 커버리지 80% 이상
- 코드 중복 최소화

시작해줘!
```

---

### Day 4-5: 리팩토링과 최적화

#### 전체 프로젝트 리팩토링 프롬프트

```
프로젝트 전체를 리팩토링하고 싶어. 다음 관점에서 분석하고 개선해줘:

[Phase 1: 분석]
1. 코드 중복 찾기
2. 복잡도가 높은 메서드 식별
3. 네이밍 일관성 검토
4. 아키텍처 패턴 준수 여부

[Phase 2: 개선 제안]
각 이슈에 대해:
- 문제점
- 영향도 (높음/중간/낮음)
- 개선 방안
- 예상 소요 시간

[Phase 3: 실행]
우선순위 높은 것부터 단계별로 개선
(내 승인 후 진행)

먼저 Phase 1 분석 결과를 보여줘.
```

#### 성능 최적화 프롬프트

```
시스템 성능을 최적화해줘:

[분석 영역]
1. 데이터베이스 쿼리
   - N+1 쿼리 찾기
   - 느린 쿼리 식별
   - 인덱스 누락 확인

2. API 응답 시간
   - 각 엔드포인트 분석
   - 병목 지점 식별

3. 프론트엔드 렌더링
   - 불필요한 리렌더링
   - 번들 크기

[최적화 전략]
- 데이터베이스: 쿼리 최적화, 인덱스 추가
- 백엔드: 캐싱, 비동기 처리
- 프론트엔드: 코드 스플리팅, 메모이제이션

각 최적화의 예상 효과를 백분율로 알려줘.
```

---

## Week 2: 고급 워크플로우

### 일일 루틴 확립

#### 아침 루틴 (30분)

**1. 마스터 플랜 세우기**

```
Claude, 오늘의 마스터 플랜을 세워줘:

[어제까지 진행 상황]
- 포트폴리오 CRUD 완성
- 수익률 계산 로직 구현
- 기본 UI 완성

[오늘의 목표]
- 실시간 주가 업데이트 기능
- WebSocket 연동
- 차트 고도화

[제약사항]
- 오후 3시에 팀 미팅 (2시간)
- 실제 개발 가능 시간: 5시간

[우선순위]
1. 반드시 완료: WebSocket 백엔드
2. 가능하면 완료: 프론트엔드 연동
3. 시간 남으면: 차트 개선

이를 바탕으로:
1. 시간별 작업 계획
2. 각 작업 예상 소요 시간
3. 리스크 요인
4. 체크포인트

를 제시해줘.
```

**2. Git 상태 확인**

```
현재 Git 상태를 확인하고:
1. 커밋되지 않은 변경사항 확인
2. 현재 브랜치 확인
3. 최근 커밋 요약
4. 오늘 작업할 브랜치 제안

해줘.
```

#### 점심 전 체크포인트 (15분)

```
오전 작업을 리뷰해줘:

[확인 사항]
1. 완료된 작업 목록
2. 생성/수정된 파일 목록
3. 테스트 통과 여부
4. 발견된 이슈나 기술 부채
5. 오후 작업 조정 필요 사항

[Git 작업]
의미있는 단위로 commit 생성해줘.
커밋 메시지는 Conventional Commits 형식으로.
```

#### 저녁 리뷰 (30분)

```
오늘 하루를 정리해줘:

[생성된 코드 분석]
1. 파일별 변경 라인 수
2. 추가된 기능 목록
3. 수정된 버그 목록
4. 작성된 테스트 수

[품질 체크]
1. 코드 커버리지
2. 정적 분석 결과
3. 보안 이슈
4. 성능 이슈

[내일 준비]
1. 미완료 작업 목록
2. 기술 부채 목록
3. 내일 우선순위 제안
4. 필요한 조사/학습 사항

리포트 형식으로 정리해줘.
```

---

### 연속 작업 세션 관리

#### 3시간 딥워크 세션

**세션 시작 프롬프트:**

```
지금부터 3시간 동안 깊게 집중할 거야.

[목표]
사용자 인증 시스템 완성

[자율 작업 범위]
다음은 네가 스스로 결정해도 돼:
- 구현 세부사항
- 변수/함수 네이밍
- 코드 구조화
- 에러 메시지 문구

[확인 필요 사항]
다음은 반드시 내 확인을 받아:
- 데이터베이스 스키마 변경
- 새로운 라이브러리 추가
- 아키텍처 패턴 변경
- 보안 관련 결정

[체크포인트]
- 30분마다 진행상황 요약
- 문제 발생 시 즉시 중단하고 보고
- 1시간마다 Git commit

[Stop 조건]
- 심각한 에러 발생
- 예상과 다른 결과
- 의사결정이 필요한 상황

시작!
```

**중간 체크포인트 응답 예시:**

```
=== 30분 체크포인트 ===

[완료]
✅ JWT 라이브러리 선택 및 설정
✅ User 엔티티 생성
✅ UserMapper XML 작성
✅ 비밀번호 해싱 유틸리티

[진행 중]
🔄 AuthService 구현 (70%)

[다음 30분 계획]
- AuthService 완성
- AuthController 생성
- 로그인 API 구현

[이슈]
없음

계속 진행할까요?
```

---

## Week 3: 팀 협업 패턴

### Pull Request 워크플로우

#### PR 생성 자동화

```
다음 작업이 완료되었어:
- feature/user-authentication 브랜치
- 사용자 인증 시스템 구현

Pull Request를 생성하고 싶어:

[PR 작업]
1. 변경사항 요약 생성
2. 스크린샷 생성 (UI 변경이 있다면)
3. 테스트 결과 요약
4. 리뷰어에게 필요한 컨텍스트
5. Breaking Changes 여부
6. 마이그레이션 필요 사항

[PR 설명 템플릿]
## 변경사항
...

## 테스트
...

## 스크린샷
...

## 리뷰 포인트
...

## 체크리스트
- [ ] 테스트 통과
- [ ] 문서 업데이트
- [ ] Breaking changes 문서화

이 형식으로 PR 설명을 만들어줘.
```

#### 코드 리뷰 응답

```
리뷰어 코멘트를 받았어:

"""
1. AuthService.java:45 - 패스워드 검증 로직이 복잡함. 
   별도 메서드로 분리하는 게 좋겠음.

2. UserMapper.xml:23 - SQL 쿼리에 인덱스가 없는 것 같음. 
   성능 이슈 가능성.

3. 단위 테스트에서 엣지 케이스가 부족함.
   빈 문자열, null, 특수문자 케이스 추가 필요.
"""

각 코멘트에 대해:
1. 개선 방안 제시
2. 코드 수정
3. 추가 테스트 작성

해줘.
```

---

### 페어 프로그래밍 세션

#### 실시간 협업 모드

```
팀원과 페어 프로그래밍을 할 거야.

[내 역할: Navigator]
- 방향 설정
- 비즈니스 로직 결정
- 리뷰

[네 역할: Driver]
- 코드 작성
- 즉각적인 구현
- 리팩토링 제안

[작업]
결제 시스템 통합

[진행 방식]
내가 "이렇게 해줘"라고 하면
→ 너는 즉시 구현하고 결과를 보여줘
→ 내가 리뷰하고 다음 지시

빠르게 반복하자. 시작!
```

**실제 대화 예시:**

```
You: "Payment 인터페이스를 만들어줘. 
      pay(), refund(), getStatus() 메서드 필요해."

Claude: "Payment 인터페이스를 생성했습니다:

public interface Payment {
    PaymentResult pay(PaymentRequest request);
    RefundResult refund(String paymentId);
    PaymentStatus getStatus(String paymentId);
}

PaymentResult와 RefundResult DTO도 필요할까요?"

You: "응, 만들어줘. 그리고 KakaoPayment 구현체도."

Claude: "DTO와 구현체를 만들었습니다..."
```

---

## Week 4: 프로덕션 레벨 작업

### 대규모 리팩토링 프로젝트

#### 7일 리팩토링 계획

**Day 1: 현황 분석**

```
전체 프로젝트를 스캔하고 리팩토링 필요 항목을 찾아줘:

[분석 카테고리]
1. 코드 중복
   - 3회 이상 반복되는 코드 블록
   - 유사한 패턴의 메서드
   
2. 복잡도
   - Cyclomatic Complexity > 10
   - 메서드 라인 수 > 50
   
3. 네이밍
   - 일관성 없는 변수명
   - 불명확한 메서드명
   
4. 아키텍처
   - 레이어 분리 위반
   - 순환 참조
   
5. 성능
   - N+1 쿼리
   - 불필요한 객체 생성

[출력 형식]
각 카테고리별로:
- 발견 항목 수
- 영향도 (Critical/High/Medium/Low)
- 예상 수정 시간
- 파일 경로와 라인 번호

우선순위 순으로 정렬해서 보고서 만들어줘.
```

**Day 2-6: 단계별 개선**

```
리팩토링 Day 2 - 코드 중복 제거

[오늘의 목표]
어제 식별한 코드 중복 항목 중 Priority High 처리

[작업 방식]
각 중복 코드에 대해:
1. 중복 코드 위치 표시
2. 통합 방안 제안
3. 내 승인 후 리팩토링 실행
4. 테스트로 기능 유지 확인
5. Git commit

[안전 장치]
- 한 번에 하나씩만 수정
- 각 수정 후 전체 테스트 실행
- 문제 발생 시 즉시 롤백

시작해줘. 첫 번째 중복부터.
```

---

### 성능 최적화 프로젝트

#### 병목 지점 분석 및 최적화

```
프로덕션 환경에서 성능 이슈가 보고되고 있어:

[증상]
- /api/stocks 엔드포인트 응답 시간 3초
- /api/predictions/tomorrow 응답 시간 5초
- 데이터베이스 CPU 사용률 80%

[분석 요청]
1. 각 엔드포인트의 쿼리 실행 계획 분석
2. N+1 쿼리 여부 확인
3. 인덱스 누락 확인
4. 불필요한 데이터 로딩 확인

[최적화 제안]
각 이슈에 대해:
- 문제 설명
- 현재 코드
- 개선 코드
- 예상 성능 향상 (%)

[측정]
최적화 전후 성능을 측정할 수 있도록
간단한 벤치마크 코드도 만들어줘.
```

---

## 실전 시나리오별 프롬프트 라이브러리

### 시나리오 1: 긴급 버그 수정

```
프로덕션에서 긴급 버그가 발생했어!

[버그 설명]
사용자가 포트폴리오를 삭제할 때 
관련 주식 데이터가 삭제되지 않아서 
고아 레코드가 남는 문제

[긴급 수정 프로세스]
1. 문제 원인 파악
2. 최소 침습적 수정 방안 제안
3. 핫픽스 브랜치 생성
4. 수정 및 테스트
5. PR 생성

[제약 조건]
- 30분 내 수정 완료 필요
- 데이터 손실 절대 금지
- 기존 기능에 영향 최소화

지금 바로 시작해줘!
```

### 시나리오 2: 새로운 기술 스택 도입

```
프로젝트에 Redis 캐싱을 도입하고 싶어.

[Phase 1: 조사 및 계획]
1. 우리 프로젝트에서 Redis를 활용할 수 있는 영역 분석
2. 도입 시 예상 효과 (성능, 비용)
3. 잠재적 리스크
4. 단계별 도입 계획

[Phase 2: PoC]
1. 가장 효과적일 것 같은 영역 선정
2. 최소 구현으로 PoC 개발
3. 성능 측정

[Phase 3: 전면 적용]
1. 캐싱 전략 수립
2. 전체 시스템 적용
3. 모니터링 설정

먼저 Phase 1 보고서를 만들어줘.
```

### 시나리오 3: 레거시 코드 현대화

```
2년 전에 작성된 레거시 컴포넌트를 현대화하고 싶어:

[대상]
StockAnalysisService.java (500줄)

[목표]
- Java 17 기능 활용 (Records, Pattern Matching, etc.)
- 함수형 프로그래밍 패턴 적용
- 테스트 커버리지 80% 달성
- 복잡도 50% 감소

[제약]
- 기존 API 인터페이스 유지 (하위 호환성)
- 단계별 마이그레이션 (BigBang 금지)
- 각 단계마다 테스트로 검증

[진행 방식]
1. 현재 코드 분석 및 이슈 식별
2. 현대화 계획 수립
3. 단계별 리팩토링
4. 각 단계마다 내 승인 필요

시작해줘.
```

---

## 품질 관리 체크리스트

### 매일 사용하는 품질 체크리스트

```markdown
## 코드 제출 전 체크리스트

### 기능 구현
- [ ] 모든 요구사항이 구현되었는가?
- [ ] 엣지 케이스가 처리되었는가?
- [ ] 에러 메시지가 명확한가?

### 테스트
- [ ] 단위 테스트 작성 및 통과
- [ ] 통합 테스트 작성 및 통과
- [ ] 커버리지 80% 이상
- [ ] 모든 테스트가 로컬에서 통과

### 보안
- [ ] SQL 인젝션 방지
- [ ] XSS 방지
- [ ] CSRF 토큰 확인
- [ ] 민감 정보 로깅 금지
- [ ] 적절한 인증/인가

### 성능
- [ ] N+1 쿼리 없음
- [ ] 적절한 인덱스 사용
- [ ] 대용량 데이터 처리 검증
- [ ] 메모리 누수 확인

### 코드 품질
- [ ] 네이밍 컨벤션 준수
- [ ] 중복 코드 최소화
- [ ] 복잡도 적정 수준
- [ ] 주석 (필요시)

### 문서화
- [ ] API 문서 업데이트
- [ ] README 업데이트 (필요시)
- [ ] CHANGELOG 작성

### Git
- [ ] 의미있는 커밋 메시지
- [ ] 적절한 브랜치명
- [ ] .gitignore 확인
```

---

## 일주일 단위 계획 템플릿

### 주간 계획 수립

**매주 월요일 아침:**

```
Claude, 이번 주 스프린트를 계획하자:

[완료된 작업]
- 지난주에 완료한 기능들...

[이번 주 목표]
- 스프린트 백로그에서 가져온 태스크들...

[가용 시간]
- 월-금 하루 6시간 개발 가능
- 수요일 오후는 미팅

[제약사항]
- 금요일까지 데모 준비 필요
- 기술 부채 20% 할당

다음을 만들어줘:
1. 일별 작업 계획
2. 각 태스크 예상 시간
3. 리스크 요인 및 대응책
4. 일일 체크포인트
```

### 주간 회고

**매주 금요일 저녁:**

```
이번 주를 회고하자:

[완료 현황]
Git 로그를 분석해서:
- 커밋 수
- 변경된 파일 수
- 추가/삭제 라인 수
- 주요 기능 목록

[품질 지표]
- 테스트 커버리지 변화
- 버그 발생 수
- 코드 리뷰 코멘트 수

[Claude 활용도]
- AI가 생성한 코드 비율
- 수동으로 수정한 비율
- 효과적이었던 프롬프트 패턴
- 개선이 필요한 부분

[다음 주 개선사항]
- 이번 주 문제점 기반 개선 계획
- 새로 시도할 워크플로우

리포트 형식으로 정리해줘.
```

---

## 도구 및 자동화

### Git 자동화

```
Git 작업을 자동화해줘:

[매일 아침]
1. 현재 브랜치 상태 확인
2. upstream 변경사항 pull
3. 충돌 여부 확인
4. 오늘 작업할 브랜치 생성/전환

[개발 중]
1. 의미있는 단위로 자동 commit
2. Conventional Commits 형식
3. 관련 파일들 함께 커밋

[저녁]
1. 하루 작업 요약
2. commit history 정리
3. 브랜치 push

스크립트나 명령어로 만들어줘.
```

### 문서 자동 생성

```
프로젝트 문서를 자동으로 생성/업데이트해줘:

[API 문서]
- Controller 클래스들을 스캔
- Swagger/OpenAPI 스펙 생성
- 예제 요청/응답 포함

[데이터베이스 문서]
- 테이블 스키마 다이어그램
- 관계도 (ERD)
- 인덱스 목록

[아키텍처 문서]
- 레이어 다이어그램
- 데이터 흐름도
- 배포 구조

[CHANGELOG]
- Git 커밋 기반 변경사항
- 버전별 정리
- Breaking Changes 강조

주간 단위로 자동 업데이트되도록.
```

---

## 트러블슈팅 가이드

### 일반적인 문제와 해결책

#### 문제 1: Claude가 요구사항을 잘못 이해

**증상:**
```
내가 원한 건 A인데 Claude는 B를 만들었어.
```

**해결책:**
```
내 요구사항을 다시 설명할게:

[원래 요청]
"주식 차트를 추가해줘"

[명확한 요청]
"StockDetail 페이지에 Recharts 라이브러리를 사용해서
최근 30일간의 종가를 선 그래프로 표시해줘.

- X축: 날짜 (YYYY-MM-DD 형식)
- Y축: 가격 (원화, 천원 단위)
- 툴팁: 날짜와 정확한 가격 표시
- 색상: 상승은 빨강, 하락은 파랑

현재 StockDetail.jsx 파일을 수정해서 구현해줘."
```

#### 문제 2: 생성된 코드에 버그가 있음

**증상:**
```
Claude가 생성한 코드가 실행되지 않아.
NullPointerException 발생.
```

**해결책:**
```
다음 에러를 분석하고 수정해줘:

[에러 메시지]
```
java.lang.NullPointerException: Cannot invoke "com.stock.model.Stock.getName()" 
because "stock" is null
    at com.stock.service.StockService.getStockInfo(StockService.java:45)
```

[발생 상황]
- /api/stocks/999999 호출 시
- 존재하지 않는 stock_id

[기대 동작]
- 404 Not Found 응답
- 명확한 에러 메시지

코드를 수정하고 테스트를 추가해줘.
```

#### 문제 3: 성능이 예상보다 느림

**증상:**
```
API 응답이 3초 이상 걸려.
```

**해결책:**
```
/api/portfolios/1 엔드포인트 성능을 분석해줘:

[현재 상황]
- 응답 시간: 3.2초
- 데이터량: 포트폴리오 1개, 주식 20개

[분석 요청]
1. SQL 쿼리 실행 계획
2. N+1 쿼리 여부
3. 인덱스 활용도
4. 불필요한 데이터 로딩

[최적화]
각 이슈별 해결 방안과 예상 개선율을 알려줘.
그리고 실제로 적용해줘.
```

---

## 체크리스트: 다 익혔나요?

### Week 1 완료 체크리스트

- [ ] CLAUDE.md 파일 작성 완료
- [ ] 첫 AI 협업으로 CRUD 기능 구현
- [ ] 일일 회고 루틴 확립
- [ ] 코드 검토 체크리스트 사용
- [ ] 간단한 리팩토링 경험

### Week 2 완료 체크리스트

- [ ] 복잡한 멀티레이어 기능 구현
- [ ] 3시간 이상 연속 작업 세션 경험
- [ ] Stop Hooks 활용
- [ ] 아침/저녁 루틴 확립
- [ ] Git 자동화 워크플로우 구축

### Week 3 완료 체크리스트

- [ ] Pull Request 자동 생성
- [ ] 코드 리뷰 응답 자동화
- [ ] 페어 프로그래밍 경험
- [ ] 팀 협업 패턴 확립

### Week 4 완료 체크리스트

- [ ] 대규모 리팩토링 완료
- [ ] 성능 최적화 프로젝트 수행
- [ ] 프로덕션 레벨 품질 달성
- [ ] 월간 100+ 커밋 달성

---

## 다음 단계: 259 PRs 챌린지

Week 4를 성공적으로 완료했다면, 이제 Boris Cherny 수준에 도전할 준비가 되었습니다.

### 30일 챌린지 시작하기

```
Claude, 30일 동안 259 PRs 챌린지를 시작할 거야.

[목표]
- 30일간 259개 Pull Requests
- 평균 하루 8-9개 PR
- 모든 PR은 의미있는 기능/개선

[전략]
- 큰 기능을 작은 PR로 분할
- 매일 아침 8-10개 작업 계획
- 점심 전 3-4개, 오후 5-6개 완료

[측정]
- 일일 PR 수
- 코드 품질 지표
- 리뷰 통과율
- 배포 성공률

첫 주 계획을 세워줘.
```

---

## 마치며

Continuous Agentic Development는 단순한 도구 사용법이 아닙니다. 개발자로서 일하는 방식 전체를 바꾸는 것입니다.

이 가이드의 워크플로우들을 하나씩 익히세요. 처음에는 어색하겠지만, 2-3주면 자연스러워집니다. 한 달이 지나면 예전 방식으로는 돌아갈 수 없을 것입니다.

기억하세요:
- **당신은 편집장입니다** - 코드를 타이핑하는 사람이 아닙니다
- **80%는 방향 설정에** - 20%만 검증에 사용하세요
- **AI를 신뢰하되 검증하세요** - 맹목적 신뢰는 금물
- **작게 시작하세요** - 한 번에 모든 것을 바꾸려 하지 마세요

내일 아침, 이 가이드의 Day 1부터 시작하세요. 
당신의 개발 인생이 바뀔 것입니다.

---

**작성일:** 2025-12-28  
**기반:** Boris Cherny 사례, Rakuten 사례, Anthropic 공식 베스트 프랙티스  

[#](https://claude.ai/public/artifacts/73de0cda-77f6-419a-95da-a52309b30d44)