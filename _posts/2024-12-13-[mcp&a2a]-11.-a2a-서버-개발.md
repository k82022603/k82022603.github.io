---
title: "[MCP&A2A] 11. A2A ì„œë²„ ê°œë°œ"
date: 2024-12-13 10:10:00 +0900
categories: [AI,  MCP & A2A]
mermaid: [True]
tags: [AI,  MCP,  A2A,  Guide,  MCP-A2A-Guide,  Medium,  Claude.write]
---


## Agent-to-Agent Protocol (A2A) ì„œë²„

A2A ì„œë²„ëŠ” AI ì—ì´ì „íŠ¸ ê°„ ë¹„ë™ê¸° í˜‘ì—…ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ì¸í”„ë¼ì…ë‹ˆë‹¤. MCPê°€ ë™ê¸°ì‹ ë„êµ¬ ì‹¤í–‰ì— ì§‘ì¤‘í•œë‹¤ë©´, A2AëŠ” ì¥ê¸° ì‹¤í–‰ íƒœìŠ¤í¬ì™€ ì—ì´ì „íŠ¸ ê°„ í†µì‹ ì— ìµœì í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

### A2A vs MCP ë¹„êµ

| íŠ¹ì„± | A2A | MCP |
|------|-----|-----|
| **í†µì‹  íŒ¨í„´** | ë¹„ë™ê¸° (Task ê¸°ë°˜) | ë™ê¸° (Request-Response) |
| **ì‹¤í–‰ ì‹œê°„** | ì´ˆ~ë¶„~ì‹œê°„ | ë°€ë¦¬ì´ˆ~ì´ˆ |
| **ìƒíƒœ ê´€ë¦¬** | Stateful (íƒœìŠ¤í¬ ì¶”ì ) | Stateless |
| **ì§„í–‰ ìƒí™©** | SSE ìŠ¤íŠ¸ë¦¬ë° | ì—†ìŒ |
| **ìš©ë„** | ì—ì´ì „íŠ¸ í˜‘ì—…, ì›Œí¬í”Œë¡œìš° | ë„êµ¬ ì‹¤í–‰, ë°ì´í„° ì¡°íšŒ |
| **ë³µì¡ë„** | ë†’ìŒ | ë‚®ìŒ |

### A2Aê°€ í•„ìš”í•œ ì‹œë‚˜ë¦¬ì˜¤

```
âœ… A2A ì‚¬ìš©:
- ë©€í‹°ìŠ¤í… ë¦¬ì„œì¹˜ (ê²€ìƒ‰ â†’ ë¶„ì„ â†’ ë³´ê³ ì„œ ìƒì„±)
- ì½”ë“œ ë¦¬ë·° (ë¶„ì„ â†’ ê°œì„  ì œì•ˆ â†’ ë¦¬íŒ©í† ë§)
- ë°ì´í„° íŒŒì´í”„ë¼ì¸ (ìˆ˜ì§‘ â†’ ë³€í™˜ â†’ ì €ì¥)
- ì—ì´ì „íŠ¸ íŒ€ í˜‘ì—… (ì¡°ìœ¨ì â†’ ì‘ì—…ì â†’ ê²€ì¦ì)

âŒ A2A ë¶ˆí•„ìš” (MCP ì‚¬ìš©):
- ë‹¨ì¼ ë¬¸ì„œ ê²€ìƒ‰
- ê°„ë‹¨í•œ ê³„ì‚°
- ë¹ ë¥¸ API í˜¸ì¶œ
```

## í”„ë¡œì íŠ¸ êµ¬ì¡°

```
a2a-server/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go                 # ì§„ì…ì 
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ task.go                 # íƒœìŠ¤í¬ ëª¨ë¸
â”‚   â”‚   â”œâ”€â”€ agent_card.go           # ì—ì´ì „íŠ¸ ì¹´ë“œ
â”‚   â”‚   â””â”€â”€ artifact.go             # ê²°ê³¼ë¬¼
â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”œâ”€â”€ task_store.go           # íƒœìŠ¤í¬ ì €ì¥ì†Œ
â”‚   â”‚   â””â”€â”€ postgres_store.go       # PostgreSQL êµ¬í˜„
â”‚   â”œâ”€â”€ executor/
â”‚   â”‚   â”œâ”€â”€ executor.go             # íƒœìŠ¤í¬ ì‹¤í–‰ê¸°
â”‚   â”‚   â””â”€â”€ worker_pool.go          # ì›Œì»¤ í’€
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ agent_card.go           # Agent Card í•¸ë“¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ tasks.go                # íƒœìŠ¤í¬ CRUD
â”‚   â”‚   â”œâ”€â”€ messages.go             # ë©”ì‹œì§€ í•¸ë“¤ëŸ¬
â”‚   â”‚   â””â”€â”€ events.go               # SSE ìŠ¤íŠ¸ë¦¬ë°
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.go                 # JWT ì¸ì¦
â”‚   â”‚   â””â”€â”€ cors.go                 # CORS
â”‚   â””â”€â”€ skills/
â”‚       â”œâ”€â”€ skill.go                # Skill ì¸í„°í˜ì´ìŠ¤
â”‚       â”œâ”€â”€ research.go             # ë¦¬ì„œì¹˜ ìŠ¤í‚¬
â”‚       â””â”€â”€ analysis.go             # ë¶„ì„ ìŠ¤í‚¬
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

## í•µì‹¬ ëª¨ë¸

### 1. Task ëª¨ë¸

```go
// internal/models/task.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

// TaskStatus ì—´ê±°í˜•
type TaskStatus string

const (
    StatusPending   TaskStatus = "pending"   // ëŒ€ê¸° ì¤‘
    StatusRunning   TaskStatus = "running"   // ì‹¤í–‰ ì¤‘
    StatusCompleted TaskStatus = "completed" // ì™„ë£Œ
    StatusFailed    TaskStatus = "failed"    // ì‹¤íŒ¨
    StatusCancelled TaskStatus = "cancelled" // ì·¨ì†Œë¨
)

// Task êµ¬ì¡°ì²´
type Task struct {
    ID        string                 `json:"taskId"`
    AgentID   string                 `json:"agentId"`
    Skill     string                 `json:"skill"`
    Input     map[string]interface{} `json:"input"`
    Status    TaskStatus             `json:"status"`
    Artifacts []Artifact             `json:"artifacts,omitempty"`
    Error     *TaskError             `json:"error,omitempty"`
    
    // ë©”íƒ€ë°ì´í„°
    CreatedAt time.Time `json:"createdAt"`
    UpdatedAt time.Time `json:"updatedAt"`
    StartedAt *time.Time `json:"startedAt,omitempty"`
    EndedAt   *time.Time `json:"endedAt,omitempty"`
    
    // ì§„í–‰ ìƒí™©
    Progress  *TaskProgress `json:"progress,omitempty"`
    
    // ë‚´ë¶€ í•„ë“œ
    TenantID  string `json:"-"`
    UserID    string `json:"-"`
}

// TaskProgress ì§„í–‰ ìƒí™©
type TaskProgress struct {
    Current int    `json:"current"`
    Total   int    `json:"total"`
    Message string `json:"message"`
}

// TaskError ì—ëŸ¬ ì •ë³´
type TaskError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details map[string]interface{} `json:"details,omitempty"`
}

// NewTask ìƒì„±ì
func NewTask(agentID, skill string, input map[string]interface{}) *Task {
    now := time.Now()
    return &Task{
        ID:        uuid.New().String(),
        AgentID:   agentID,
        Skill:     skill,
        Input:     input,
        Status:    StatusPending,
        CreatedAt: now,
        UpdatedAt: now,
    }
}

// Start íƒœìŠ¤í¬ ì‹œì‘
func (t *Task) Start() {
    now := time.Now()
    t.Status = StatusRunning
    t.StartedAt = &now
    t.UpdatedAt = now
}

// Complete íƒœìŠ¤í¬ ì™„ë£Œ
func (t *Task) Complete(artifacts []Artifact) {
    now := time.Now()
    t.Status = StatusCompleted
    t.Artifacts = artifacts
    t.EndedAt = &now
    t.UpdatedAt = now
}

// Fail íƒœìŠ¤í¬ ì‹¤íŒ¨
func (t *Task) Fail(err error) {
    now := time.Now()
    t.Status = StatusFailed
    t.Error = &TaskError{
        Code:    "EXECUTION_ERROR",
        Message: err.Error(),
    }
    t.EndedAt = &now
    t.UpdatedAt = now
}

// UpdateProgress ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
func (t *Task) UpdateProgress(current, total int, message string) {
    t.Progress = &TaskProgress{
        Current: current,
        Total:   total,
        Message: message,
    }
    t.UpdatedAt = time.Now()
}

// Duration ì‹¤í–‰ ì‹œê°„ (ì™„ë£Œëœ íƒœìŠ¤í¬ë§Œ)
func (t *Task) Duration() time.Duration {
    if t.StartedAt == nil || t.EndedAt == nil {
        return 0
    }
    return t.EndedAt.Sub(*t.StartedAt)
}
```

### 2. Artifact ëª¨ë¸

```go
// internal/models/artifact.go
package models

import (
    "time"
    
    "github.com/google/uuid"
)

// Artifact ê²°ê³¼ë¬¼
type Artifact struct {
    ID        string    `json:"artifactId"`
    Name      string    `json:"name"`
    Parts     []Part    `json:"parts"`
    CreatedAt time.Time `json:"createdAt"`
}

// Part ì½˜í…ì¸  ë¸”ë¡
type Part struct {
    Kind     string                 `json:"kind"` // text, data, file, image
    Text     string                 `json:"text,omitempty"`
    Data     interface{}            `json:"data,omitempty"`
    URL      string                 `json:"url,omitempty"`
    MimeType string                 `json:"mimeType,omitempty"`
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// NewArtifact ìƒì„±ì
func NewArtifact(name string, parts []Part) *Artifact {
    return &Artifact{
        ID:        uuid.New().String(),
        Name:      name,
        Parts:     parts,
        CreatedAt: time.Now(),
    }
}

// NewTextArtifact í…ìŠ¤íŠ¸ ê²°ê³¼ë¬¼
func NewTextArtifact(name, text string) *Artifact {
    return NewArtifact(name, []Part{
        {
            Kind: "text",
            Text: text,
        },
    })
}

// NewDataArtifact ë°ì´í„° ê²°ê³¼ë¬¼
func NewDataArtifact(name string, data interface{}) *Artifact {
    return NewArtifact(name, []Part{
        {
            Kind: "data",
            Data: data,
        },
    })
}

// NewFileArtifact íŒŒì¼ ê²°ê³¼ë¬¼
func NewFileArtifact(name, url, mimeType string) *Artifact {
    return NewArtifact(name, []Part{
        {
            Kind:     "file",
            URL:      url,
            MimeType: mimeType,
        },
    })
}
```

### 3. Agent Card ëª¨ë¸

```go
// internal/models/agent_card.go
package models

// AgentCard ì—ì´ì „íŠ¸ ì •ì˜
type AgentCard struct {
    Name           string              `json:"name"`
    Description    string              `json:"description"`
    URL            string              `json:"url"`
    Version        string              `json:"version"`
    Skills         []Skill             `json:"skills"`
    Authentication *AuthenticationInfo `json:"authentication,omitempty"`
}

// Skill ìŠ¤í‚¬ ì •ì˜
type Skill struct {
    Name        string   `json:"name"`
    Description string   `json:"description"`
    InputModes  []string `json:"inputModes"`  // text, data, file, image
    OutputModes []string `json:"outputModes"`
}

// AuthenticationInfo ì¸ì¦ ì •ë³´
type AuthenticationInfo struct {
    Type        string `json:"type"` // bearer, basic, oauth2
    Description string `json:"description,omitempty"`
}

// NewAgentCard ìƒì„±ì
func NewAgentCard(name, description, url, version string) *AgentCard {
    return &AgentCard{
        Name:        name,
        Description: description,
        URL:         url,
        Version:     version,
        Skills:      []Skill{},
    }
}

// AddSkill ìŠ¤í‚¬ ì¶”ê°€
func (ac *AgentCard) AddSkill(skill Skill) {
    ac.Skills = append(ac.Skills, skill)
}
```

## Task Store êµ¬í˜„

### ì¸í„°í˜ì´ìŠ¤

```go
// internal/store/task_store.go
package store

import (
    "context"
    "time"
    
    "a2a-server/internal/models"
)

// TaskStore ì¸í„°í˜ì´ìŠ¤
type TaskStore interface {
    // íƒœìŠ¤í¬ ìƒì„±
    Create(ctx context.Context, task *models.Task) error
    
    // íƒœìŠ¤í¬ ì¡°íšŒ
    Get(ctx context.Context, taskID string) (*models.Task, error)
    
    // íƒœìŠ¤í¬ ëª©ë¡ (í…Œë„ŒíŠ¸ë³„)
    List(ctx context.Context, tenantID string, params ListParams) ([]*models.Task, error)
    
    // íƒœìŠ¤í¬ ì—…ë°ì´íŠ¸
    Update(ctx context.Context, task *models.Task) error
    
    // íƒœìŠ¤í¬ ì‚­ì œ
    Delete(ctx context.Context, taskID string) error
    
    // ìƒíƒœë³„ ì¡°íšŒ
    GetByStatus(ctx context.Context, status models.TaskStatus, limit int) ([]*models.Task, error)
}

// ListParams ëª©ë¡ ì¡°íšŒ íŒŒë¼ë¯¸í„°
type ListParams struct {
    Status    models.TaskStatus
    AgentID   string
    Limit     int
    Offset    int
    SortBy    string // created_at, updated_at
    SortOrder string // asc, desc
}
```

### PostgreSQL êµ¬í˜„

```go
// internal/store/postgres_store.go
package store

import (
    "context"
    "encoding/json"
    "fmt"
    
    "github.com/jackc/pgx/v5/pgxpool"
    
    "a2a-server/internal/models"
)

type PostgresStore struct {
    pool *pgxpool.Pool
}

func NewPostgresStore(pool *pgxpool.Pool) *PostgresStore {
    return &PostgresStore{pool: pool}
}

// Create íƒœìŠ¤í¬ ìƒì„±
func (s *PostgresStore) Create(ctx context.Context, task *models.Task) error {
    inputJSON, err := json.Marshal(task.Input)
    if err != nil {
        return fmt.Errorf("failed to marshal input: %w", err)
    }
    
    query := `
        INSERT INTO tasks (
            id, tenant_id, user_id, agent_id, skill,
            input, status, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `
    
    _, err = s.pool.Exec(
        ctx, query,
        task.ID,
        task.TenantID,
        task.UserID,
        task.AgentID,
        task.Skill,
        inputJSON,
        task.Status,
        task.CreatedAt,
        task.UpdatedAt,
    )
    
    return err
}

// Get íƒœìŠ¤í¬ ì¡°íšŒ
func (s *PostgresStore) Get(ctx context.Context, taskID string) (*models.Task, error) {
    query := `
        SELECT 
            id, tenant_id, user_id, agent_id, skill,
            input, status, artifacts, error,
            created_at, updated_at, started_at, ended_at,
            progress
        FROM tasks
        WHERE id = $1
    `
    
    var task models.Task
    var inputJSON, artifactsJSON, errorJSON, progressJSON []byte
    var startedAt, endedAt *time.Time
    
    err := s.pool.QueryRow(ctx, query, taskID).Scan(
        &task.ID,
        &task.TenantID,
        &task.UserID,
        &task.AgentID,
        &task.Skill,
        &inputJSON,
        &task.Status,
        &artifactsJSON,
        &errorJSON,
        &task.CreatedAt,
        &task.UpdatedAt,
        &startedAt,
        &endedAt,
        &progressJSON,
    )
    
    if err != nil {
        return nil, err
    }
    
    // JSON ì–¸ë§ˆìƒ¬ë§
    if err := json.Unmarshal(inputJSON, &task.Input); err != nil {
        return nil, err
    }
    
    if len(artifactsJSON) > 0 {
        if err := json.Unmarshal(artifactsJSON, &task.Artifacts); err != nil {
            return nil, err
        }
    }
    
    if len(errorJSON) > 0 {
        if err := json.Unmarshal(errorJSON, &task.Error); err != nil {
            return nil, err
        }
    }
    
    if len(progressJSON) > 0 {
        if err := json.Unmarshal(progressJSON, &task.Progress); err != nil {
            return nil, err
        }
    }
    
    task.StartedAt = startedAt
    task.EndedAt = endedAt
    
    return &task, nil
}

// Update íƒœìŠ¤í¬ ì—…ë°ì´íŠ¸
func (s *PostgresStore) Update(ctx context.Context, task *models.Task) error {
    inputJSON, _ := json.Marshal(task.Input)
    artifactsJSON, _ := json.Marshal(task.Artifacts)
    errorJSON, _ := json.Marshal(task.Error)
    progressJSON, _ := json.Marshal(task.Progress)
    
    query := `
        UPDATE tasks SET
            status = $2,
            input = $3,
            artifacts = $4,
            error = $5,
            updated_at = $6,
            started_at = $7,
            ended_at = $8,
            progress = $9
        WHERE id = $1
    `
    
    _, err := s.pool.Exec(
        ctx, query,
        task.ID,
        task.Status,
        inputJSON,
        artifactsJSON,
        errorJSON,
        task.UpdatedAt,
        task.StartedAt,
        task.EndedAt,
        progressJSON,
    )
    
    return err
}

// List íƒœìŠ¤í¬ ëª©ë¡
func (s *PostgresStore) List(ctx context.Context, tenantID string, params ListParams) ([]*models.Task, error) {
    query := `
        SELECT 
            id, agent_id, skill, status,
            created_at, updated_at
        FROM tasks
        WHERE tenant_id = $1
    `
    
    args := []interface{}{tenantID}
    argIndex := 2
    
    // í•„í„° ì¶”ê°€
    if params.Status != "" {
        query += fmt.Sprintf(" AND status = $%d", argIndex)
        args = append(args, params.Status)
        argIndex++
    }
    
    if params.AgentID != "" {
        query += fmt.Sprintf(" AND agent_id = $%d", argIndex)
        args = append(args, params.AgentID)
        argIndex++
    }
    
    // ì •ë ¬
    sortBy := params.SortBy
    if sortBy == "" {
        sortBy = "created_at"
    }
    
    sortOrder := params.SortOrder
    if sortOrder == "" {
        sortOrder = "desc"
    }
    
    query += fmt.Sprintf(" ORDER BY %s %s", sortBy, sortOrder)
    
    // í˜ì´ì§€ë„¤ì´ì…˜
    if params.Limit > 0 {
        query += fmt.Sprintf(" LIMIT $%d", argIndex)
        args = append(args, params.Limit)
        argIndex++
    }
    
    if params.Offset > 0 {
        query += fmt.Sprintf(" OFFSET $%d", argIndex)
        args = append(args, params.Offset)
    }
    
    rows, err := s.pool.Query(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var tasks []*models.Task
    for rows.Next() {
        var task models.Task
        err := rows.Scan(
            &task.ID,
            &task.AgentID,
            &task.Skill,
            &task.Status,
            &task.CreatedAt,
            &task.UpdatedAt,
        )
        if err != nil {
            return nil, err
        }
        
        tasks = append(tasks, &task)
    }
    
    return tasks, nil
}

// GetByStatus ìƒíƒœë³„ ì¡°íšŒ
func (s *PostgresStore) GetByStatus(ctx context.Context, status models.TaskStatus, limit int) ([]*models.Task, error) {
    query := `
        SELECT id, tenant_id, agent_id, skill, input, status, created_at
        FROM tasks
        WHERE status = $1
        ORDER BY created_at ASC
        LIMIT $2
    `
    
    rows, err := s.pool.Query(ctx, query, status, limit)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var tasks []*models.Task
    for rows.Next() {
        var task models.Task
        var inputJSON []byte
        
        err := rows.Scan(
            &task.ID,
            &task.TenantID,
            &task.AgentID,
            &task.Skill,
            &inputJSON,
            &task.Status,
            &task.CreatedAt,
        )
        if err != nil {
            return nil, err
        }
        
        json.Unmarshal(inputJSON, &task.Input)
        tasks = append(tasks, &task)
    }
    
    return tasks, nil
}
```

### ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- tasks í…Œì´ë¸”
CREATE TABLE tasks (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    user_id TEXT NOT NULL,
    agent_id TEXT NOT NULL,
    skill TEXT NOT NULL,
    
    -- ì…ë ¥/ì¶œë ¥
    input JSONB NOT NULL,
    artifacts JSONB,
    error JSONB,
    
    -- ìƒíƒœ
    status TEXT NOT NULL,
    progress JSONB,
    
    -- íƒ€ì„ìŠ¤íƒ¬í”„
    created_at TIMESTAMPTZ NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL,
    started_at TIMESTAMPTZ,
    ended_at TIMESTAMPTZ
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_tasks_tenant_id ON tasks(tenant_id);
CREATE INDEX idx_tasks_status ON tasks(status) WHERE status IN ('pending', 'running');
CREATE INDEX idx_tasks_agent_id ON tasks(agent_id);
CREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);

-- RLS í™œì„±í™”
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation ON tasks
    USING (tenant_id = current_setting('app.current_tenant_id', true)::uuid);
```

## Task Executor êµ¬í˜„

### Executor ì¸í„°í˜ì´ìŠ¤

```go
// internal/executor/executor.go
package executor

import (
    "context"
    
    "a2a-server/internal/models"
)

// Executor íƒœìŠ¤í¬ ì‹¤í–‰ê¸°
type Executor interface {
    Execute(ctx context.Context, task *models.Task) error
}

// SkillExecutor ìŠ¤í‚¬ë³„ ì‹¤í–‰ê¸°
type SkillExecutor interface {
    Name() string
    Execute(ctx context.Context, input map[string]interface{}) ([]models.Artifact, error)
}
```

### Worker Pool êµ¬í˜„

```go
// internal/executor/worker_pool.go
package executor

import (
    "context"
    "log"
    "sync"
    
    "a2a-server/internal/models"
    "a2a-server/internal/store"
)

type WorkerPool struct {
    taskStore store.TaskStore
    skills    map[string]SkillExecutor
    
    workers   int
    taskQueue chan *models.Task
    wg        sync.WaitGroup
    
    eventBus *EventBus
}

func NewWorkerPool(
    taskStore store.TaskStore,
    workers int,
    eventBus *EventBus,
) *WorkerPool {
    return &WorkerPool{
        taskStore: taskStore,
        skills:    make(map[string]SkillExecutor),
        workers:   workers,
        taskQueue: make(chan *models.Task, workers*2),
        eventBus:  eventBus,
    }
}

// RegisterSkill ìŠ¤í‚¬ ë“±ë¡
func (wp *WorkerPool) RegisterSkill(skill SkillExecutor) {
    wp.skills[skill.Name()] = skill
}

// Start ì›Œì»¤ í’€ ì‹œì‘
func (wp *WorkerPool) Start(ctx context.Context) {
    log.Printf("Starting worker pool with %d workers", wp.workers)
    
    for i := 0; i < wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker(ctx, i)
    }
    
    // ëŒ€ê¸° ì¤‘ì¸ íƒœìŠ¤í¬ í´ë§
    go wp.pollPendingTasks(ctx)
}

// Stop ì›Œì»¤ í’€ ì¤‘ì§€
func (wp *WorkerPool) Stop() {
    close(wp.taskQueue)
    wp.wg.Wait()
    log.Println("Worker pool stopped")
}

// Submit íƒœìŠ¤í¬ ì œì¶œ
func (wp *WorkerPool) Submit(task *models.Task) {
    wp.taskQueue <- task
}

// worker ê°œë³„ ì›Œì»¤
func (wp *WorkerPool) worker(ctx context.Context, id int) {
    defer wp.wg.Done()
    
    log.Printf("Worker %d started", id)
    
    for task := range wp.taskQueue {
        log.Printf("Worker %d processing task %s", id, task.ID)
        
        if err := wp.executeTask(ctx, task); err != nil {
            log.Printf("Worker %d failed task %s: %v", id, task.ID, err)
        }
    }
    
    log.Printf("Worker %d stopped", id)
}

// executeTask íƒœìŠ¤í¬ ì‹¤í–‰
func (wp *WorkerPool) executeTask(ctx context.Context, task *models.Task) error {
    // ìŠ¤í‚¬ ì°¾ê¸°
    skill, ok := wp.skills[task.Skill]
    if !ok {
        task.Fail(fmt.Errorf("skill not found: %s", task.Skill))
        wp.taskStore.Update(ctx, task)
        wp.eventBus.Publish(task.ID, Event{
            Type: "error",
            Data: map[string]interface{}{
                "message": "Skill not found",
            },
        })
        return fmt.Errorf("skill not found: %s", task.Skill)
    }
    
    // íƒœìŠ¤í¬ ì‹œì‘
    task.Start()
    wp.taskStore.Update(ctx, task)
    wp.eventBus.Publish(task.ID, Event{
        Type: "started",
        Data: map[string]interface{}{
            "taskId": task.ID,
        },
    })
    
    // ìŠ¤í‚¬ ì‹¤í–‰
    artifacts, err := skill.Execute(ctx, task.Input)
    
    if err != nil {
        // ì‹¤íŒ¨ ì²˜ë¦¬
        task.Fail(err)
        wp.taskStore.Update(ctx, task)
        wp.eventBus.Publish(task.ID, Event{
            Type: "error",
            Data: map[string]interface{}{
                "message": err.Error(),
            },
        })
        return err
    }
    
    // ì™„ë£Œ ì²˜ë¦¬
    task.Complete(artifacts)
    wp.taskStore.Update(ctx, task)
    wp.eventBus.Publish(task.ID, Event{
        Type: "completed",
        Data: map[string]interface{}{
            "taskId":    task.ID,
            "artifacts": artifacts,
        },
    })
    
    log.Printf("Task %s completed in %v", task.ID, task.Duration())
    
    return nil
}

// pollPendingTasks ëŒ€ê¸° ì¤‘ì¸ íƒœìŠ¤í¬ í´ë§
func (wp *WorkerPool) pollPendingTasks(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            tasks, err := wp.taskStore.GetByStatus(ctx, models.StatusPending, wp.workers)
            if err != nil {
                log.Printf("Failed to poll pending tasks: %v", err)
                continue
            }
            
            for _, task := range tasks {
                select {
                case wp.taskQueue <- task:
                    log.Printf("Queued pending task %s", task.ID)
                default:
                    log.Printf("Queue full, skipping task %s", task.ID)
                }
            }
        }
    }
}
```

### Event Bus (SSEìš©)

```go
// internal/executor/event_bus.go
package executor

import (
    "sync"
)

type Event struct {
    Type string
    Data map[string]interface{}
}

type EventBus struct {
    subscribers map[string][]chan Event
    mu          sync.RWMutex
}

func NewEventBus() *EventBus {
    return &EventBus{
        subscribers: make(map[string][]chan Event),
    }
}

// Subscribe ì´ë²¤íŠ¸ êµ¬ë…
func (eb *EventBus) Subscribe(taskID string) chan Event {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    ch := make(chan Event, 10)
    eb.subscribers[taskID] = append(eb.subscribers[taskID], ch)
    
    return ch
}

// Unsubscribe êµ¬ë… ì·¨ì†Œ
func (eb *EventBus) Unsubscribe(taskID string, ch chan Event) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    
    subs := eb.subscribers[taskID]
    for i, sub := range subs {
        if sub == ch {
            eb.subscribers[taskID] = append(subs[:i], subs[i+1:]...)
            close(ch)
            break
        }
    }
    
    if len(eb.subscribers[taskID]) == 0 {
        delete(eb.subscribers, taskID)
    }
}

// Publish ì´ë²¤íŠ¸ ë°œí–‰
func (eb *EventBus) Publish(taskID string, event Event) {
    eb.mu.RLock()
    defer eb.mu.RUnlock()
    
    for _, ch := range eb.subscribers[taskID] {
        select {
        case ch <- event:
        default:
            // ì±„ë„ì´ ê°€ë“ ì°¨ë©´ ë¬´ì‹œ
        }
    }
}
```

## HTTP í•¸ë“¤ëŸ¬

### Agent Card í•¸ë“¤ëŸ¬

```go
// internal/handlers/agent_card.go
package handlers

import (
    "encoding/json"
    "net/http"
    
    "a2a-server/internal/models"
)

type AgentCardHandler struct {
    agentCard *models.AgentCard
}

func NewAgentCardHandler(agentCard *models.AgentCard) *AgentCardHandler {
    return &AgentCardHandler{agentCard: agentCard}
}

// GET /.well-known/agent-card.json
func (h *AgentCardHandler) Get(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(h.agentCard)
}
```

### Task í•¸ë“¤ëŸ¬

```go
// internal/handlers/tasks.go
package handlers

import (
    "encoding/json"
    "net/http"
    
    "github.com/go-chi/chi/v5"
    
    "a2a-server/internal/executor"
    "a2a-server/internal/models"
    "a2a-server/internal/store"
)

type TaskHandler struct {
    taskStore  store.TaskStore
    workerPool *executor.WorkerPool
}

func NewTaskHandler(taskStore store.TaskStore, workerPool *executor.WorkerPool) *TaskHandler {
    return &TaskHandler{
        taskStore:  taskStore,
        workerPool: workerPool,
    }
}

// POST /a2a/{agentId}/tasks
func (h *TaskHandler) Create(w http.ResponseWriter, r *http.Request) {
    agentID := chi.URLParam(r, "agentId")
    
    var req struct {
        Skill string                 `json:"skill"`
        Input map[string]interface{} `json:"input"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request", http.StatusBadRequest)
        return
    }
    
    // íƒœìŠ¤í¬ ìƒì„±
    task := models.NewTask(agentID, req.Skill, req.Input)
    task.TenantID = r.Context().Value("tenant_id").(string)
    task.UserID = r.Context().Value("user_id").(string)
    
    // ì €ì¥
    if err := h.taskStore.Create(r.Context(), task); err != nil {
        http.Error(w, "Failed to create task", http.StatusInternalServerError)
        return
    }
    
    // ì›Œì»¤ í’€ì— ì œì¶œ
    h.workerPool.Submit(task)
    
    // ì‘ë‹µ
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(task)
}

// GET /a2a/{agentId}/tasks/{taskId}
func (h *TaskHandler) Get(w http.ResponseWriter, r *http.Request) {
    taskID := chi.URLParam(r, "taskId")
    
    task, err := h.taskStore.Get(r.Context(), taskID)
    if err != nil {
        http.Error(w, "Task not found", http.StatusNotFound)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(task)
}

// GET /a2a/{agentId}/tasks
func (h *TaskHandler) List(w http.ResponseWriter, r *http.Request) {
    tenantID := r.Context().Value("tenant_id").(string)
    
    params := store.ListParams{
        Limit:  10,
        Offset: 0,
    }
    
    // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° íŒŒì‹±
    if status := r.URL.Query().Get("status"); status != "" {
        params.Status = models.TaskStatus(status)
    }
    
    tasks, err := h.taskStore.List(r.Context(), tenantID, params)
    if err != nil {
        http.Error(w, "Failed to list tasks", http.StatusInternalServerError)
        return
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(map[string]interface{}{
        "tasks": tasks,
    })
}
```

### SSE ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬

```go
// internal/handlers/events.go
package handlers

import (
    "encoding/json"
    "fmt"
    "net/http"
    
    "github.com/go-chi/chi/v5"
    
    "a2a-server/internal/executor"
)

type EventHandler struct {
    eventBus *executor.EventBus
}

func NewEventHandler(eventBus *executor.EventBus) *EventHandler {
    return &EventHandler{eventBus: eventBus}
}

// GET /a2a/{agentId}/tasks/{taskId}/events
func (h *EventHandler) Stream(w http.ResponseWriter, r *http.Request) {
    taskID := chi.URLParam(r, "taskId")
    
    // SSE í—¤ë” ì„¤ì •
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    w.Header().Set("Access-Control-Allow-Origin", "*")
    
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }
    
    // ì´ë²¤íŠ¸ êµ¬ë…
    eventChan := h.eventBus.Subscribe(taskID)
    defer h.eventBus.Unsubscribe(taskID, eventChan)
    
    // ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¬ë°
    for {
        select {
        case event, ok := <-eventChan:
            if !ok {
                return
            }
            
            // JSON ì§ë ¬í™”
            data, _ := json.Marshal(event.Data)
            
            // SSE í¬ë§·ìœ¼ë¡œ ì „ì†¡
            fmt.Fprintf(w, "event: %s\n", event.Type)
            fmt.Fprintf(w, "data: %s\n\n", data)
            flusher.Flush()
            
            // ì™„ë£Œ ë˜ëŠ” ì—ëŸ¬ ì‹œ ì¢…ë£Œ
            if event.Type == "completed" || event.Type == "error" {
                return
            }
            
        case <-r.Context().Done():
            return
        }
    }
}
```

## main.go - ì „ì²´ ì¡°í•©

```go
// cmd/server/main.go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/jackc/pgx/v5/pgxpool"
    
    "a2a-server/internal/executor"
    "a2a-server/internal/handlers"
    custommw "a2a-server/internal/middleware"
    "a2a-server/internal/models"
    "a2a-server/internal/skills"
    "a2a-server/internal/store"
)

func main() {
    // í™˜ê²½ ë³€ìˆ˜
    dbURL := os.Getenv("DATABASE_URL")
    port := os.Getenv("PORT")
    if port == "" {
        port = "8081"
    }
    
    // DB ì—°ê²°
    pool, err := pgxpool.New(context.Background(), dbURL)
    if err != nil {
        log.Fatal(err)
    }
    defer pool.Close()
    
    log.Println("âœ… Database connected")
    
    // Store ìƒì„±
    taskStore := store.NewPostgresStore(pool)
    
    // Event Bus
    eventBus := executor.NewEventBus()
    
    // Worker Pool
    workerPool := executor.NewWorkerPool(taskStore, 10, eventBus)
    
    // ìŠ¤í‚¬ ë“±ë¡
    workerPool.RegisterSkill(skills.NewResearchSkill())
    workerPool.RegisterSkill(skills.NewAnalysisSkill())
    
    log.Println("âœ… Skills registered")
    
    // Worker Pool ì‹œì‘
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    workerPool.Start(ctx)
    log.Println("âœ… Worker pool started")
    
    // Agent Card
    agentCard := models.NewAgentCard(
        "Research Assistant",
        "Multi-step research and analysis agent",
        "https://api.example.com/a2a/research-assistant",
        "1.0.0",
    )
    agentCard.AddSkill(models.Skill{
        Name:        "research",
        Description: "Comprehensive research on a topic",
        InputModes:  []string{"text"},
        OutputModes: []string{"text", "data"},
    })
    
    // í•¸ë“¤ëŸ¬
    agentCardHandler := handlers.NewAgentCardHandler(agentCard)
    taskHandler := handlers.NewTaskHandler(taskStore, workerPool)
    eventHandler := handlers.NewEventHandler(eventBus)
    
    // ë¼ìš°í„°
    r := chi.NewRouter()
    
    // ë¯¸ë“¤ì›¨ì–´
    r.Use(middleware.RequestID)
    r.Use(middleware.RealIP)
    r.Use(middleware.Logger)
    r.Use(middleware.Recoverer)
    
    // Agent Card (ê³µê°œ)
    r.Get("/.well-known/agent-card.json", agentCardHandler.Get)
    
    // A2A ì—”ë“œí¬ì¸íŠ¸ (ì¸ì¦ í•„ìš”)
    r.Group(func(r chi.Router) {
        r.Use(custommw.AuthMiddleware(jwtValidator))
        
        r.Post("/a2a/{agentId}/tasks", taskHandler.Create)
        r.Get("/a2a/{agentId}/tasks/{taskId}", taskHandler.Get)
        r.Get("/a2a/{agentId}/tasks", taskHandler.List)
        r.Get("/a2a/{agentId}/tasks/{taskId}/events", eventHandler.Stream)
    })
    
    // ì„œë²„ ì‹œì‘
    srv := &http.Server{
        Addr:    ":" + port,
        Handler: r,
    }
    
    go func() {
        log.Printf("ğŸš€ A2A Server listening on :%s", port)
        if err := srv.ListenAndServe(); err != http.ErrServerClosed {
            log.Fatal(err)
        }
    }()
    
    // Graceful shutdown
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    cancel() // Worker pool ì¤‘ì§€
    workerPool.Stop()
    
    shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer shutdownCancel()
    
    if err := srv.Shutdown(shutdownCtx); err != nil {
        log.Fatal(err)
    }
    
    log.Println("âœ… Server stopped")
}
```

## í•µì‹¬ ìš”ì•½

### A2A ì„œë²„ êµ¬ì„±

- âœ… **Models**: Task, Artifact, AgentCard
- âœ… **Store**: PostgreSQL ê¸°ë°˜ ì˜ì†ì„±
- âœ… **Executor**: Worker Pool + Event Bus
- âœ… **Handlers**: Task CRUD + SSE ìŠ¤íŠ¸ë¦¬ë°
- âœ… **Skills**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„

### ì£¼ìš” íŠ¹ì§•

- âœ… **ë¹„ë™ê¸°**: ë°±ê·¸ë¼ìš´ë“œ Worker Pool
- âœ… **í™•ì¥ì„±**: ì›Œì»¤ ìˆ˜ ì¡°ì • ê°€ëŠ¥
- âœ… **ì‹¤ì‹œê°„**: SSEë¡œ ì§„í–‰ ìƒí™© ìŠ¤íŠ¸ë¦¬ë°
- âœ… **ìƒíƒœ ê´€ë¦¬**: PostgreSQLì— íƒœìŠ¤í¬ ì €ì¥
- âœ… **ë©€í‹°í…Œë„Œì‹œ**: RLSë¡œ ê²©ë¦¬


**ì‘ì„±ì¼**: 2024-12-13
