---
title: "\"이게 된다고?!\" — Claude Code와 바이브코딩으로 만든 부동산 자동화 매크로 완전 해설"
date: 2026-02-25 21:00:00 +0900
categories: [AI,  Claude Code]
mermaid: [True]
tags: [AI,  claude-code,  vibe-coding,  Claude.write]
---


> 작성일: 2026-02-25

---

## 들어가며: 당연히 고생해야 한다고 믿었던 것들

"이게 된다고?!"

최근 친구를 위해 자동화 툴을 하나 만들어주고 들은 말이다. 처음 요청은 단순했다. "정해진 시간에 버튼을 동시 클릭하는 게 가능하냐"는 정도였다. 예전이었으면 꽤 공수가 들었겠지만, 지금은 AI가 있다. Claude Code와 바이브코딩으로 크롤링과 매크로를 금방 만들었고, Electron UI에 서버 시계 밀리초 동기화까지 갖춘 꽤 정교한 물건이 나왔다.

그런데 진짜 이야기는 그 다음이었다. 버튼을 누르기 전에, 눌러야 할 대상을 추리는 사전 작업이 존재했다. 매일 수백 건을 복사하고, 검색하고, 확인하는 반복 노가다. 친구는 이것을 당연히 손으로 해야 하는 일이라 믿고 있었다. 자동화가 된다는 상상조차 못 했다. 이 부분까지 통째로 해결해줬더니, 감동을 넘어 허탈해했다.

그 허탈함은 AI가 대단해서가 아니었다. "당연히 고생해야 한다고 믿었던 수고가 사라질 수 있다"는 사실 앞에서 나온 반응이었다.

---

## 1. 전체 시스템 구조: 무엇을 만들었나

이 자동화 시스템은 크게 두 개의 레이어로 구성된다.

**첫 번째 레이어: 사전 필터링 자동화**

매일 수백 건씩 쏟아지는 항목들 중에서 실제로 확인해야 할 대상을 자동으로 추려내는 역할을 담당한다. 사람이 손으로 하나하나 복사하고, 검색하고, 체크하던 작업을 Python과 Selenium, ChromeDriver가 대신 수행한다. `naver_mail_search.py`라는 스크립트가 이 레이어를 담당하며, CLI 인수로 처리 건수와 실행 시각을 지정할 수 있다.

**두 번째 레이어: 동시 클릭 매크로**

필터링이 완료된 대상들에 대해 정확히 예약된 시각에 동시에 버튼을 클릭하는 역할을 담당한다. NTP 서버와 밀리초 단위로 시간을 동기화하며, `prop_auto_check`라는 Electron 기반 데스크톱 앱이 동작 상태를 실시간으로 시각화한다.

이 두 레이어가 하나의 파이프라인처럼 연결되어, 처음부터 끝까지 사람 손이 거의 필요 없는 완전 자동화 흐름이 완성된다.

---

## 2. 사전 필터링 레이어 — Python + Selenium + ChromeDriver

### 병렬 브라우저 제어

스크립트는 실행 시 `--test 10 --at 08:37:30` 같은 인수를 받아 처리 건수(10개)와 실행 예약 시각(08:37:30)을 결정한다. ChromeDriver를 초기화한 뒤, 지정된 수만큼의 Chrome 브라우저 창을 동시에 생성한다.

생성된 창들은 모니터 해상도에 맞게 격자 형태로 자동 배치된다. 예를 들어 해상도 `2560x1410` 공간에서는 `4x3` 격자로 10개의 창을 배열하고, 각 창의 크기는 `640x470` 픽셀로 맞춰진다. 이렇게 배치하면 모든 창의 상태를 한눈에 모니터링하면서도 각 창이 독립적으로 동작하는 환경이 만들어진다.

각 창은 독립된 Chrome 프로파일 또는 별도 세션으로 운영되어, 로그인 상태나 쿠키가 서로 간섭하지 않도록 격리된다. 이는 각 창이 서로 다른 계정이나 세션을 사용해 작업할 수 있게 하기 위한 설계다.

### NTP 시간 동기화

병렬 브라우저가 준비되면 스크립트는 NTP 서버에 접속해 현재 시각을 가져온다. `pool.ntp.org`는 전 세계에 분산된 공개 NTP 서버 풀로, 누구나 무료로 사용할 수 있는 인프라다. 로컬 시스템 시계는 하루에도 수십 밀리초씩 드리프트(오차 누적)가 발생하는데, NTP로 동기화하면 이 오차를 수 밀리초 이내로 줄일 수 있다.

실제 동작 로그를 보면 다음과 같은 내용이 출력된다:

```
NTP 시간 동기화...
  NTP (pool.ntp.org): 오차 +6.3ms
현재 (NTP): 08:36:47
검색 예약: 08:37:30
08:37:30까지 대기 중...
남은 시간: 39초
```

오차 `+6.3ms`는 로컬 시계가 NTP 서버 시각보다 6.3밀리초 빠르다는 의미다. 이 오차를 인식하고 보정하여 예약 타이밍을 조정한다.

### JavaScript 타이머 주입

예약 시각 10초 전쯤, 스크립트는 각 브라우저 창에 JavaScript 타이머를 직접 주입한다. Selenium의 `execute_script()` 메서드를 사용하면 Python 코드에서 브라우저의 JavaScript 실행 컨텍스트에 코드를 직접 삽입할 수 있다. 이 타이머는 정확한 시각에 폼 제출 이벤트(Enter 키 입력 또는 클릭)를 발생시키도록 설계된다.

```
JS 타이머 주입...
창 1: 타이머 설정 완료
창 2: 타이머 설정 완료
...
창 10: 타이머 설정 완료

08:37:38.012 - 검색 실행 완료!
```

Python 스크립트를 통하는 것보다 브라우저 내부의 JavaScript 엔진이 직접 타이밍을 관리하게 하는 이유는 정밀도 때문이다. Python의 `time.sleep()`은 운영체제 스케줄러에 의존하기 때문에 수십 밀리초의 오차가 발생할 수 있다. 반면 JavaScript의 `setTimeout()`은 브라우저 엔진 수준에서 처리되어 상대적으로 더 정밀하다. Python → Selenium → JavaScript → 브라우저 DOM으로 이어지는 이 구조가 동시 클릭의 정밀도를 높이는 핵심 기법이다.

---

## 3. 동시 클릭 레이어 — Electron 대시보드

### Electron이란

Electron은 웹 기술(HTML, CSS, JavaScript)로 데스크톱 애플리케이션을 만들 수 있는 프레임워크다. VS Code, Slack, Discord, Figma가 모두 Electron으로 만들어진 대표적인 애플리케이션이다. 웹 개발자가 별도의 네이티브 앱 개발 지식 없이도 Windows, macOS, Linux에서 동작하는 데스크톱 앱을 만들 수 있다는 장점이 있다. Claude Code에게 Electron 앱을 만들어달라고 요청하면, 복잡한 셋업 없이 작동하는 코드를 바로 생성해준다.

### 대시보드 구성

`prop_auto_check` 앱의 메인 화면은 여러 구성 요소로 이루어진다.

좌측 패널에는 이번 작업의 대상 목록이 표시된다. 총 9건의 항목이 체크박스와 함께 나열되어 있으며, 각각의 항목은 이름과 함께 활성/비활성 상태를 보여준다.

상단 타이머는 이 앱의 가장 중요한 기능 중 하나다. 단순한 경과 시간이 아니라 NTP 서버와 동기화된 현재 시각을 밀리초 단위까지 표시하며, `2ms 빨라서 보정됨` 같은 형태로 오차 보정 상태를 실시간으로 피드백해준다. 이것이 있기 때문에 예약된 시각에 정확히 클릭을 실행할 수 있다.

중앙 그리드에는 각 항목의 상세 패널이 카드 형태로 표시된다. `#1`부터 `#9`까지 번호가 매겨진 각 패널에는 예약 시각, 현재 상태(대기중 / 입력완료 / 오류), 해당 항목의 화면 미리보기 등이 표시된다. 모든 패널에 '입력완료' 배지가 붙어 있다면 해당 시각에 모든 클릭이 정상 실행됐음을 의미한다.

하단의 '9건 매크로 예약' 버튼을 누르면 9개의 항목에 대해 지정된 시각에 동시 클릭이 실행되도록 예약이 잡힌다.

---

## 4. 이 자동화의 맥락 — 부동산 공고 신청 업무

`prop_auto_check`(property auto check)라는 앱 이름과 '광장동 아파트', '광장동 국동아파트' 같은 검색어, 그리고 '매크로 예약', '입력완료'라는 용어들을 종합하면 이 시스템의 용도가 드러난다.

이것은 **부동산 임대 공고 자동 확인 및 신청 시스템**이다. 공공임대주택이나 특정 아파트의 임차 신청 업무에서는 특정 시각에 일제히 신청을 접수받는 방식이 자주 사용된다. 이 경우 누가 더 정확한 시각에 버튼을 누르느냐가 결과에 영향을 미칠 수 있다. 이 시스템은 그 문제를 해결하기 위해 설계된 것이다.

전체 업무 흐름은 대략 다음과 같다:

1. 매일 아침, 당일 확인이 필요한 매물이나 공고 목록을 수집한다.
2. `naver_mail_search.py`가 각 항목에 대해 네이버 검색 및 크롤링을 수행하고 필요한 정보를 확인한다.
3. 확인된 항목들이 Electron 앱 대시보드에 자동으로 등록된다.
4. 공고 신청 시작 시각에 맞춰 '매크로 예약'을 설정한다.
5. 예약된 시각에 9개 이상의 브라우저 창에서 신청 버튼이 동시에 클릭된다.

이전에는 이 모든 과정이 수작업이었다. 항목 하나하나를 복사해서 네이버에 검색하고, 결과를 확인하고, 체크하는 반복 작업을 매일 수백 건씩 해야 했다. 신청 시각이 되면 여러 창을 열어놓고 최대한 빠르게 마우스를 클릭하려 애썼다. 이제 그것이 사라졌다.

---

## 5. 바이브코딩(Vibe Coding)이란 무엇인가

이 시스템 전체가 Claude Code와 바이브코딩으로 만들어졌다는 점이 핵심 맥락이다.

바이브코딩이라는 개념은 2025년 2월, OpenAI 출신의 AI 연구자 **Andrej Karpathy**가 처음 제안한 용어다. 그는 "코드가 존재한다는 사실조차 잊고, AI에게 완전히 흐름을 맡기는 새로운 코딩 방식"이라고 설명했다. 개발자가 세세한 구현 방법을 지시하는 대신, 원하는 것을 자연어로 설명하면 AI가 코드 전체를 생성해주는 방식이다.

예를 들어 "네이버에서 특정 키워드를 검색하는 Chrome 창 10개를 동시에 열고, NTP 서버와 동기화한 시각에 정확히 Enter를 누르는 Python 스크립트를 만들어줘"라고 Claude Code에게 요청하면, Selenium 설치, ChromeDriver 설정, NTP 클라이언트 코드, 병렬 브라우저 제어 로직을 모두 포함한 완성된 스크립트가 나온다.

Claude Code는 단순한 코드 생성 도구를 넘어선다. 터미널 명령 실행, 파일 시스템 접근, 코드 실행 및 디버깅까지 스스로 수행하는 **에이전틱(agentic) 코딩 도구**다. 개발자가 목표를 설명하면 Claude Code가 스스로 계획을 세우고, 코드를 작성하고, 실행하고, 에러를 수정하는 전 과정을 자율적으로 처리한다.

2025년 기준으로 YCombinator 최신 코호트 스타트업 중 약 25%가 코드베이스의 대부분을 AI로 생성했다는 조사 결과가 있을 만큼, 바이브코딩은 이미 실무에서 빠르게 확산 중이다.

---

## 6. 기술 스택 요약

| 구성 요소 | 역할 |
|---|---|
| Python | 전체 자동화 스크립트의 주언어 |
| Selenium + ChromeDriver | 브라우저 제어 및 병렬 인스턴스 관리 |
| NTP (pool.ntp.org) | 서버 시계와 밀리초 단위 동기화 |
| JavaScript 타이머 주입 | 브라우저 엔진 수준에서 정밀 타이밍 실행 |
| Electron | 데스크톱 GUI 대시보드 |
| Claude Code | 전체 시스템 코드 생성 (바이브코딩) |

---

## 7. 진짜 통찰: 요청 너머의 문제를 발견하는 것

글의 본질적인 메시지는 기술적 성취가 아니다.

친구의 최초 요청은 "버튼 동시 클릭이 가능하냐"였다. 이것이 표면적인 요청이다. 하지만 실제 업무를 들여다보니 그 클릭 이전에 매일 수백 건을 수작업으로 추리는 사전 작업이 있었다. 친구는 그 노가다가 자동화될 수 있다는 생각 자체를 하지 못하고 있었다. 이것이 진짜 문제였다.

AI가 코드를 써주는 시대에, 요청한 것을 만들어주는 것은 이제 누구나 할 수 있다. 그러나 **상대방이 미처 인식하지 못한 더 근본적인 문제를 발견하고, 그것까지 해결해주는 것**은 여전히 사람의 통찰이 필요한 영역이다.

이 통찰은 소프트웨어 개발뿐만 아니라 모든 지식 노동에 적용된다. AI가 점점 더 많은 실행 작업을 대신하게 될수록, "무엇을 만들어야 하는가"를 먼저 발견하는 능력의 가치는 오히려 더 높아진다. 친구의 감동과 허탈함은 자동화가 신기해서가 아니라, "내가 당연히 고생해야 한다고 믿었던 것이 사실은 고생할 필요가 없는 것이었다"는 인식의 전환에서 비롯된 것이다.

---

## 8. AI 시대의 개발자 역할 변화

과거에는 이 정도 자동화 도구를 만들려면 Selenium 문서를 읽고, Python 멀티스레딩을 공부하고, NTP 라이브러리 사용법을 익히고, Electron 앱 구조를 설계하는 데 수 주에서 수 개월이 걸렸다. 이 모든 것을 혼자 다 알고 있어야 했다.

지금은 다르다. Claude Code에게 원하는 것을 설명하면 이 모든 기술적 구현을 AI가 담당한다. 개발자의 역할은 점점 더 **문제를 발견하고, 맥락을 파악하고, 무엇을 만들어야 할지 정의하는 것**으로 이동하고 있다.

동시에, AI가 생성한 코드를 검증하고, 실제 환경에서 잘 동작하는지 확인하고, 예상치 못한 엣지 케이스를 처리하는 능력도 여전히 중요하다. AI는 훌륭한 코드를 빠르게 생성하지만, 그 코드가 실제 비즈니스 맥락에서 올바르게 작동하는지 판단하는 것은 사람의 몫이다.

결국 AI 코딩 도구가 발전할수록, 기술적 구현 능력보다는 **문제 정의 능력, 요구사항 발굴 능력, 전체 맥락을 보는 시각**이 개발자의 핵심 역량으로 부상하고 있다.

---

## 마치며

Selenium으로 10개의 브라우저를 동시에 제어하고, NTP로 밀리초를 동기화하고, JavaScript 타이머를 브라우저에 직접 주입하는 정교한 기술이 이 시스템 안에 있다. 하지만 그보다 더 중요한 것은, 그 기술이 만들어지게 된 계기 — 즉, 누군가가 친구의 업무를 들여다보고 "이것도 자동화할 수 있겠다"고 먼저 알아챈 순간 — 에 있다.

AI가 코드를 쓰는 시대에, 가장 희귀한 능력은 여전히 **문제를 먼저 보는 눈**이다.

그리고 그 눈을 가진 사람은 맥주를 원없이 얻어먹는다. 🍺

---

*작성일: 2026-02-25*
