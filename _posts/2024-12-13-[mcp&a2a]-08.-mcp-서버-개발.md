---
title: "[MCP&A2A] 08. MCP ì„œë²„ ê°œë°œ"
date: 2024-12-13 10:40:00 +0900
categories: [AI,  MCP & A2A]
mermaid: [True]
tags: [AI,  MCP,  A2A,  Guide,  MCP-A2A-Guide,  Medium,  Claude.write]
---


## Go ê¸°ë°˜ MCP ì„œë²„ êµ¬í˜„

MCP(Model Context Protocol) ì„œë²„ëŠ” AI ëª¨ë¸ì´ ë„êµ¬(Tools)ì™€ ë°ì´í„°(Resources)ì— ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” í•µì‹¬ ì¸í”„ë¼ì…ë‹ˆë‹¤. ì´ ì¥ì—ì„œëŠ” í”„ë¡œë•ì…˜ê¸‰ Go MCP ì„œë²„ë¥¼ ì²˜ìŒë¶€í„° êµ¬ì¶•í•˜ëŠ” ë°©ë²•ì„ ë‹¤ë£¹ë‹ˆë‹¤.

### ì™œ Goì¸ê°€?

```
Go ì„ íƒ ì´ìœ :
â”œâ”€â”€ ì„±ëŠ¥: 5,000+ req/sec ì²˜ë¦¬ ê°€ëŠ¥
â”œâ”€â”€ ë™ì‹œì„±: Goroutinesìœ¼ë¡œ ê°„ë‹¨í•œ ë³‘ë ¬ ì²˜ë¦¬
â”œâ”€â”€ íƒ€ì… ì•ˆì •ì„±: ì»´íŒŒì¼ íƒ€ì„ ì—ëŸ¬ ê²€ì¶œ
â”œâ”€â”€ ë‹¨ì¼ ë°”ì´ë„ˆë¦¬: ë°°í¬ ê°„ì†Œí™”
â”œâ”€â”€ í’ë¶€í•œ ìƒíƒœê³„: HTTP, DB, JSON ë¼ì´ë¸ŒëŸ¬ë¦¬
â””â”€â”€ ë©”ëª¨ë¦¬ íš¨ìœ¨: ë‚®ì€ ë©”ëª¨ë¦¬ í’‹í”„ë¦°íŠ¸
```

### ëŒ€ì•ˆê³¼ ë¹„êµ

| ì–¸ì–´ | ì„±ëŠ¥ | ê°œë°œ ì†ë„ | ìƒíƒœê³„ | íƒ€ì… ì•ˆì „ | ì í•©ì„± |
|------|------|----------|--------|----------|--------|
| **Go** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | âœ… ìµœì  |
| Python | â­â­ | â­â­â­â­â­ | â­â­â­â­â­ | â­â­ | âš ï¸ AI ë¡œì§ìš© |
| TypeScript | â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | âš ï¸ Node.js |
| Rust | â­â­â­â­â­ | â­â­ | â­â­â­ | â­â­â­â­â­ | âš ï¸ ëŸ¬ë‹ì»¤ë¸Œ |

## í”„ë¡œì íŠ¸ êµ¬ì¡°

### ë””ë ‰í† ë¦¬ ë ˆì´ì•„ì›ƒ

```
mcp-server/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go                 # ì§„ì…ì 
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ jwt.go                  # JWT ê²€ì¦
â”‚   â”‚   â””â”€â”€ jwt_test.go
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go               # ì„¤ì • ê´€ë¦¬
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ postgres.go             # DB ì—°ê²° í’€
â”‚   â”‚   â”œâ”€â”€ documents.go            # ë¬¸ì„œ CRUD
â”‚   â”‚   â””â”€â”€ search.go               # í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ mcp.go                  # MCP í•¸ë“¤ëŸ¬
â”‚   â”‚   â”œâ”€â”€ initialize.go           # ì´ˆê¸°í™”
â”‚   â”‚   â”œâ”€â”€ tools.go                # ë„êµ¬ ëª©ë¡/í˜¸ì¶œ
â”‚   â”‚   â””â”€â”€ resources.go            # ë¦¬ì†ŒìŠ¤ ì²˜ë¦¬
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.go                 # ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â”œâ”€â”€ ratelimit.go            # Rate limiting
â”‚   â”‚   â”œâ”€â”€ logger.go               # ë¡œê¹…
â”‚   â”‚   â””â”€â”€ recovery.go             # Panic ë³µêµ¬
â”‚   â”œâ”€â”€ protocol/
â”‚   â”‚   â”œâ”€â”€ types.go                # MCP íƒ€ì… ì •ì˜
â”‚   â”‚   â”œâ”€â”€ request.go              # ìš”ì²­ êµ¬ì¡°
â”‚   â”‚   â”œâ”€â”€ response.go             # ì‘ë‹µ êµ¬ì¡°
â”‚   â”‚   â””â”€â”€ errors.go               # ì—ëŸ¬ ì½”ë“œ
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ tool.go                 # Tool ì¸í„°í˜ì´ìŠ¤
â”‚       â”œâ”€â”€ hybrid_search.go        # í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ë„êµ¬
â”‚       â”œâ”€â”€ get_document.go         # ë¬¸ì„œ ì¡°íšŒ ë„êµ¬
â”‚       â””â”€â”€ list_documents.go       # ë¬¸ì„œ ëª©ë¡ ë„êµ¬
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ logging/
â”‚       â””â”€â”€ logger.go               # êµ¬ì¡°í™”ëœ ë¡œê±°
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ config.yaml                 # ê¸°ë³¸ ì„¤ì •
â”‚   â””â”€â”€ config.prod.yaml            # í”„ë¡œë•ì…˜ ì„¤ì •
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ migrate.sh                  # DB ë§ˆì´ê·¸ë ˆì´ì…˜
â”‚   â””â”€â”€ build.sh                    # ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â”œâ”€â”€ Dockerfile
â””â”€â”€ README.md
```

## í•µì‹¬ ì»´í¬ë„ŒíŠ¸

### 1. MCP í”„ë¡œí† ì½œ íƒ€ì… ì •ì˜

```go
// internal/protocol/types.go
package protocol

import "encoding/json"

// JSON-RPC 2.0 ìš”ì²­
type Request struct {
    JSONRPC string          `json:"jsonrpc"`
    ID      interface{}     `json:"id"`      // string ë˜ëŠ” number
    Method  string          `json:"method"`
    Params  json.RawMessage `json:"params,omitempty"`
}

// JSON-RPC 2.0 ì‘ë‹µ
type Response struct {
    JSONRPC string      `json:"jsonrpc"`
    ID      interface{} `json:"id"`
    Result  interface{} `json:"result,omitempty"`
    Error   *Error      `json:"error,omitempty"`
}

// JSON-RPC 2.0 ì—ëŸ¬
type Error struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}

// í‘œì¤€ ì—ëŸ¬ ì½”ë“œ
const (
    ParseError     = -32700  // JSON íŒŒì‹± ì‹¤íŒ¨
    InvalidRequest = -32600  // ì˜ëª»ëœ ìš”ì²­
    MethodNotFound = -32601  // ë©”ì„œë“œ ì—†ìŒ
    InvalidParams  = -32602  // ì˜ëª»ëœ íŒŒë¼ë¯¸í„°
    InternalError  = -32603  // ë‚´ë¶€ ì—ëŸ¬
)

// MCP ì»¤ìŠ¤í…€ ì—ëŸ¬ ì½”ë“œ
const (
    AuthRequired      = -32001  // ì¸ì¦ í•„ìš”
    AuthorizationFail = -32002  // ê¶Œí•œ ì—†ìŒ
    RateLimitExceeded = -32003  // Rate limit ì´ˆê³¼
    ResourceNotFound  = -32004  // ë¦¬ì†ŒìŠ¤ ì—†ìŒ
    ValidationError   = -32005  // ê²€ì¦ ì‹¤íŒ¨
)

// ì´ˆê¸°í™” ìš”ì²­
type InitializeParams struct {
    ProtocolVersion string                 `json:"protocolVersion"`
    Capabilities    ClientCapabilities     `json:"capabilities"`
    ClientInfo      ClientInfo             `json:"clientInfo"`
}

type ClientCapabilities struct {
    Experimental map[string]interface{} `json:"experimental,omitempty"`
    Sampling     map[string]interface{} `json:"sampling,omitempty"`
}

type ClientInfo struct {
    Name    string `json:"name"`
    Version string `json:"version"`
}

// ì´ˆê¸°í™” ì‘ë‹µ
type InitializeResult struct {
    ProtocolVersion string             `json:"protocolVersion"`
    Capabilities    ServerCapabilities `json:"capabilities"`
    ServerInfo      ServerInfo         `json:"serverInfo"`
}

type ServerCapabilities struct {
    Tools     *ToolsCapability     `json:"tools,omitempty"`
    Resources *ResourcesCapability `json:"resources,omitempty"`
    Prompts   *PromptsCapability   `json:"prompts,omitempty"`
    Logging   map[string]interface{} `json:"logging,omitempty"`
}

type ToolsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}

type ResourcesCapability struct {
    Subscribe   bool `json:"subscribe,omitempty"`
    ListChanged bool `json:"listChanged,omitempty"`
}

type PromptsCapability struct {
    ListChanged bool `json:"listChanged,omitempty"`
}

type ServerInfo struct {
    Name    string `json:"name"`
    Version string `json:"version"`
}

// ë„êµ¬ ì •ì˜
type ToolDefinition struct {
    Name        string                 `json:"name"`
    Description string                 `json:"description"`
    InputSchema map[string]interface{} `json:"inputSchema"`
}

// ë„êµ¬ í˜¸ì¶œ íŒŒë¼ë¯¸í„°
type ToolCallParams struct {
    Name      string                 `json:"name"`
    Arguments map[string]interface{} `json:"arguments,omitempty"`
}

// ë„êµ¬ í˜¸ì¶œ ê²°ê³¼
type ToolCallResult struct {
    Content []ContentBlock `json:"content"`
    IsError bool           `json:"isError,omitempty"`
}

// ì½˜í…ì¸  ë¸”ë¡
type ContentBlock struct {
    Type     string                 `json:"type"`  // "text", "image", "resource"
    Text     string                 `json:"text,omitempty"`
    Data     string                 `json:"data,omitempty"`
    MimeType string                 `json:"mimeType,omitempty"`
    URI      string                 `json:"uri,omitempty"`
    Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// ë¦¬ì†ŒìŠ¤ ì •ì˜
type Resource struct {
    URI         string                 `json:"uri"`
    Name        string                 `json:"name"`
    Description string                 `json:"description,omitempty"`
    MimeType    string                 `json:"mimeType,omitempty"`
    Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// ë¦¬ì†ŒìŠ¤ ë‚´ìš©
type ResourceContents struct {
    URI      string         `json:"uri"`
    MimeType string         `json:"mimeType,omitempty"`
    Contents []ContentBlock `json:"contents"`
}
```

### 2. Tool ì¸í„°í˜ì´ìŠ¤

```go
// internal/tools/tool.go
package tools

import (
    "context"
    "mcp-server/internal/protocol"
)

// Tool ì¸í„°í˜ì´ìŠ¤
type Tool interface {
    // ë„êµ¬ ì •ì˜ ë°˜í™˜
    Definition() protocol.ToolDefinition
    
    // ë„êµ¬ ì‹¤í–‰
    Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error)
    
    // ì…ë ¥ ê²€ì¦ (ì„ íƒì‚¬í•­)
    Validate(args map[string]interface{}) error
}

// ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬
type Registry struct {
    tools map[string]Tool
}

func NewRegistry() *Registry {
    return &Registry{
        tools: make(map[string]Tool),
    }
}

func (r *Registry) Register(tool Tool) {
    def := tool.Definition()
    r.tools[def.Name] = tool
}

func (r *Registry) Get(name string) (Tool, bool) {
    tool, ok := r.tools[name]
    return tool, ok
}

func (r *Registry) List() []protocol.ToolDefinition {
    var definitions []protocol.ToolDefinition
    for _, tool := range r.tools {
        definitions = append(definitions, tool.Definition())
    }
    return definitions
}
```

### 3. í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ë„êµ¬ êµ¬í˜„

```go
// internal/tools/hybrid_search.go
package tools

import (
    "context"
    "fmt"
    "mcp-server/internal/database"
    "mcp-server/internal/protocol"
)

type HybridSearchTool struct {
    db *database.DB
}

func NewHybridSearchTool(db *database.DB) *HybridSearchTool {
    return &HybridSearchTool{db: db}
}

func (t *HybridSearchTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "hybrid_search",
        Description: "BM25ì™€ ë²¡í„° ìœ ì‚¬ë„ë¥¼ ê²°í•©í•œ í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "query": map[string]interface{}{
                    "type":        "string",
                    "description": "ê²€ìƒ‰ ì¿¼ë¦¬",
                },
                "limit": map[string]interface{}{
                    "type":        "integer",
                    "description": "ê²°ê³¼ ê°œìˆ˜ (ê¸°ë³¸ê°’: 10)",
                    "default":     10,
                    "minimum":     1,
                    "maximum":     100,
                },
                "bm25_weight": map[string]interface{}{
                    "type":        "number",
                    "description": "BM25 ê°€ì¤‘ì¹˜ (ê¸°ë³¸ê°’: 0.5)",
                    "default":     0.5,
                    "minimum":     0.0,
                    "maximum":     1.0,
                },
                "vector_weight": map[string]interface{}{
                    "type":        "number",
                    "description": "ë²¡í„° ê°€ì¤‘ì¹˜ (ê¸°ë³¸ê°’: 0.5)",
                    "default":     0.5,
                    "minimum":     0.0,
                    "maximum":     1.0,
                },
            },
            "required": []string{"query"},
        },
    }
}

func (t *HybridSearchTool) Validate(args map[string]interface{}) error {
    // query í•„ìˆ˜
    query, ok := args["query"].(string)
    if !ok || query == "" {
        return fmt.Errorf("queryëŠ” ë¹„ì–´ìˆì§€ ì•Šì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    }
    
    // limit ë²”ìœ„ ì²´í¬
    if limit, ok := args["limit"].(float64); ok {
        if limit < 1 || limit > 100 {
            return fmt.Errorf("limitì€ 1-100 ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤")
        }
    }
    
    // ê°€ì¤‘ì¹˜ í•© ì²´í¬
    bm25Weight := 0.5
    vectorWeight := 0.5
    
    if w, ok := args["bm25_weight"].(float64); ok {
        bm25Weight = w
    }
    if w, ok := args["vector_weight"].(float64); ok {
        vectorWeight = w
    }
    
    if bm25Weight+vectorWeight <= 0 {
        return fmt.Errorf("ê°€ì¤‘ì¹˜ í•©ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
    }
    
    return nil
}

func (t *HybridSearchTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    // ì…ë ¥ ê²€ì¦
    if err := t.Validate(args); err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ê²€ì¦ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // íŒŒë¼ë¯¸í„° ì¶”ì¶œ
    query := args["query"].(string)
    
    limit := 10
    if l, ok := args["limit"].(float64); ok {
        limit = int(l)
    }
    
    bm25Weight := 0.5
    if w, ok := args["bm25_weight"].(float64); ok {
        bm25Weight = w
    }
    
    vectorWeight := 0.5
    if w, ok := args["vector_weight"].(float64); ok {
        vectorWeight = w
    }
    
    // ì»¨í…ìŠ¤íŠ¸ì—ì„œ tenant_id ì¶”ì¶œ
    tenantID, ok := ctx.Value("tenant_id").(string)
    if !ok {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: "tenant_idë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"},
            },
        }, nil
    }
    
    // í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ì‹¤í–‰
    results, err := t.db.HybridSearch(ctx, database.SearchParams{
        TenantID:     tenantID,
        Query:        query,
        Limit:        limit,
        BM25Weight:   bm25Weight,
        VectorWeight: vectorWeight,
    })
    
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ê²€ìƒ‰ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // ê²°ê³¼ í¬ë§·íŒ…
    if len(results) == 0 {
        return protocol.ToolCallResult{
            Content: []protocol.ContentBlock{
                {Type: "text", Text: "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."},
            },
        }, nil
    }
    
    // ê²°ê³¼ë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
    var text string
    text += fmt.Sprintf("ê²€ìƒ‰ ê²°ê³¼ (%dê°œ):\n\n", len(results))
    
    for i, result := range results {
        text += fmt.Sprintf("%d. %s (ì ìˆ˜: %.4f)\n", i+1, result.Title, result.Score)
        text += fmt.Sprintf("   ë‚´ìš©: %s\n\n", truncate(result.Content, 200))
    }
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: text,
                Metadata: map[string]interface{}{
                    "results_count": len(results),
                    "query":         query,
                },
            },
        },
    }, nil
}

func truncate(s string, maxLen int) string {
    if len(s) <= maxLen {
        return s
    }
    return s[:maxLen] + "..."
}
```

### 4. ë¬¸ì„œ ì¡°íšŒ ë„êµ¬

```go
// internal/tools/get_document.go
package tools

import (
    "context"
    "fmt"
    "mcp-server/internal/database"
    "mcp-server/internal/protocol"
)

type GetDocumentTool struct {
    db *database.DB
}

func NewGetDocumentTool(db *database.DB) *GetDocumentTool {
    return &GetDocumentTool{db: db}
}

func (t *GetDocumentTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "get_document",
        Description: "IDë¡œ íŠ¹ì • ë¬¸ì„œ ì¡°íšŒ",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "document_id": map[string]interface{}{
                    "type":        "string",
                    "description": "ë¬¸ì„œ UUID",
                    "format":      "uuid",
                },
            },
            "required": []string{"document_id"},
        },
    }
}

func (t *GetDocumentTool) Validate(args map[string]interface{}) error {
    docID, ok := args["document_id"].(string)
    if !ok || docID == "" {
        return fmt.Errorf("document_idëŠ” ë¹„ì–´ìˆì§€ ì•Šì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    }
    return nil
}

func (t *GetDocumentTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    if err := t.Validate(args); err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ê²€ì¦ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    docID := args["document_id"].(string)
    tenantID := ctx.Value("tenant_id").(string)
    
    // ë¬¸ì„œ ì¡°íšŒ
    doc, err := t.db.GetDocument(ctx, tenantID, docID)
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ë¬¸ì„œ ì¡°íšŒ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // ê²°ê³¼ ë°˜í™˜
    text := fmt.Sprintf("ì œëª©: %s\n\n%s", doc.Title, doc.Content)
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: text,
                Metadata: map[string]interface{}{
                    "document_id": doc.ID,
                    "source":      doc.Source,
                    "created_at":  doc.CreatedAt,
                },
            },
        },
    }, nil
}
```

### 5. MCP í•¸ë“¤ëŸ¬

```go
// internal/handlers/mcp.go
package handlers

import (
    "context"
    "encoding/json"
    "log"
    "net/http"
    
    "mcp-server/internal/protocol"
    "mcp-server/internal/tools"
)

type MCPHandler struct {
    toolRegistry *tools.Registry
    serverInfo   protocol.ServerInfo
}

func NewMCPHandler(toolRegistry *tools.Registry) *MCPHandler {
    return &MCPHandler{
        toolRegistry: toolRegistry,
        serverInfo: protocol.ServerInfo{
            Name:    "MCP Server",
            Version: "1.0.0",
        },
    }
}

func (h *MCPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Content-Type ì²´í¬
    if r.Header.Get("Content-Type") != "application/json" {
        h.respondError(w, nil, protocol.InvalidRequest, "Content-Type must be application/json")
        return
    }
    
    // ìš”ì²­ íŒŒì‹±
    var req protocol.Request
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.respondError(w, nil, protocol.ParseError, "Invalid JSON")
        return
    }
    
    // JSON-RPC ë²„ì „ ì²´í¬
    if req.JSONRPC != "2.0" {
        h.respondError(w, req.ID, protocol.InvalidRequest, "jsonrpc must be 2.0")
        return
    }
    
    // ë©”ì„œë“œ ë¼ìš°íŒ…
    switch req.Method {
    case "initialize":
        h.handleInitialize(w, &req)
    case "tools/list":
        h.handleToolsList(w, &req)
    case "tools/call":
        h.handleToolsCall(w, r, &req)
    case "resources/list":
        h.handleResourcesList(w, &req)
    case "resources/read":
        h.handleResourcesRead(w, &req)
    default:
        h.respondError(w, req.ID, protocol.MethodNotFound, 
            fmt.Sprintf("Method not found: %s", req.Method))
    }
}

func (h *MCPHandler) handleInitialize(w http.ResponseWriter, req *protocol.Request) {
    var params protocol.InitializeParams
    if err := json.Unmarshal(req.Params, &params); err != nil {
        h.respondError(w, req.ID, protocol.InvalidParams, "Invalid params")
        return
    }
    
    result := protocol.InitializeResult{
        ProtocolVersion: "2024-11-05",
        Capabilities: protocol.ServerCapabilities{
            Tools: &protocol.ToolsCapability{
                ListChanged: false,
            },
            Resources: &protocol.ResourcesCapability{
                Subscribe:   false,
                ListChanged: false,
            },
        },
        ServerInfo: h.serverInfo,
    }
    
    h.respondSuccess(w, req.ID, result)
}

func (h *MCPHandler) handleToolsList(w http.ResponseWriter, req *protocol.Request) {
    tools := h.toolRegistry.List()
    
    result := map[string]interface{}{
        "tools": tools,
    }
    
    h.respondSuccess(w, req.ID, result)
}

func (h *MCPHandler) handleToolsCall(w http.ResponseWriter, r *http.Request, req *protocol.Request) {
    var params protocol.ToolCallParams
    if err := json.Unmarshal(req.Params, &params); err != nil {
        h.respondError(w, req.ID, protocol.InvalidParams, "Invalid params")
        return
    }
    
    // ë„êµ¬ ì°¾ê¸°
    tool, ok := h.toolRegistry.Get(params.Name)
    if !ok {
        h.respondError(w, req.ID, protocol.ResourceNotFound, 
            fmt.Sprintf("Tool not found: %s", params.Name))
        return
    }
    
    // ë„êµ¬ ì‹¤í–‰
    result, err := tool.Execute(r.Context(), params.Arguments)
    if err != nil {
        h.respondError(w, req.ID, protocol.InternalError, err.Error())
        return
    }
    
    h.respondSuccess(w, req.ID, result)
}

func (h *MCPHandler) handleResourcesList(w http.ResponseWriter, req *protocol.Request) {
    // ë¦¬ì†ŒìŠ¤ ëª©ë¡ ë°˜í™˜ (êµ¬í˜„ ì˜ˆì •)
    result := map[string]interface{}{
        "resources": []protocol.Resource{},
    }
    
    h.respondSuccess(w, req.ID, result)
}

func (h *MCPHandler) handleResourcesRead(w http.ResponseWriter, req *protocol.Request) {
    // ë¦¬ì†ŒìŠ¤ ì½ê¸° (êµ¬í˜„ ì˜ˆì •)
    h.respondError(w, req.ID, protocol.MethodNotFound, "Not implemented")
}

func (h *MCPHandler) respondSuccess(w http.ResponseWriter, id interface{}, result interface{}) {
    resp := protocol.Response{
        JSONRPC: "2.0",
        ID:      id,
        Result:  result,
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(resp)
}

func (h *MCPHandler) respondError(w http.ResponseWriter, id interface{}, code int, message string) {
    resp := protocol.Response{
        JSONRPC: "2.0",
        ID:      id,
        Error: &protocol.Error{
            Code:    code,
            Message: message,
        },
    }
    
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)  // JSON-RPCëŠ” í•­ìƒ 200 OK
    json.NewEncoder(w).Encode(resp)
}
```

### 6. ì¸ì¦ ë¯¸ë“¤ì›¨ì–´

```go
// internal/middleware/auth.go
package middleware

import (
    "context"
    "net/http"
    "strings"
    
    "mcp-server/internal/auth"
)

func AuthMiddleware(validator *auth.JWTValidator) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Authorization í—¤ë” ì¶”ì¶œ
            authHeader := r.Header.Get("Authorization")
            if authHeader == "" {
                http.Error(w, `{"error": "Missing authorization"}`, http.StatusUnauthorized)
                return
            }
            
            // Bearer í† í° íŒŒì‹±
            parts := strings.Split(authHeader, " ")
            if len(parts) != 2 || parts[0] != "Bearer" {
                http.Error(w, `{"error": "Invalid authorization format"}`, http.StatusUnauthorized)
                return
            }
            
            tokenString := parts[1]
            
            // í† í° ê²€ì¦
            claims, err := validator.ValidateToken(tokenString)
            if err != nil {
                http.Error(w, `{"error": "Invalid token"}`, http.StatusUnauthorized)
                return
            }
            
            // ì»¨í…ìŠ¤íŠ¸ì— í´ë ˆì„ ì¶”ê°€
            ctx := r.Context()
            ctx = context.WithValue(ctx, "tenant_id", claims.TenantID)
            ctx = context.WithValue(ctx, "user_id", claims.UserID)
            ctx = context.WithValue(ctx, "roles", claims.Roles)
            
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

### 7. Rate Limiting ë¯¸ë“¤ì›¨ì–´

```go
// internal/middleware/ratelimit.go
package middleware

import (
    "net/http"
    "sync"
    "time"
    
    "golang.org/x/time/rate"
)

type RateLimiter struct {
    limiters map[string]*rate.Limiter
    mu       sync.RWMutex
    rate     rate.Limit
    burst    int
}

func NewRateLimiter(reqPerSec int, burst int) *RateLimiter {
    return &RateLimiter{
        limiters: make(map[string]*rate.Limiter),
        rate:     rate.Limit(reqPerSec),
        burst:    burst,
    }
}

func (rl *RateLimiter) getLimiter(key string) *rate.Limiter {
    rl.mu.RLock()
    limiter, exists := rl.limiters[key]
    rl.mu.RUnlock()
    
    if !exists {
        rl.mu.Lock()
        limiter = rate.NewLimiter(rl.rate, rl.burst)
        rl.limiters[key] = limiter
        rl.mu.Unlock()
    }
    
    return limiter
}

func RateLimitMiddleware(limiter *RateLimiter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // í…Œë„ŒíŠ¸ë³„ rate limiting
            tenantID, ok := r.Context().Value("tenant_id").(string)
            if !ok {
                tenantID = "anonymous"
            }
            
            if !limiter.getLimiter(tenantID).Allow() {
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusTooManyRequests)
                w.Write([]byte(`{
                    "jsonrpc": "2.0",
                    "error": {
                        "code": -32003,
                        "message": "Rate limit exceeded"
                    }
                }`))
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

### 8. ë¡œê¹… ë¯¸ë“¤ì›¨ì–´

```go
// internal/middleware/logger.go
package middleware

import (
    "log"
    "net/http"
    "time"
)

type responseWriter struct {
    http.ResponseWriter
    statusCode int
    bytes      int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
    n, err := rw.ResponseWriter.Write(b)
    rw.bytes += n
    return n, err
}

func LoggerMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        rw := &responseWriter{
            ResponseWriter: w,
            statusCode:     http.StatusOK,
        }
        
        next.ServeHTTP(rw, r)
        
        duration := time.Since(start)
        
        log.Printf(
            "%s %s %d %d bytes %v",
            r.Method,
            r.URL.Path,
            rw.statusCode,
            rw.bytes,
            duration,
        )
    })
}
```

### 9. main.go - ì „ì²´ ì¡°í•©

```go
// cmd/server/main.go
package main

import (
    "log"
    "net/http"
    "os"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    
    "mcp-server/internal/auth"
    "mcp-server/internal/database"
    "mcp-server/internal/handlers"
    custommw "mcp-server/internal/middleware"
    "mcp-server/internal/tools"
)

func main() {
    // í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
    dbURL := os.Getenv("DATABASE_URL")
    if dbURL == "" {
        log.Fatal("DATABASE_URL is required")
    }
    
    jwtPublicKeyPath := os.Getenv("JWT_PUBLIC_KEY_PATH")
    if jwtPublicKeyPath == "" {
        log.Fatal("JWT_PUBLIC_KEY_PATH is required")
    }
    
    port := os.Getenv("PORT")
    if port == "" {
        port = "8080"
    }
    
    // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
    db, err := database.New(dbURL)
    if err != nil {
        log.Fatalf("Failed to connect to database: %v", err)
    }
    defer db.Close()
    
    log.Println("âœ… Database connected")
    
    // JWT ê²€ì¦ê¸° ì´ˆê¸°í™”
    jwtValidator, err := auth.NewJWTValidator(jwtPublicKeyPath)
    if err != nil {
        log.Fatalf("Failed to create JWT validator: %v", err)
    }
    
    log.Println("âœ… JWT validator initialized")
    
    // ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒì„±
    toolRegistry := tools.NewRegistry()
    
    // ë„êµ¬ ë“±ë¡
    toolRegistry.Register(tools.NewHybridSearchTool(db))
    toolRegistry.Register(tools.NewGetDocumentTool(db))
    toolRegistry.Register(tools.NewListDocumentsTool(db))
    
    log.Printf("âœ… Registered %d tools", len(toolRegistry.List()))
    
    // Rate limiter ìƒì„± (100 req/sec, burst 200)
    rateLimiter := custommw.NewRateLimiter(100, 200)
    
    // ë¼ìš°í„° ì„¤ì •
    r := chi.NewRouter()
    
    // ë¯¸ë“¤ì›¨ì–´ ì²´ì¸
    r.Use(middleware.RequestID)
    r.Use(middleware.RealIP)
    r.Use(custommw.LoggerMiddleware)
    r.Use(middleware.Recoverer)
    r.Use(custommw.AuthMiddleware(jwtValidator))
    r.Use(custommw.RateLimitMiddleware(rateLimiter))
    
    // í•¸ë“¤ëŸ¬ ë“±ë¡
    mcpHandler := handlers.NewMCPHandler(toolRegistry)
    r.Post("/mcp", mcpHandler.ServeHTTP)
    
    // í—¬ìŠ¤ ì²´í¬ (ì¸ì¦ ë¶ˆí•„ìš”)
    r.Group(func(r chi.Router) {
        r.Get("/health", func(w http.ResponseWriter, r *http.Request) {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte(`{"status":"ok"}`))
        })
    })
    
    // ì„œë²„ ì‹œì‘
    addr := ":" + port
    log.Printf("ğŸš€ MCP Server listening on %s", addr)
    
    if err := http.ListenAndServe(addr, r); err != nil {
        log.Fatalf("Server failed: %v", err)
    }
}
```

## ë¹Œë“œ ë° ì‹¤í–‰

### go.mod

```go
module mcp-server

go 1.22

require (
    github.com/go-chi/chi/v5 v5.0.11
    github.com/golang-jwt/jwt/v5 v5.2.0
    github.com/google/uuid v1.5.0
    github.com/jackc/pgx/v5 v5.5.1
    github.com/pgvector/pgvector-go v0.1.1
    golang.org/x/time v0.5.0
)
```

### ë¹Œë“œ

```bash
# ê°œë°œ ë¹Œë“œ
go build -o bin/mcp-server cmd/server/main.go

# í”„ë¡œë•ì…˜ ë¹Œë“œ (ìµœì í™”)
CGO_ENABLED=0 GOOS=linux go build \
    -ldflags="-s -w" \
    -o bin/mcp-server \
    cmd/server/main.go

# ì‹¤í–‰
./bin/mcp-server
```

### Docker

```dockerfile
# Dockerfile
FROM golang:1.22-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build \
    -ldflags="-s -w" \
    -o mcp-server \
    cmd/server/main.go

FROM alpine:3.19

RUN apk --no-cache add ca-certificates

WORKDIR /app

COPY --from=builder /app/mcp-server .
COPY configs/ ./configs/

EXPOSE 8080

CMD ["./mcp-server"]
```

```bash
# ë¹Œë“œ
docker build -t mcp-server:latest .

# ì‹¤í–‰
docker run -d \
    -p 8080:8080 \
    -e DATABASE_URL="postgres://..." \
    -e JWT_PUBLIC_KEY_PATH="/app/certs/public_key.pem" \
    -v $(pwd)/certs:/app/certs \
    mcp-server:latest
```

## í…ŒìŠ¤íŠ¸

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```go
// internal/tools/hybrid_search_test.go
package tools

import (
    "context"
    "testing"
)

func TestHybridSearchTool_Validate(t *testing.T) {
    tool := &HybridSearchTool{}
    
    tests := []struct {
        name    string
        args    map[string]interface{}
        wantErr bool
    }{
        {
            name: "valid args",
            args: map[string]interface{}{
                "query": "test query",
                "limit": float64(10),
            },
            wantErr: false,
        },
        {
            name: "missing query",
            args: map[string]interface{}{
                "limit": float64(10),
            },
            wantErr: true,
        },
        {
            name: "invalid limit",
            args: map[string]interface{}{
                "query": "test",
                "limit": float64(200),
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tool.Validate(tt.args)
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### í†µí•© í…ŒìŠ¤íŠ¸

```go
// cmd/server/integration_test.go
package main

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
)

func TestMCPServer_Initialize(t *testing.T) {
    // í…ŒìŠ¤íŠ¸ ì„œë²„ ì„¤ì •
    // ...
    
    reqBody := map[string]interface{}{
        "jsonrpc": "2.0",
        "id":      1,
        "method":  "initialize",
        "params": map[string]interface{}{
            "protocolVersion": "2024-11-05",
            "capabilities":    map[string]interface{}{},
            "clientInfo": map[string]interface{}{
                "name":    "test-client",
                "version": "1.0.0",
            },
        },
    }
    
    body, _ := json.Marshal(reqBody)
    req := httptest.NewRequest("POST", "/mcp", bytes.NewBuffer(body))
    req.Header.Set("Content-Type", "application/json")
    
    w := httptest.NewRecorder()
    handler.ServeHTTP(w, req)
    
    if w.Code != http.StatusOK {
        t.Errorf("Expected status 200, got %d", w.Code)
    }
    
    var resp map[string]interface{}
    json.NewDecoder(w.Body).Decode(&resp)
    
    if resp["jsonrpc"] != "2.0" {
        t.Error("Invalid JSON-RPC version")
    }
}
```

## í•µì‹¬ ìš”ì•½

### êµ¬ì¡°

- âœ… **ê³„ì¸µí™”**: protocol â†’ tools â†’ handlers â†’ main
- âœ… **ì˜ì¡´ì„± ì£¼ì…**: í…ŒìŠ¤íŠ¸ ìš©ì´
- âœ… **ì¸í„°í˜ì´ìŠ¤**: Tool í™•ì¥ ê°€ëŠ¥

### ì„±ëŠ¥

- âœ… **ë™ì‹œì„±**: Goroutinesìœ¼ë¡œ ë³‘ë ¬ ì²˜ë¦¬
- âœ… **ì—°ê²° í’€**: ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”
- âœ… **Rate limiting**: í…Œë„ŒíŠ¸ë³„ ì œí•œ

### ë³´ì•ˆ

- âœ… **JWT ê²€ì¦**: RS256 ë¹„ëŒ€ì¹­ ì•”í˜¸í™”
- âœ… **ì»¨í…ìŠ¤íŠ¸ ì „íŒŒ**: tenant_id ê²©ë¦¬
- âœ… **ì…ë ¥ ê²€ì¦**: ëª¨ë“  íŒŒë¼ë¯¸í„° ì²´í¬


**ì‘ì„±ì¼**: 2024-12-13
