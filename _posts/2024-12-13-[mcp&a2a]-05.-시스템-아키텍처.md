---
title: "[MCP&A2A] 05. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜"
date: 2024-12-13 11:10:00 +0900
categories: [AI,  MCP & A2A]
mermaid: [True]
tags: [AI,  MCP,  A2A,  Guide,  MCP-A2A-Guide,  Medium,  Claude.write]
---


## ì „ì²´ ì‹œìŠ¤í…œ ê°œìš”

MCPì™€ A2Aë¥¼ ê²°í•©í•œ í”„ë¡œë•ì…˜ê¸‰ AI ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œì˜ ì „ì²´ ì•„í‚¤í…ì²˜ë¥¼ ì‚´í´ë´…ë‹ˆë‹¤.

### ì•„í‚¤í…ì²˜ ì›ì¹™

ì„¸ ê°€ì§€ í•µì‹¬ ì›ì¹™ì´ ëª¨ë“  ì„¤ê³„ ê²°ì •ì„ ì´ë•ë‹ˆë‹¤:

```
1. ë„êµ¬ì— ë§ëŠ” ì–¸ì–´ ì„ íƒ
   - Go: ë†’ì€ ì²˜ë¦¬ëŸ‰ì˜ í”„ë¡œí† ì½œ ì„œë²„
   - Python: AI ì›Œí¬í”Œë¡œìš°

2. ë°ì´í„°ë² ì´ìŠ¤ ë ˆë²¨ ë³´ì•ˆ
   - PostgreSQL Row-Level Security (RLS)ë¡œ ë©€í‹°í…Œë„Œì‹œ ê°•ì œ
   - ì• í”Œë¦¬ì¼€ì´ì…˜ ì½”ë“œê°€ ì•„ë‹Œ DBì—ì„œ ê²©ë¦¬

3. ì™„ì „í•œ ë¬´ìƒíƒœ
   - ëª¨ë“  ì„œë¹„ìŠ¤ê°€ ìˆ˜í‰ í™•ì¥ ê°€ëŠ¥
   - ì„¸ì…˜ ì—†ìŒ, ê³µìœ  ìƒíƒœ ì—†ìŒ, ë‹¨ì¼ ì‹¤íŒ¨ ì§€ì  ì—†ìŒ
```

## ì‹œìŠ¤í…œ ì»´í¬ë„ŒíŠ¸ ë‹¤ì´ì–´ê·¸ë¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚        Streamlit UI (Python)                     â”‚  â”‚
â”‚  â”‚  â€¢ ì¸ì¦ (JWT í† í° ë°œê¸‰)                          â”‚  â”‚
â”‚  â”‚  â€¢ ë¬¸ì„œ ê²€ìƒ‰ ì¸í„°í˜ì´ìŠ¤                          â”‚  â”‚
â”‚  â”‚  â€¢ A2A íƒœìŠ¤í¬ ìƒì„± ë° ëª¨ë‹ˆí„°ë§                   â”‚  â”‚
â”‚  â”‚  â€¢ ë¹„ìš© ì¶”ì  ëŒ€ì‹œë³´ë“œ                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                            â”‚
         â”‚ HTTP + JWT                 â”‚ HTTP + SSE
         â”‚                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MCP ì„œë²„ (Go)     â”‚      â”‚   A2A ì„œë²„ (Go)     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ë„êµ¬:           â”‚ â”‚      â”‚ â”‚ íƒœìŠ¤í¬ ê´€ë¦¬     â”‚ â”‚
â”‚ â”‚ â€¢ hybrid_search â”‚ â”‚      â”‚ â”‚ â€¢ ìƒì„±          â”‚ â”‚
â”‚ â”‚ â€¢ get_document  â”‚ â”‚      â”‚ â”‚ â€¢ ì‹¤í–‰          â”‚ â”‚
â”‚ â”‚ â€¢ list_docs     â”‚ â”‚      â”‚ â”‚ â€¢ ìŠ¤íŠ¸ë¦¬ë°      â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                     â”‚      â”‚                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ ì¸ì¦/ê¶Œí•œ       â”‚ â”‚      â”‚ â”‚ SSE ì´ë²¤íŠ¸      â”‚ â”‚
â”‚ â”‚ â€¢ JWT ê²€ì¦      â”‚ â”‚      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”‚ â€¢ RLS ì»¨í…ìŠ¤íŠ¸  â”‚ â”‚      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ MCP í˜¸ì¶œ
       â”‚ SQL + RLS                  â”‚
       â”‚                            â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚        PostgreSQL 16 + pgvector          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  documents í…Œì´ë¸”                  â”‚  â”‚
â”‚  â”‚  â€¢ id, tenant_id, title, content  â”‚  â”‚
â”‚  â”‚  â€¢ embedding (vector(1536))       â”‚  â”‚
â”‚  â”‚  â€¢ metadata (jsonb)               â”‚  â”‚
â”‚  â”‚  â€¢ RLS ì •ì±… í™œì„±í™”                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â–²
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Python AI ì›Œí¬í”Œë¡œìš°      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ LangGraph Workflows  â”‚ â”‚
â”‚  â”‚ â€¢ RAG íŒŒì´í”„ë¼ì¸     â”‚ â”‚
â”‚  â”‚ â€¢ ë¦¬ì„œì¹˜ ì›Œí¬í”Œë¡œìš°  â”‚ â”‚
â”‚  â”‚ â€¢ ë©€í‹°ìŠ¤í… ì—ì´ì „íŠ¸  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚
â”‚  MCP í´ë¼ì´ì–¸íŠ¸ë¡œ         â”‚
â”‚  ë„êµ¬ í˜¸ì¶œ                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Ollama (LLM)   â”‚
    â”‚ â€¢ llama3.2     â”‚
    â”‚ â€¢ ì„ë² ë”© ìƒì„±  â”‚
    â”‚ â€¢ ë¡œì»¬ ì¶”ë¡     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ë ˆì´ì–´ë³„ ì±…ì„

### 1. í”„ë ˆì  í…Œì´ì…˜ ë ˆì´ì–´ (Streamlit UI)

**ì±…ì„**:
- ì‚¬ìš©ì ì¸ì¦ ë° JWT í† í° ë°œê¸‰
- ê²€ìƒ‰ ì¸í„°í˜ì´ìŠ¤ ì œê³µ
- A2A íƒœìŠ¤í¬ ìƒì„± ë° ëª¨ë‹ˆí„°ë§
- ë¹„ìš© ì¶”ì  ì‹œê°í™”
- ì‹¤ì‹œê°„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ í‘œì‹œ

**ê¸°ìˆ  ìŠ¤íƒ**:
```yaml
ì–¸ì–´: Python 3.11+
í”„ë ˆì„ì›Œí¬: Streamlit 1.28+
ì¸ì¦: PyJWT, cryptography
HTTP í´ë¼ì´ì–¸íŠ¸: requests, httpx
```

**ì£¼ìš” ê¸°ëŠ¥**:
```python
# streamlit-ui/pages/1_ğŸ”_Authentication.py
def generate_jwt_token(tenant_id: str, user_id: str) -> str:
    """RSA-256ë¡œ ì„œëª…ëœ JWT í† í° ìƒì„±"""
    payload = {
        "tenant_id": tenant_id,
        "user_id": user_id,
        "iat": datetime.now(timezone.utc),
        "exp": datetime.now(timezone.utc) + timedelta(hours=1),
    }
    
    with open("/app/certs/private_key.pem", "rb") as f:
        private_key = load_pem_private_key(f.read(), password=None)
    
    return jwt.encode(payload, private_key, algorithm="RS256")

# streamlit-ui/pages/2_ğŸ”_Search.py
def search_documents(query: str, limit: int = 10):
    """MCP ì„œë²„ë¥¼ í†µí•œ í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰"""
    response = requests.post(
        f"{MCP_SERVER_URL}/mcp",
        headers={"Authorization": f"Bearer {st.session_state.token}"},
        json={
            "jsonrpc": "2.0",
            "id": 1,
            "method": "tools/call",
            "params": {
                "name": "hybrid_search",
                "arguments": {"query": query, "limit": limit}
            }
        }
    )
    return response.json()["result"]["content"][0]["text"]
```

### 2. í”„ë¡œí† ì½œ ì„œë²„ ë ˆì´ì–´ (Go)

#### MCP ì„œë²„

**ì±…ì„**:
- JSON-RPC 2.0 í”„ë¡œí† ì½œ ì²˜ë¦¬
- JWT ì¸ì¦ ë° í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
- ë„êµ¬ ì‹¤í–‰ (í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰, ë¬¸ì„œ ì¡°íšŒ)
- ë°ì´í„°ë² ì´ìŠ¤ ì•¡ì„¸ìŠ¤ (RLS ê°•ì œ)

**ë””ë ‰í† ë¦¬ êµ¬ì¡°**:
```
mcp-server/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go                 # ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â””â”€â”€ jwt.go                  # JWT ê²€ì¦
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ postgres.go             # DB ì—°ê²° í’€
â”‚   â”‚   â”œâ”€â”€ documents.go            # ë¬¸ì„œ CRUD
â”‚   â”‚   â””â”€â”€ hybrid_search.go        # í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â””â”€â”€ mcp.go                  # MCP ìš”ì²­ í•¸ë“¤ëŸ¬
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.go                 # ì¸ì¦ ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â”œâ”€â”€ logging.go              # ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â””â”€â”€ ratelimit.go            # Rate limiting
â”‚   â”œâ”€â”€ protocol/
â”‚   â”‚   â””â”€â”€ types.go                # MCP íƒ€ì… ì •ì˜
â”‚   â””â”€â”€ tools/
â”‚       â”œâ”€â”€ tool.go                 # Tool ì¸í„°í˜ì´ìŠ¤
â”‚       â”œâ”€â”€ hybrid_search.go        # ê²€ìƒ‰ ë„êµ¬
â”‚       â””â”€â”€ get_document.go         # ë¬¸ì„œ ì¡°íšŒ ë„êµ¬
â””â”€â”€ go.mod
```

**í•µì‹¬ êµ¬í˜„**:
```go
// mcp-server/internal/handlers/mcp.go
type MCPHandler struct {
    db           database.Store
    validator    *auth.JWTValidator
    toolRegistry map[string]tools.Tool
}

func (h *MCPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // 1. JWT ì¸ì¦
    claims, err := h.validator.ValidateToken(r.Header.Get("Authorization"))
    if err != nil {
        respondError(w, -32001, "Authentication required")
        return
    }
    
    // 2. ì»¨í…ìŠ¤íŠ¸ì— í…Œë„ŒíŠ¸ ì •ë³´ ì¶”ê°€
    ctx := context.WithValue(r.Context(), "tenant_id", claims.TenantID)
    ctx = context.WithValue(ctx, "user_id", claims.UserID)
    
    // 3. JSON-RPC ìš”ì²­ íŒŒì‹±
    var req protocol.Request
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        respondError(w, -32700, "Parse error")
        return
    }
    
    // 4. ë©”ì„œë“œ ë¼ìš°íŒ…
    switch req.Method {
    case "tools/call":
        h.handleToolsCall(ctx, w, &req)
    case "tools/list":
        h.handleToolsList(ctx, w, &req)
    default:
        respondError(w, -32601, "Method not found")
    }
}
```

#### A2A ì„œë²„

**ì±…ì„**:
- íƒœìŠ¤í¬ ìƒëª…ì£¼ê¸° ê´€ë¦¬
- Server-Sent Events (SSE) ìŠ¤íŠ¸ë¦¬ë°
- LangGraph ì›Œí¬í”Œë¡œìš° ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜
- ì¤‘ê°„ ê²°ê³¼(Artifact) ì €ì¥

**ë””ë ‰í† ë¦¬ êµ¬ì¡°**:
```
a2a-server/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ tasks.go                # íƒœìŠ¤í¬ CRUD
â”‚   â”‚   â””â”€â”€ events.go               # SSE ìŠ¤íŠ¸ë¦¬ë°
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ task.go                 # íƒœìŠ¤í¬ ëª¨ë¸
â”‚   â”‚   â””â”€â”€ artifact.go             # Artifact ëª¨ë¸
â”‚   â””â”€â”€ orchestrator/
â”‚       â””â”€â”€ workflow.go             # ì›Œí¬í”Œë¡œìš° ê´€ë¦¬
â””â”€â”€ go.mod
```

### 3. ë°ì´í„° ë ˆì´ì–´ (PostgreSQL + pgvector)

**ì±…ì„**:
- ë©€í‹°í…Œë„ŒíŠ¸ ë¬¸ì„œ ì €ì¥
- Row-Level Securityë¡œ ê²©ë¦¬ ê°•ì œ
- ë²¡í„° ìœ ì‚¬ë„ ê²€ìƒ‰ (pgvector)
- ì „ë¬¸ ê²€ìƒ‰ (Full-Text Search)

**ìŠ¤í‚¤ë§ˆ ì„¤ê³„**:
```sql
-- í™•ì¥ ê¸°ëŠ¥ í™œì„±í™”
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ë¬¸ì„œ í…Œì´ë¸”
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536),  -- OpenAI ada-002 ì°¨ì›
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- ì¸ë±ìŠ¤
    CONSTRAINT documents_tenant_id_check CHECK (tenant_id IS NOT NULL)
);

-- Row-Level Security í™œì„±í™”
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- RLS ì •ì±…: ì‚¬ìš©ìëŠ” ìì‹ ì˜ í…Œë„ŒíŠ¸ ë°ì´í„°ë§Œ ì ‘ê·¼
CREATE POLICY tenant_isolation ON documents
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_documents_tenant_id ON documents(tenant_id);
CREATE INDEX idx_documents_embedding ON documents 
    USING ivfflat (embedding vector_cosine_ops)
    WITH (lists = 100);  -- ë²¡í„° ê²€ìƒ‰ ìµœì í™”
CREATE INDEX idx_documents_content_fts ON documents 
    USING gin(to_tsvector('english', content));  -- ì „ë¬¸ ê²€ìƒ‰ ìµœì í™”
```

**RLS ë™ì‘ ë©”ì»¤ë‹ˆì¦˜**:
```go
// mcp-server/internal/database/postgres.go
func (db *DB) HybridSearch(ctx context.Context, tenantID string, params SearchParams) ([]Result, error) {
    // íŠ¸ëœì­ì…˜ ì‹œì‘
    tx, err := db.pool.Begin(ctx)
    if err != nil {
        return nil, err
    }
    defer tx.Rollback(ctx)
    
    // ì¤‘ìš”: í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
    // ì´í›„ ëª¨ë“  ì¿¼ë¦¬ëŠ” ìë™ìœ¼ë¡œ tenant_idë¡œ í•„í„°ë§ë¨
    _, err = tx.Exec(ctx, 
        fmt.Sprintf("SET LOCAL app.current_tenant_id = '%s'", tenantID))
    if err != nil {
        return nil, err
    }
    
    // RLS ì •ì±…ì´ ìë™ ì ìš©ë¨
    // WHERE tenant_id = current_setting('app.current_tenant_id')::uuid
    // ê°€ ëª¨ë“  ì¿¼ë¦¬ì— ìë™ ì¶”ê°€ë¨
    rows, err := tx.Query(ctx, `
        SELECT id, title, content, embedding
        FROM documents
        WHERE to_tsvector('english', content) @@ plainto_tsquery('english', $1)
        ORDER BY embedding <=> $2
        LIMIT $3
    `, params.Query, params.Embedding, params.Limit)
    
    // ê²°ê³¼ ì²˜ë¦¬...
    tx.Commit(ctx)
    return results, nil
}
```

### 4. AI ì›Œí¬í”Œë¡œìš° ë ˆì´ì–´ (Python + LangGraph)

**ì±…ì„**:
- ë©€í‹°ìŠ¤í… RAG íŒŒì´í”„ë¼ì¸
- ë³µì¡í•œ ë¦¬ì„œì¹˜ ì›Œí¬í”Œë¡œìš°
- MCP ë„êµ¬ ì¡°ìœ¨
- ì¤‘ê°„ ê²°ê³¼ ê´€ë¦¬

**ë””ë ‰í† ë¦¬ êµ¬ì¡°**:
```
orchestration/
â”œâ”€â”€ workflows/
â”‚   â”œâ”€â”€ rag_workflow.py             # RAG íŒŒì´í”„ë¼ì¸
â”‚   â”œâ”€â”€ research_workflow.py        # ë¦¬ì„œì¹˜ ì›Œí¬í”Œë¡œìš°
â”‚   â””â”€â”€ base.py                     # ê¸°ë³¸ ì›Œí¬í”Œë¡œìš° í´ë˜ìŠ¤
â”œâ”€â”€ clients/
â”‚   â”œâ”€â”€ mcp_client.py               # MCP í´ë¼ì´ì–¸íŠ¸
â”‚   â””â”€â”€ a2a_client.py               # A2A í´ë¼ì´ì–¸íŠ¸
â””â”€â”€ requirements.txt
```

**LangGraph ì›Œí¬í”Œë¡œìš° ì˜ˆì œ**:
```python
# orchestration/workflows/rag_workflow.py
from langgraph.graph import StateGraph, START, END
from typing import TypedDict

class RAGState(TypedDict):
    query: str
    documents: list
    ranked_docs: list
    answer: str
    verified: bool

class RAGWorkflow:
    def __init__(self, mcp_url: str):
        self.mcp_client = MCPClient(mcp_url)
        self.workflow = self.build_workflow()
    
    def build_workflow(self) -> StateGraph:
        workflow = StateGraph(RAGState)
        
        # ë…¸ë“œ ì •ì˜
        workflow.add_node("search", self.search_documents)
        workflow.add_node("rank", self.rank_results)
        workflow.add_node("generate", self.generate_answer)
        workflow.add_node("verify", self.verify_sources)
        
        # ì—£ì§€ ì •ì˜ (ì›Œí¬í”Œë¡œìš° ê·¸ë˜í”„)
        workflow.add_edge(START, "search")
        workflow.add_edge("search", "rank")
        workflow.add_edge("rank", "generate")
        workflow.add_edge("generate", "verify")
        workflow.add_edge("verify", END)
        
        return workflow.compile()
    
    def search_documents(self, state: RAGState) -> RAGState:
        """MCP í•˜ì´ë¸Œë¦¬ë“œ ê²€ìƒ‰ ë„êµ¬ ì‚¬ìš©"""
        results = self.mcp_client.hybrid_search(
            query=state["query"],
            limit=10,
            bm25_weight=0.5,
            vector_weight=0.5
        )
        
        state["documents"] = results
        return state
    
    def rank_results(self, state: RAGState) -> RAGState:
        """ê²°ê³¼ ë­í‚¹"""
        docs = sorted(
            state["documents"], 
            key=lambda x: x["score"], 
            reverse=True
        )[:5]
        
        state["ranked_docs"] = docs
        return state
    
    def generate_answer(self, state: RAGState) -> RAGState:
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ë‹µë³€ ìƒì„±"""
        context = "\n\n".join([
            f"Document: {doc['title']}\n{doc['content']}"
            for doc in state["ranked_docs"]
        ])
        
        prompt = f"""ë‹¤ìŒ ë¬¸ì„œë¥¼ ë°”íƒ•ìœ¼ë¡œ ì§ˆë¬¸ì— ë‹µí•˜ì„¸ìš”.

ì»¨í…ìŠ¤íŠ¸:
{context}

ì§ˆë¬¸: {state['query']}

ë‹µë³€:"""
        
        response = ollama.generate(
            model="llama3.2",
            prompt=prompt
        )
        
        state["answer"] = response["response"]
        return state
```

## ë°ì´í„° íë¦„

### 1. ê²€ìƒ‰ ìš”ì²­ í”Œë¡œìš°

```
ì‚¬ìš©ì â†’ Streamlit UI
  â†“ (JWT í† í° í¬í•¨)
MCP ì„œë²„
  â†“ (JWT ê²€ì¦)
Auth ë¯¸ë“¤ì›¨ì–´
  â†“ (í…Œë„ŒíŠ¸ ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€)
HybridSearchTool
  â†“ (ì„ë² ë”© ìƒì„±)
Ollama
  â†“ (í•˜ì´ë¸Œë¦¬ë“œ ì¿¼ë¦¬)
PostgreSQL + RLS
  â†“ (ê²°ê³¼ ë°˜í™˜)
MCP ì„œë²„
  â†“ (JSON ì‘ë‹µ)
Streamlit UI
  â†“ (ê²°ê³¼ í‘œì‹œ)
ì‚¬ìš©ì
```

### 2. A2A íƒœìŠ¤í¬ í”Œë¡œìš°

```
ì‚¬ìš©ì â†’ Streamlit UI
  â†“ (íƒœìŠ¤í¬ ìƒì„± ìš”ì²­)
A2A ì„œë²„
  â†“ (íƒœìŠ¤í¬ DB ì €ì¥)
PostgreSQL
  â†“ (ì›Œí¬í”Œë¡œìš° ì‹œì‘)
LangGraph Workflow
  â†“ (MCP ë„êµ¬ í˜¸ì¶œ)
MCP ì„œë²„
  â†“ (SSE ì´ë²¤íŠ¸ ë°œí–‰)
A2A ì„œë²„
  â†“ (ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¼)
Streamlit UI
  â†“ (ì§„í–‰ ìƒí™© í‘œì‹œ)
ì‚¬ìš©ì
```

## í™•ì¥ì„± ê³ ë ¤ì‚¬í•­

### ìˆ˜í‰ í™•ì¥

ëª¨ë“  ì»´í¬ë„ŒíŠ¸ëŠ” ìˆ˜í‰ í™•ì¥ ê°€ëŠ¥í•˜ë„ë¡ ì„¤ê³„:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë¡œë“œë°¸ëŸ°ì„œ  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚           â”‚        â”‚
â”Œâ”€â”€â–¼â”€â”€â”   â”Œâ”€â”€â”€â–¼â”€â”  â”Œâ”€â”€â–¼â”€â”€â”
â”‚MCP-1â”‚   â”‚MCP-2â”‚  â”‚MCP-3â”‚  â† ë¬´ìƒíƒœ (ì„¸ì…˜ ì—†ìŒ)
â””â”€â”€â”¬â”€â”€â”˜   â””â”€â”€â”€â”¬â”€â”˜  â””â”€â”€â”¬â”€â”€â”˜
   â”‚          â”‚       â”‚
   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ PostgreSQL â”‚
    â”‚  (Primary) â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   Replicas â”‚  â† ì½ê¸° ì „ìš©
    â”‚  (ì½ê¸°ìš©)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ìºì‹± ì „ëµ

```go
// Redisë¥¼ í†µí•œ ì¿¼ë¦¬ ê²°ê³¼ ìºì‹±
type CacheLayer struct {
    redis *redis.Client
    ttl   time.Duration
}

func (c *CacheLayer) GetOrCompute(
    key string, 
    compute func() (interface{}, error),
) (interface{}, error) {
    // ìºì‹œ í™•ì¸
    cached, err := c.redis.Get(context.Background(), key).Result()
    if err == nil {
        var result interface{}
        json.Unmarshal([]byte(cached), &result)
        return result, nil
    }
    
    // ìºì‹œ ë¯¸ìŠ¤ - ê³„ì‚°
    result, err := compute()
    if err != nil {
        return nil, err
    }
    
    // ìºì‹œ ì €ì¥
    data, _ := json.Marshal(result)
    c.redis.Set(context.Background(), key, data, c.ttl)
    
    return result, nil
}
```

## í•µì‹¬ ì„¤ê³„ ê²°ì •

### 1. Go vs Python ë¶„ë¦¬

**Goë¥¼ ì„ íƒí•œ ì´ìœ ** (í”„ë¡œí† ì½œ ì„œë²„):
- âœ… ë†’ì€ ì²˜ë¦¬ëŸ‰ (5,000+ req/sec)
- âœ… ë‚®ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (52MB ë² ì´ìŠ¤ë¼ì¸)
- âœ… ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ì•ˆì „ì„±
- âœ… ìš°ìˆ˜í•œ ë™ì‹œì„± (goroutines)
- âœ… ë¹ ë¥¸ JSON ì²˜ë¦¬

**Pythonì„ ì„ íƒí•œ ì´ìœ ** (AI ì›Œí¬í”Œë¡œìš°):
- âœ… í’ë¶€í•œ AI ìƒíƒœê³„ (LangChain, LangGraph)
- âœ… ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘
- âœ… ì„ë² ë”© ëª¨ë¸ í†µí•© ìš©ì´
- âœ… ê³¼í•™ ì»´í“¨íŒ… ë¼ì´ë¸ŒëŸ¬ë¦¬

### 2. PostgreSQL + pgvector

**ì„ íƒ ì´ìœ **:
- âœ… ACID íŠ¸ëœì­ì…˜
- âœ… Row-Level Security (RLS)
- âœ… ë²¡í„° ê²€ìƒ‰ (pgvector í™•ì¥)
- âœ… ì „ë¬¸ ê²€ìƒ‰ (Full-Text Search)
- âœ… JSON ì§€ì› (JSONB)
- âœ… ì„±ìˆ™í•œ ì—ì½”ì‹œìŠ¤í…œ

### 3. JWT ê¸°ë°˜ ì¸ì¦

**ì„ íƒ ì´ìœ **:
- âœ… ë¬´ìƒíƒœ (ìˆ˜í‰ í™•ì¥ ìš©ì´)
- âœ… í‘œì¤€í™” (RFC 7519)
- âœ… ë¹„ëŒ€ì¹­ ì•”í˜¸í™” (RS256)
- âœ… í† í° ì·¨ì†Œ ê°€ëŠ¥ (jti í´ë ˆì„)

## í•µì‹¬ ìš”ì•½

### ì•„í‚¤í…ì²˜ ê°•ì 

- âœ… **í™•ì¥ ê°€ëŠ¥**: ëª¨ë“  ë ˆì´ì–´ê°€ ìˆ˜í‰ í™•ì¥
- âœ… **ë³´ì•ˆ**: RLS + JWT ë‹¤ì¸µ ë³´ì•ˆ
- âœ… **ì„±ëŠ¥**: Go ì„œë²„ + ìºì‹±
- âœ… **ìœ ì§€ë³´ìˆ˜**: ê´€ì‹¬ì‚¬ ë¶„ë¦¬


---

**ì°¸ê³  ìë£Œ**:
- ì°¸ì¡° êµ¬í˜„: https://github.com/bhatti/mcp-a2a-go
- PostgreSQL RLS: https://www.postgresql.org/docs/current/ddl-rowsecurity.html
- pgvector: https://github.com/pgvector/pgvector

**ì‘ì„±ì¼**: 2024ë…„ 12ì›” 13ì¼
