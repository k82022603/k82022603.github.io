---
title: "[MCP&A2A] 13. ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°"
date: 2024-12-13 09:50:00 +0900
categories: [AI,  MCP & A2A]
mermaid: [True]
tags: [AI,  MCP,  A2A,  Guide,  MCP-A2A-Guide,  SSE,  Medium,  Claude.write]
---


## Server-Sent Events (SSE)

SSEëŠ” ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ë¡œ ì‹¤ì‹œê°„ ë°ì´í„°ë¥¼ í‘¸ì‹œí•˜ëŠ” ë‹¨ë°©í–¥ í†µì‹  í”„ë¡œí† ì½œì…ë‹ˆë‹¤. AI ì—ì´ì „íŠ¸ì˜ ì§„í–‰ ìƒí™©, ì¤‘ê°„ ê²°ê³¼, ìŠ¤íŠ¸ë¦¬ë° ì‘ë‹µì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ì „ë‹¬í•˜ëŠ” ë° ì´ìƒì ì…ë‹ˆë‹¤.

### SSE vs WebSocket vs Long Polling

| íŠ¹ì„± | SSE | WebSocket | Long Polling |
|------|-----|-----------|--------------|
| **ë°©í–¥ì„±** | ë‹¨ë°©í–¥ (ì„œë²„â†’í´ë¼ì´ì–¸íŠ¸) | ì–‘ë°©í–¥ | ë‹¨ë°©í–¥ |
| **í”„ë¡œí† ì½œ** | HTTP | TCP | HTTP |
| **ì¬ì—°ê²°** | âœ… ìë™ | âŒ ìˆ˜ë™ | âŒ ìˆ˜ë™ |
| **ë³µì¡ë„** | ë‚®ìŒ | ë†’ìŒ | ì¤‘ê°„ |
| **ë¸Œë¼ìš°ì € ì§€ì›** | âœ… ëŒ€ë¶€ë¶„ | âœ… ëª¨ë“  ìµœì‹  ë¸Œë¼ìš°ì € | âœ… ëª¨ë“  ë¸Œë¼ìš°ì € |
| **í”„ë¡ì‹œ í˜¸í™˜** | âœ… ì¢‹ìŒ | âš ï¸ ì„¤ì • í•„ìš” | âœ… ì¢‹ìŒ |
| **ì˜¤ë²„í—¤ë“œ** | ë‚®ìŒ | ë‚®ìŒ | ë†’ìŒ |
| **ìš©ë„** | ì§„í–‰ ìƒí™©, ì•Œë¦¼ | ì±„íŒ…, ê²Œì„ | ë ˆê±°ì‹œ |

### SSEë¥¼ ì„ íƒí•´ì•¼ í•˜ëŠ” ê²½ìš°

âœ… **SSE ì‚¬ìš©**:
- AI ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë° (í† í° ë‹¨ìœ„)
- íƒœìŠ¤í¬ ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
- ì‹¤ì‹œê°„ ì•Œë¦¼
- ì„œë²„ â†’ í´ë¼ì´ì–¸íŠ¸ë§Œ í•„ìš”
- ê°„ë‹¨í•œ êµ¬í˜„ ì›í•¨

âŒ **WebSocket ì‚¬ìš©**:
- ì‹¤ì‹œê°„ ì–‘ë°©í–¥ í†µì‹  (ì±„íŒ…)
- ë‚®ì€ ì§€ì—°ì‹œê°„ í•„ìˆ˜ (ê²Œì„)
- ë°”ì´ë„ˆë¦¬ ë°ì´í„° ì „ì†¡
- í´ë¼ì´ì–¸íŠ¸ â†’ ì„œë²„ë„ ë¹ˆë²ˆ

## SSE í”„ë¡œí† ì½œ ì´í•´

### SSE ë©”ì‹œì§€ í¬ë§·

```
event: message_type
data: {"key": "value"}
id: unique_id
retry: 3000

```

**í•„ë“œ ì„¤ëª…**:
- `event`: ì´ë²¤íŠ¸ íƒ€ì… (ì„ íƒ, ê¸°ë³¸ê°’: "message")
- `data`: í˜ì´ë¡œë“œ (ì—¬ëŸ¬ ì¤„ ê°€ëŠ¥)
- `id`: ì´ë²¤íŠ¸ ID (ì¬ì—°ê²° ì‹œ ì‚¬ìš©)
- `retry`: ì¬ì—°ê²° ëŒ€ê¸° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
- ë¹ˆ ì¤„: ë©”ì‹œì§€ ì¢…ë£Œ í‘œì‹œ

### ì—¬ëŸ¬ ì¤„ ë°ì´í„°

```
data: This is the first line
data: This is the second line
data: This is the third line

```

í´ë¼ì´ì–¸íŠ¸ëŠ” `\n`ìœ¼ë¡œ ì—°ê²°:
```
This is the first line
This is the second line
This is the third line
```

### ì¬ì—°ê²° ë©”ì»¤ë‹ˆì¦˜

```
id: 42
data: Some data

```

í´ë¼ì´ì–¸íŠ¸ê°€ ì—°ê²° ëŠê¹€:
```
GET /events HTTP/1.1
Last-Event-ID: 42
```

ì„œë²„ëŠ” ID 43ë¶€í„° ì „ì†¡ ì¬ê°œ

## Go ì„œë²„ êµ¬í˜„

### ê¸°ë³¸ SSE í•¸ë“¤ëŸ¬

```go
// internal/handlers/sse.go
package handlers

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"
)

type SSEHandler struct {
    // í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬
    clients   map[string]chan SSEMessage
    register  chan SSEClient
    unregister chan string
    
    // ì´ë²¤íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    broadcast chan SSEEvent
}

type SSEClient struct {
    ID      string
    Channel chan SSEMessage
}

type SSEMessage struct {
    Event string                 `json:"-"`
    ID    string                 `json:"-"`
    Data  map[string]interface{} `json:"data"`
    Retry int                    `json:"-"` // milliseconds
}

type SSEEvent struct {
    ClientID string
    Message  SSEMessage
}

func NewSSEHandler() *SSEHandler {
    h := &SSEHandler{
        clients:    make(map[string]chan SSEMessage),
        register:   make(chan SSEClient),
        unregister: make(chan string),
        broadcast:  make(chan SSEEvent, 100),
    }
    
    go h.run()
    
    return h
}

// run í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬ ë£¨í”„
func (h *SSEHandler) run() {
    for {
        select {
        case client := <-h.register:
            h.clients[client.ID] = client.Channel
            fmt.Printf("âœ… Client registered: %s (total: %d)\n", client.ID, len(h.clients))
            
        case clientID := <-h.unregister:
            if ch, ok := h.clients[clientID]; ok {
                close(ch)
                delete(h.clients, clientID)
                fmt.Printf("âŒ Client unregistered: %s (total: %d)\n", clientID, len(h.clients))
            }
            
        case event := <-h.broadcast:
            if ch, ok := h.clients[event.ClientID]; ok {
                select {
                case ch <- event.Message:
                default:
                    // ì±„ë„ì´ ê°€ë“ ì°¨ë©´ í´ë¼ì´ì–¸íŠ¸ ì œê±°
                    close(ch)
                    delete(h.clients, event.ClientID)
                    fmt.Printf("âš ï¸ Client removed (slow consumer): %s\n", event.ClientID)
                }
            }
        }
    }
}

// ServeHTTP SSE ìŠ¤íŠ¸ë¦¼ í•¸ë“¤ëŸ¬
func (h *SSEHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // SSE í—¤ë” ì„¤ì •
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    w.Header().Set("Access-Control-Allow-Origin", "*")
    
    // Flusher ì§€ì› í™•ì¸
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }
    
    // í´ë¼ì´ì–¸íŠ¸ ID (ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ë˜ëŠ” ìƒì„±)
    clientID := r.URL.Query().Get("client_id")
    if clientID == "" {
        clientID = fmt.Sprintf("client_%d", time.Now().UnixNano())
    }
    
    // í´ë¼ì´ì–¸íŠ¸ ì±„ë„ ìƒì„±
    messageChan := make(chan SSEMessage, 10)
    
    // í´ë¼ì´ì–¸íŠ¸ ë“±ë¡
    h.register <- SSEClient{
        ID:      clientID,
        Channel: messageChan,
    }
    
    defer func() {
        h.unregister <- clientID
    }()
    
    // ì—°ê²° í™•ì¸ ë©”ì‹œì§€
    h.sendMessage(w, flusher, SSEMessage{
        Event: "connected",
        Data: map[string]interface{}{
            "clientId": clientID,
            "message":  "Connected to SSE stream",
        },
    })
    
    // ì»¨í…ìŠ¤íŠ¸ ì™„ë£Œ ëŒ€ê¸°
    ctx := r.Context()
    
    // Heartbeat ticker (30ì´ˆë§ˆë‹¤)
    heartbeat := time.NewTicker(30 * time.Second)
    defer heartbeat.Stop()
    
    for {
        select {
        case <-ctx.Done():
            // í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì¢…ë£Œ
            return
            
        case msg := <-messageChan:
            // ë©”ì‹œì§€ ì „ì†¡
            if err := h.sendMessage(w, flusher, msg); err != nil {
                return
            }
            
        case <-heartbeat.C:
            // Heartbeat (ì—°ê²° ìœ ì§€)
            h.sendMessage(w, flusher, SSEMessage{
                Event: "heartbeat",
                Data: map[string]interface{}{
                    "timestamp": time.Now().Unix(),
                },
            })
        }
    }
}

// sendMessage SSE ë©”ì‹œì§€ ì „ì†¡
func (h *SSEHandler) sendMessage(w http.ResponseWriter, flusher http.Flusher, msg SSEMessage) error {
    // Event íƒ€ì…
    if msg.Event != "" {
        fmt.Fprintf(w, "event: %s\n", msg.Event)
    }
    
    // ID
    if msg.ID != "" {
        fmt.Fprintf(w, "id: %s\n", msg.ID)
    }
    
    // Data (JSON)
    data, err := json.Marshal(msg.Data)
    if err != nil {
        return err
    }
    fmt.Fprintf(w, "data: %s\n", data)
    
    // Retry
    if msg.Retry > 0 {
        fmt.Fprintf(w, "retry: %d\n", msg.Retry)
    }
    
    // ë©”ì‹œì§€ ì¢…ë£Œ
    fmt.Fprintf(w, "\n")
    
    // ì¦‰ì‹œ ì „ì†¡
    flusher.Flush()
    
    return nil
}

// Send í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì‹œì§€ ì „ì†¡
func (h *SSEHandler) Send(clientID string, msg SSEMessage) {
    h.broadcast <- SSEEvent{
        ClientID: clientID,
        Message:  msg,
    }
}

// Broadcast ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ì „ì†¡
func (h *SSEHandler) Broadcast(msg SSEMessage) {
    for clientID := range h.clients {
        h.Send(clientID, msg)
    }
}
```

### AI ìŠ¤íŠ¸ë¦¬ë° í†µí•©

```go
// internal/handlers/ai_stream.go
package handlers

import (
    "context"
    "fmt"
    "net/http"
    "strings"
    
    "github.com/go-chi/chi/v5"
)

type AIStreamHandler struct {
    sseHandler *SSEHandler
    llmClient  LLMClient
}

func NewAIStreamHandler(sseHandler *SSEHandler, llmClient LLMClient) *AIStreamHandler {
    return &AIStreamHandler{
        sseHandler: sseHandler,
        llmClient:  llmClient,
    }
}

// StreamCompletion AI ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë°
func (h *AIStreamHandler) StreamCompletion(w http.ResponseWriter, r *http.Request) {
    var req struct {
        Prompt   string `json:"prompt"`
        ClientID string `json:"clientId"`
    }
    
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request", http.StatusBadRequest)
        return
    }
    
    // ì¦‰ì‹œ ì‘ë‹µ (ë¹„ë™ê¸° ì²˜ë¦¬)
    w.WriteHeader(http.StatusAccepted)
    json.NewEncoder(w).Encode(map[string]string{
        "status":   "streaming",
        "clientId": req.ClientID,
    })
    
    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìŠ¤íŠ¸ë¦¬ë°
    go h.streamResponse(req.ClientID, req.Prompt)
}

func (h *AIStreamHandler) streamResponse(clientID, prompt string) {
    // ì‹œì‘ ì´ë²¤íŠ¸
    h.sseHandler.Send(clientID, SSEMessage{
        Event: "start",
        Data: map[string]interface{}{
            "message": "AI ì‘ë‹µ ìƒì„± ì‹œì‘",
        },
    })
    
    // ìŠ¤íŠ¸ë¦¬ë° ìš”ì²­
    ctx := context.Background()
    stream, err := h.llmClient.StreamCompletion(ctx, prompt)
    
    if err != nil {
        h.sseHandler.Send(clientID, SSEMessage{
            Event: "error",
            Data: map[string]interface{}{
                "message": err.Error(),
            },
        })
        return
    }
    
    // í† í° ìŠ¤íŠ¸ë¦¬ë°
    var fullResponse strings.Builder
    tokenCount := 0
    
    for token := range stream {
        tokenCount++
        fullResponse.WriteString(token)
        
        // í† í° ì´ë²¤íŠ¸
        h.sseHandler.Send(clientID, SSEMessage{
            Event: "token",
            Data: map[string]interface{}{
                "token": token,
                "count": tokenCount,
            },
        })
        
        // 10 í† í°ë§ˆë‹¤ ì§„í–‰ ìƒí™©
        if tokenCount%10 == 0 {
            h.sseHandler.Send(clientID, SSEMessage{
                Event: "progress",
                Data: map[string]interface{}{
                    "tokens": tokenCount,
                },
            })
        }
    }
    
    // ì™„ë£Œ ì´ë²¤íŠ¸
    h.sseHandler.Send(clientID, SSEMessage{
        Event: "complete",
        Data: map[string]interface{}{
            "response":    fullResponse.String(),
            "tokenCount":  tokenCount,
            "message":     "AI ì‘ë‹µ ìƒì„± ì™„ë£Œ",
        },
    })
}
```

### Task ì§„í–‰ ìƒí™© ìŠ¤íŠ¸ë¦¬ë°

```go
// internal/handlers/task_stream.go
package handlers

import (
    "context"
    "net/http"
    
    "github.com/go-chi/chi/v5"
)

type TaskStreamHandler struct {
    sseHandler *SSEHandler
    taskStore  TaskStore
}

func NewTaskStreamHandler(sseHandler *SSEHandler, taskStore TaskStore) *TaskStreamHandler {
    return &TaskStreamHandler{
        sseHandler: sseHandler,
        taskStore:  taskStore,
    }
}

// StreamTaskProgress íƒœìŠ¤í¬ ì§„í–‰ ìƒí™© ìŠ¤íŠ¸ë¦¬ë°
func (h *TaskStreamHandler) StreamTaskProgress(w http.ResponseWriter, r *http.Request) {
    taskID := chi.URLParam(r, "taskId")
    clientID := r.URL.Query().Get("client_id")
    
    // íƒœìŠ¤í¬ ì¡°íšŒ
    task, err := h.taskStore.Get(r.Context(), taskID)
    if err != nil {
        http.Error(w, "Task not found", http.StatusNotFound)
        return
    }
    
    // í˜„ì¬ ìƒíƒœ ì „ì†¡
    h.sseHandler.Send(clientID, SSEMessage{
        Event: "task_status",
        Data: map[string]interface{}{
            "taskId": task.ID,
            "status": task.Status,
            "step":   task.Progress.Current,
            "total":  task.Progress.Total,
        },
    })
    
    // ì™„ë£Œëœ íƒœìŠ¤í¬ëŠ” ì¦‰ì‹œ ì¢…ë£Œ
    if task.Status == "completed" || task.Status == "failed" {
        h.sseHandler.Send(clientID, SSEMessage{
            Event: task.Status,
            Data: map[string]interface{}{
                "taskId": task.ID,
                "result": task.Result,
            },
        })
        return
    }
    
    // íƒœìŠ¤í¬ ì™„ë£Œ ëŒ€ê¸°
    h.waitForTaskCompletion(r.Context(), clientID, taskID)
}

func (h *TaskStreamHandler) waitForTaskCompletion(ctx context.Context, clientID, taskID string) {
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
            
        case <-ticker.C:
            task, err := h.taskStore.Get(ctx, taskID)
            if err != nil {
                h.sseHandler.Send(clientID, SSEMessage{
                    Event: "error",
                    Data: map[string]interface{}{
                        "message": "Failed to get task",
                    },
                })
                return
            }
            
            // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
            if task.Progress != nil {
                h.sseHandler.Send(clientID, SSEMessage{
                    Event: "progress",
                    Data: map[string]interface{}{
                        "step":    task.Progress.Current,
                        "total":   task.Progress.Total,
                        "message": task.Progress.Message,
                    },
                })
            }
            
            // ì™„ë£Œ í™•ì¸
            if task.Status == "completed" {
                h.sseHandler.Send(clientID, SSEMessage{
                    Event: "completed",
                    Data: map[string]interface{}{
                        "taskId": task.ID,
                        "result": task.Result,
                    },
                })
                return
            }
            
            if task.Status == "failed" {
                h.sseHandler.Send(clientID, SSEMessage{
                    Event: "failed",
                    Data: map[string]interface{}{
                        "taskId": task.ID,
                        "error":  task.Error,
                    },
                })
                return
            }
        }
    }
}
```

## JavaScript í´ë¼ì´ì–¸íŠ¸

### ê¸°ë³¸ EventSource

```javascript
// client/sse-client.js

class SSEClient {
    constructor(url) {
        this.url = url;
        this.eventSource = null;
        this.listeners = new Map();
        this.clientId = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }
    
    connect() {
        // í´ë¼ì´ì–¸íŠ¸ ID ìƒì„±
        this.clientId = `client_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        const url = `${this.url}?client_id=${this.clientId}`;
        
        this.eventSource = new EventSource(url);
        
        // ì—°ê²° ì´ë²¤íŠ¸
        this.eventSource.addEventListener('connected', (event) => {
            const data = JSON.parse(event.data);
            console.log('âœ… Connected:', data);
            this.reconnectAttempts = 0;
            this.emit('connected', data);
        });
        
        // Heartbeat
        this.eventSource.addEventListener('heartbeat', (event) => {
            const data = JSON.parse(event.data);
            console.log('ğŸ’“ Heartbeat:', new Date(data.timestamp * 1000));
        });
        
        // ì—ëŸ¬ ì²˜ë¦¬
        this.eventSource.onerror = (error) => {
            console.error('âŒ SSE Error:', error);
            
            if (this.eventSource.readyState === EventSource.CLOSED) {
                this.handleReconnect();
            }
        };
        
        return this;
    }
    
    handleReconnect() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('Max reconnect attempts reached');
            this.emit('max_reconnect_reached');
            return;
        }
        
        this.reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
        
        console.log(`Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
        
        setTimeout(() => {
            this.connect();
        }, delay);
    }
    
    on(event, callback) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
            
            // EventSource ë¦¬ìŠ¤ë„ˆ ë“±ë¡
            this.eventSource.addEventListener(event, (e) => {
                const data = JSON.parse(e.data);
                this.emit(event, data);
            });
        }
        
        this.listeners.get(event).push(callback);
        return this;
    }
    
    emit(event, data) {
        const callbacks = this.listeners.get(event) || [];
        callbacks.forEach(callback => callback(data));
    }
    
    close() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
    
    getClientId() {
        return this.clientId;
    }
}

// ì‚¬ìš© ì˜ˆì œ
const client = new SSEClient('/api/sse/stream');

client
    .on('connected', (data) => {
        console.log('Connected:', data);
    })
    .on('token', (data) => {
        console.log('Token:', data.token);
        // UI ì—…ë°ì´íŠ¸
        appendToken(data.token);
    })
    .on('progress', (data) => {
        console.log('Progress:', data);
        updateProgressBar(data.step, data.total);
    })
    .on('complete', (data) => {
        console.log('Complete:', data);
        showCompleteMessage(data.response);
    })
    .on('error', (data) => {
        console.error('Error:', data);
        showError(data.message);
    })
    .connect();

// ì •ë¦¬
window.addEventListener('beforeunload', () => {
    client.close();
});
```

### React í†µí•©

```javascript
// client/hooks/useSSE.js
import { useEffect, useState, useRef } from 'react';

export function useSSE(url) {
    const [status, setStatus] = useState('disconnected');
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    const eventSourceRef = useRef(null);
    const listenersRef = useRef(new Map());
    
    useEffect(() => {
        const clientId = `client_${Date.now()}`;
        const eventSource = new EventSource(`${url}?client_id=${clientId}`);
        eventSourceRef.current = eventSource;
        
        eventSource.addEventListener('connected', (event) => {
            setStatus('connected');
            setData(JSON.parse(event.data));
        });
        
        eventSource.onerror = (event) => {
            setStatus('error');
            setError(event);
        };
        
        // ë“±ë¡ëœ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
        listenersRef.current.forEach((callback, eventType) => {
            eventSource.addEventListener(eventType, (event) => {
                callback(JSON.parse(event.data));
            });
        });
        
        return () => {
            eventSource.close();
        };
    }, [url]);
    
    const on = (eventType, callback) => {
        listenersRef.current.set(eventType, callback);
        
        if (eventSourceRef.current) {
            eventSourceRef.current.addEventListener(eventType, (event) => {
                callback(JSON.parse(event.data));
            });
        }
    };
    
    return { status, data, error, on };
}

// ì‚¬ìš© ì˜ˆì œ
function StreamingComponent() {
    const [tokens, setTokens] = useState([]);
    const [progress, setProgress] = useState({ current: 0, total: 0 });
    const { status, on } = useSSE('/api/sse/stream');
    
    useEffect(() => {
        on('token', (data) => {
            setTokens(prev => [...prev, data.token]);
        });
        
        on('progress', (data) => {
            setProgress({ current: data.step, total: data.total });
        });
        
        on('complete', (data) => {
            console.log('Complete:', data);
        });
    }, []);
    
    return (
        <div>
            <div>Status: {status}</div>
            <div>Progress: {progress.current}/{progress.total}</div>
            <div>{tokens.join('')}</div>
        </div>
    );
}
```

### Vue í†µí•©

```javascript
// client/composables/useSSE.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useSSE(url) {
    const status = ref('disconnected');
    const data = ref(null);
    const error = ref(null);
    
    let eventSource = null;
    const listeners = new Map();
    
    const connect = () => {
        const clientId = `client_${Date.now()}`;
        eventSource = new EventSource(`${url}?client_id=${clientId}`);
        
        eventSource.addEventListener('connected', (event) => {
            status.value = 'connected';
            data.value = JSON.parse(event.data);
        });
        
        eventSource.onerror = (event) => {
            status.value = 'error';
            error.value = event;
        };
        
        // ë“±ë¡ëœ ë¦¬ìŠ¤ë„ˆ ì—°ê²°
        listeners.forEach((callback, eventType) => {
            eventSource.addEventListener(eventType, (event) => {
                callback(JSON.parse(event.data));
            });
        });
    };
    
    const on = (eventType, callback) => {
        listeners.set(eventType, callback);
        
        if (eventSource) {
            eventSource.addEventListener(eventType, (event) => {
                callback(JSON.parse(event.data));
            });
        }
    };
    
    const close = () => {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
    };
    
    onMounted(() => {
        connect();
    });
    
    onUnmounted(() => {
        close();
    });
    
    return { status, data, error, on, close };
}

// ì‚¬ìš© ì˜ˆì œ
<script setup>
import { ref } from 'vue';
import { useSSE } from './composables/useSSE';

const tokens = ref([]);
const { status, on } = useSSE('/api/sse/stream');

on('token', (data) => {
    tokens.value.push(data.token);
});

on('complete', (data) => {
    console.log('Complete:', data);
});
</script>

<template>
    <div>
        <div>Status: {{ status }}</div>
        <div>{{ tokens.join('') }}</div>
    </div>
</template>
```

## í”„ë¡œë•ì…˜ ê³ ë ¤ì‚¬í•­

### 1. ì—°ê²° ì œí•œ

```go
// internal/handlers/sse_limited.go
type LimitedSSEHandler struct {
    *SSEHandler
    maxClients    int
    clientsByUser map[string][]string
    mu            sync.RWMutex
}

func (h *LimitedSSEHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    userID := r.Context().Value("user_id").(string)
    
    h.mu.Lock()
    currentClients := len(h.clientsByUser[userID])
    h.mu.Unlock()
    
    if currentClients >= 3 {
        http.Error(w, "Too many connections", http.StatusTooManyRequests)
        return
    }
    
    // ë‚˜ë¨¸ì§€ ë¡œì§
    h.SSEHandler.ServeHTTP(w, r)
}
```

### 2. íƒ€ì„ì•„ì›ƒ

```go
func (h *SSEHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // ìµœëŒ€ 1ì‹œê°„
    ctx, cancel := context.WithTimeout(r.Context(), 1*time.Hour)
    defer cancel()
    
    // ...
}
```

### 3. ë²„í¼ ê´€ë¦¬

```go
// ëŠë¦° í´ë¼ì´ì–¸íŠ¸ íƒì§€
const maxBufferSize = 100

func (h *SSEHandler) Send(clientID string, msg SSEMessage) {
    if ch, ok := h.clients[clientID]; ok {
        if len(ch) >= maxBufferSize {
            // ë²„í¼ ê°€ë“ - í´ë¼ì´ì–¸íŠ¸ ì œê±°
            close(ch)
            delete(h.clients, clientID)
            return
        }
        
        ch <- msg
    }
}
```

### 4. ë©”ëª¨ë¦¬ ê´€ë¦¬

```go
// ì •ê¸°ì  ì •ë¦¬
func (h *SSEHandler) cleanup() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        h.mu.Lock()
        for clientID, ch := range h.clients {
            select {
            case ch <- SSEMessage{Event: "ping"}:
                // ì‚´ì•„ìˆìŒ
            default:
                // ì‘ë‹µ ì—†ìŒ - ì œê±°
                close(ch)
                delete(h.clients, clientID)
            }
        }
        h.mu.Unlock()
    }
}
```

## í•µì‹¬ ìš”ì•½

### SSE ì¥ì 

- âœ… **ê°„ë‹¨í•¨**: HTTP ê¸°ë°˜, ë³µì¡í•œ í”„ë¡œí† ì½œ ë¶ˆí•„ìš”
- âœ… **ì¬ì—°ê²°**: ë¸Œë¼ìš°ì €ê°€ ìë™ ì¬ì—°ê²°
- âœ… **í˜¸í™˜ì„±**: í”„ë¡ì‹œ, ë°©í™”ë²½ ì¹œí™”ì 
- âœ… **íš¨ìœ¨ì„±**: WebSocketë³´ë‹¤ ì˜¤ë²„í—¤ë“œ ë‚®ìŒ
- âœ… **í‘œì¤€**: W3C í‘œì¤€, ë¸Œë¼ìš°ì € ë„¤ì´í‹°ë¸Œ ì§€ì›

### ì‹¤ë¬´ ì²´í¬ë¦¬ìŠ¤íŠ¸

- âœ… **í—¤ë” ì„¤ì •**: Content-Type, Cache-Control, Connection
- âœ… **Flusher**: ì¦‰ì‹œ ì „ì†¡ í™•ì¸
- âœ… **Heartbeat**: ì—°ê²° ìœ ì§€ (30ì´ˆ)
- âœ… **ì—ëŸ¬ ì²˜ë¦¬**: ì¬ì—°ê²°, ë°±ì˜¤í”„
- âœ… **ì œí•œ**: ì‚¬ìš©ìë‹¹ ìµœëŒ€ ì—°ê²° ìˆ˜
- âœ… **íƒ€ì„ì•„ì›ƒ**: ì¥ì‹œê°„ ì—°ê²° ë°©ì§€
- âœ… **ì •ë¦¬**: ëŠê¸´ ì—°ê²° ì œê±°


**ì‘ì„±ì¼**: 2024-12-13
