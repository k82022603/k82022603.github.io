---
title: "Continuous Agentic Development"
date: 2025-12-28 09:00:00 +0900
categories: [AI,  Vibe Coding,  Guide]
tags: [AI,  Developer,  vibe-coding,  Guide,  Claude.write]
---

## 소프트웨어 개발의 패러다임 전환: 20/80 비율의 혁명

---

## 들어가며: 개발자의 시간은 어디로 가는가?

당신은 오늘 얼마나 많은 시간을 실제 "코드 타이핑"에 사용했습니까? 그리고 얼마나 많은 시간을 "무엇을 만들지" 고민하는 데 사용했습니까? 전통적인 소프트웨어 개발에서 이 질문의 답은 명확했습니다. 개발자는 시간의 대부분을 코드를 작성하고, 디버깅하고, 리팩토링하고, 테스트하는 데 사용했습니다. 생각하고 설계하는 시간은 전체의 일부에 불과했습니다.

하지만 2024년 말부터 2025년 초, 이 비율이 완전히 뒤집히기 시작했습니다. 그리고 이 변화는 단순히 도구가 좋아진 것을 넘어서, 개발자라는 직업의 본질 자체를 재정의하고 있습니다.

## 전통적 개발의 시간 분배: 80/20의 법칙

### 80%: Production (생산 활동)

전통적인 소프트웨어 개발에서 개발자의 시간 중 약 80%는 다음과 같은 "생산 활동"에 사용되었습니다.

**코드 작성 (40%)**

개발자는 하루 중 가장 많은 시간을 키보드 앞에 앉아 코드를 타이핑하는 데 보냈습니다. 요구사항 문서를 보고, 설계 다이어그램을 참고하고, StackOverflow를 검색하면서 한 줄 한 줄 코드를 작성했습니다. 변수명을 고민하고, 함수를 정의하고, 클래스를 만들고, API를 호출하는 코드를 작성했습니다.

이것은 순수하게 기계적인 작업이었습니다. 뇌에서 이미 결정한 내용을 손가락을 통해 컴퓨터에 전달하는 과정이었습니다. 하지만 이 과정에서 수많은 시간이 소모되었습니다. 타이핑 속도의 한계, 문법 오류, 자동완성 기능의 부재 등이 모두 시간을 잡아먹었습니다.

**디버깅 (25%)**

코드를 작성한 후에는 디버깅이 기다리고 있었습니다. 컴파일 에러, 런타임 에러, 논리적 버그. 개발자는 콘솔 로그를 출력하고, 브레이크포인트를 설정하고, 스택 트레이스를 분석하면서 문제를 찾아냈습니다.

특히 복잡한 버그는 며칠씩 시간을 잡아먹었습니다. 재현하기 어려운 버그, 타이밍 이슈, 메모리 누수. 이런 문제들을 추적하고 해결하는 데 개발자의 귀중한 시간이 소비되었습니다.

**리팩토링 (10%)**

기능이 작동하게 만든 후에는 코드를 개선해야 했습니다. 중복 코드를 제거하고, 함수를 분리하고, 변수명을 개선하고, 디자인 패턴을 적용했습니다. 코드 리뷰에서 지적받은 사항들을 수정하고, 코딩 컨벤션에 맞추는 작업도 필요했습니다.

**테스트 작성 (5%)**

단위 테스트, 통합 테스트, E2E 테스트를 작성했습니다. 각 기능에 대해 테스트 케이스를 작성하고, 엣지 케이스를 고려하고, 모킹(mocking)을 설정했습니다. 테스트 커버리지를 높이기 위해 추가 테스트를 작성하는 시간도 필요했습니다.

### 20%: Direction (방향 설정)

나머지 20%의 시간만이 실제로 "무엇을 만들 것인가"를 결정하는 데 사용되었습니다.

**요구사항 이해 (5%)**

고객이나 프로덕트 매니저와 미팅을 하고, 요구사항 문서를 읽고, 질문하고, 불명확한 부분을 명확히 하는 시간이었습니다.

**아키텍처 설계 (10%)**

시스템을 어떻게 구조화할 것인지, 어떤 기술 스택을 사용할 것인지, 데이터베이스 스키마를 어떻게 설계할 것인지 결정했습니다. 화이트보드 앞에서 다이어그램을 그리고, 팀원들과 토론하고, 최선의 접근법을 찾아냈습니다.

**UX/UI 결정 (5%)**

사용자가 어떻게 상호작용할 것인지, 화면 흐름은 어떻게 할 것인지, 에러 메시지는 어떻게 표시할 것인지 결정했습니다.

### 문제점: 역전된 우선순위

이 80/20 분배의 문제점은 명확합니다. 개발자의 가장 귀중한 자산인 창의력과 판단력이 전체 시간의 20%에만 사용되었다는 것입니다. 나머지 80%는 기계적이고 반복적인 작업에 소모되었습니다.

더 심각한 것은, 이 80%의 생산 활동이 개발자를 지치게 만들어서 나머지 20%의 방향 설정을 제대로 하지 못하게 만들었다는 점입니다. 하루 종일 코드를 작성하고 디버깅한 개발자는 저녁에 아키텍처를 설계할 에너지가 남아있지 않았습니다.

## Continuous Agentic Development: 비율의 역전

### 새로운 패러다임의 탄생

2024년 9월, Boris Cherny가 Claude Code를 만들었을 때, 그는 단순히 새로운 개발 도구를 만든 것이 아니었습니다. 그는 소프트웨어 개발이라는 행위의 본질을 바꾸는 도구를 만든 것입니다.

Boris는 이렇게 말합니다. "이제 코드를 작성할 때, 당신은 에이전트를 사용합니다. 더 이상 IDE에서 텍스트를 직접 조작하지 않습니다. 이것은 단순한 탭 자동완성이 아닙니다. 모델이 당신을 위해 코드를 작성하는 것입니다."

Continuous Agentic Development는 이러한 새로운 현실을 설명하는 개념입니다. 개발자가 AI 에이전트와 연속적으로 협업하면서, AI가 생산 루프를 담당하고 개발자는 방향 루프를 담당하는 방식입니다.

### 20%: Production Oversight (생산 활동 감독)

Continuous Agentic Development에서 개발자는 시간의 약 20%만을 생산 활동에 사용합니다. 하지만 이것은 직접 생산하는 것이 아니라 "감독"하는 것입니다.

**AI 출력 검토 (10%)**

Claude Code나 다른 AI 코딩 도구가 생성한 코드를 검토합니다. 비즈니스 로직이 정확한지, 보안 취약점은 없는지, 성능 이슈는 없는지 확인합니다. 하지만 이것은 직접 타이핑하는 것보다 훨씬 빠릅니다. 1000줄의 코드를 작성하는 데는 몇 시간이 걸리지만, 검토하는 데는 30분이면 충분합니다.

**방향 수정 (5%)**

AI가 잘못된 방향으로 가고 있다면, 즉시 멈추고 새로운 지시를 내립니다. "이 접근법은 너무 복잡해. 더 단순한 방법으로 다시 만들어줘." "여기 보안 이슈가 있어. PreparedStatement를 사용해서 다시 구현해줘." 이런 식으로 AI를 조율합니다.

**최종 승인 및 배포 (5%)**

모든 것이 만족스러우면, Git 커밋을 승인하고, Pull Request를 병합하고, 배포 파이프라인을 실행합니다. 이것도 대부분 자동화되어 있어서 몇 번의 클릭이면 끝납니다.

### 80%: Strategic Direction (전략적 방향 설정)

나머지 80%의 시간은 전략적 방향 설정에 집중합니다. 이것이 개발자가 진정으로 가치를 창출하는 영역입니다.

**비즈니스 가치 정의 (25%)**

무엇을 만들 것인가? 왜 만드는가? 사용자에게 어떤 가치를 제공하는가? 이런 근본적인 질문에 답하는 데 시간을 씁니다. 고객과 대화하고, 시장을 조사하고, 경쟁사를 분석합니다. 

Rakuten의 Yusuke Kaji는 이렇게 말합니다. "우리는 모든 팀에 빠르게 혁신하고 고객에게 더 큰 영향을 미칠 수 있는 힘을 주고 싶습니다. 이것은 기존 작업을 자동화하는 것이 아니라, 각 팀이 달성할 수 있는 것을 곱하는 것입니다."

**시스템 아키텍처 설계 (30%)**

전체 시스템을 어떻게 구조화할 것인가? 마이크로서비스로 갈 것인가, 모놀리식으로 갈 것인가? 데이터베이스는 어떻게 설계할 것인가? API는 어떻게 구조화할 것인가? 확장성, 보안, 성능을 어떻게 보장할 것인가?

이런 고수준의 결정은 여전히 인간의 영역입니다. AI는 코드를 생성할 수 있지만, 비즈니스 맥락을 이해하고 트레이드오프를 판단하는 것은 인간만이 할 수 있습니다.

**사용자 경험 최적화 (15%)**

사용자가 시스템과 어떻게 상호작용할 것인가? 화면 흐름은 어떻게 할 것인가? 에러가 발생했을 때 어떻게 처리할 것인가? 로딩 시간을 어떻게 줄일 것인가?

**팀 협업 및 커뮤니케이션 (10%)**

팀원들과 설계를 공유하고, 피드백을 받고, 합의를 이루는 시간입니다. 코드 리뷰를 하고, 페어 프로그래밍을 하고, 기술 문서를 작성합니다.

### 핵심 변화: Editor-in-Chief

Continuous Agentic Development의 핵심은 개발자의 역할이 "코더(Coder)"에서 "편집장(Editor-in-Chief)"으로 변화한다는 것입니다.

편집장은 글을 직접 쓰지 않습니다. 대신 어떤 기사를 쓸 것인지 결정하고, 작가를 배정하고, 초고를 검토하고, 방향을 조정하고, 최종 승인을 합니다. 마찬가지로, 현대의 개발자는 코드를 직접 타이핑하지 않습니다. 대신 무엇을 만들 것인지 결정하고, AI에게 구현을 맡기고, 결과물을 검토하고, 방향을 조정하고, 최종 승인을 합니다.

## 실제 사례: Rakuten의 79% 시간 단축

### 변화 이전: 24일의 긴 여정

Rakuten은 70개 이상의 비즈니스를 운영하는 거대 기업입니다. 이커머스, 여행, 핀테크, 디지털 콘텐츠, 통신 등 다양한 영역을 아우릅니다. 이런 대규모 조직에서 새로운 기능을 출시하는 것은 복잡한 과정이었습니다.

평균적으로 새로운 기능을 시장에 내놓는 데 24일(근무일 기준)이 걸렸습니다. 거의 한 달입니다. 이 시간은 다음과 같이 분배되었습니다.

**1-3일차: 요구사항 분석 및 설계**
무엇을 만들 것인지 정의하고, 기술적 접근법을 설계했습니다.

**4-18일차: 구현**
실제 코드를 작성하는 가장 긴 단계였습니다. 여러 개발자가 협업하고, 코드 리뷰를 하고, 리팩토링을 하면서 2주 이상이 소요되었습니다.

**19-22일차: 테스트 및 버그 수정**
QA 팀이 테스트를 진행하고, 발견된 버그를 수정했습니다.

**23-24일차: 배포 준비 및 출시**
프로덕션 환경에 배포하고, 모니터링을 설정했습니다.

### Claude Code 도입 후: 5일의 스프린트

Claude Code를 도입한 후, 같은 기능을 5일 만에 출시할 수 있게 되었습니다. 79%의 시간 단축입니다.

**1일차: 전략 및 아키텍처 (전일)**
여전히 첫날은 "무엇을 만들 것인가"에 집중합니다. 하지만 이제 팀은 구현의 복잡성을 걱정하지 않고 비즈니스 가치에만 집중할 수 있습니다. Claude Code가 구현을 담당할 것이기 때문입니다.

**2-3일차: AI 기반 구현 (이틀)**
개발자는 Claude Code에게 상세한 지시를 내립니다. "이 API 엔드포인트를 만들어줘. 데이터베이스는 PostgreSQL을 사용하고, ORM은 사용하지 말고 직접 SQL을 작성해줘. 트랜잭션 처리를 확실히 해줘."

Claude Code는 몇 시간 만에 전체 백엔드를 생성합니다. 개발자는 중간중간 검토하고, 방향을 조정하고, 계속 진행하도록 승인합니다.

**4일차: 검증 및 최적화 (전일)**
생성된 코드를 철저히 검토합니다. 보안 취약점 스캔, 성능 테스트, 비즈니스 로직 검증을 수행합니다. 발견된 이슈는 Claude에게 즉시 수정하도록 지시합니다.

**5일차: 배포 (전일)**
테스트를 통과한 코드를 프로덕션에 배포합니다.

### 핵심 차이: 시간은 어디로 갔는가?

24일에서 5일로 줄어든 19일은 어디로 갔을까요? 대부분은 구현 단계에서 사라졌습니다. 코드 작성, 디버깅, 리팩토링에 들던 2주 이상의 시간이 이틀로 압축되었습니다.

Rakuten의 Manoj Desai는 이렇게 말합니다. "Claude Code가 우리에게 슈퍼파워를 주었기 때문에 시장 출시 시간이 크게 단축되었습니다. 실행을 훨씬 더 빠르게 만들 수 있게 되었습니다."

## 7시간 연속 자율 코딩: 새로운 가능성

### 불가능했던 도전

Rakuten의 머신러닝 엔지니어 Kenta Naruse는 Claude Code에게 복잡한 기술적 과제를 주었습니다. vLLM이라는 대규모 오픈소스 라이브러리(1,250만 줄의 코드, 여러 프로그래밍 언어로 작성됨)에 특정 활성화 벡터 추출 메서드를 구현하는 것이었습니다.

이것은 인간 개발자라면 최소 며칠은 걸릴 복잡한 작업이었습니다. 거대한 코드베이스를 이해하고, 적절한 위치를 찾고, 기존 코드 스타일에 맞춰 구현하고, 테스트하는 전 과정이 필요했습니다.

### 7시간의 기적

Naruse는 Claude Code를 실행하고 작업을 맡겼습니다. 그리고 7시간 동안 Claude는 연속으로 작업했습니다. 단일 세션에서, 인간의 개입 없이, 자율적으로 작업을 완료했습니다.

Naruse는 회상합니다. "나는 그 7시간 동안 단 한 줄의 코드도 작성하지 않았습니다. 가끔 가이드만 제공했을 뿐입니다."

결과는 놀라웠습니다. 구현된 코드는 참조 메서드와 비교해 99.9%의 수치적 정확도를 달성했습니다. 이것은 단순히 작동하는 것을 넘어서, 프로덕션에 바로 사용할 수 있는 품질이었습니다.

### 연속성의 힘

이 사례가 중요한 이유는 단순히 빠른 속도 때문이 아닙니다. "연속적(Continuous)"이라는 단어의 진정한 의미를 보여주기 때문입니다.

전통적인 개발에서는 개발자가 멈추면 작업도 멈춥니다. 점심시간, 미팅, 다른 긴급한 작업. 하루에 실제로 코딩에 집중할 수 있는 시간은 4-5시간에 불과합니다. 그리고 컨텍스트 스위칭 비용 때문에 효율성은 더욱 떨어집니다.

하지만 Claude Code는 멈추지 않습니다. 당신이 지시하면, Claude는 작업을 완료할 때까지 계속 진행합니다. 7시간 동안 쉬지 않고, 집중력을 잃지 않고, 일관된 품질로 작업합니다.

Rakuten의 Yusuke Kaji는 이렇게 설명합니다. "5개의 작업을 동시에 진행할 수 있습니다. 4개는 Claude Code에게 위임하고, 나머지 하나에 집중하면 됩니다." 이것이 연속적 에이전틱 개발의 진정한 힘입니다. 개발자의 역량이 곱해지는 것입니다.

## 비율 전환의 심리적 영향

### 인지 부하의 변화

전통적 개발에서 개발자는 하루 종일 높은 인지 부하 상태에 있었습니다. 코드를 작성하는 것은 집중력을 요구하는 작업입니다. 문법을 기억하고, API를 찾아보고, 버그를 추적하고, 테스트 케이스를 작성하는 모든 과정이 정신적 에너지를 소모했습니다.

저녁이 되면 개발자는 지쳐 있었습니다. 아키텍처를 설계하거나 새로운 아이디어를 생각할 에너지가 남아있지 않았습니다. 이것이 80/20 분배의 실제 문제였습니다. 귀중한 20%의 시간을 개발자가 가장 지친 상태에서 사용해야 했던 것입니다.

Continuous Agentic Development는 이 문제를 해결합니다. 개발자는 더 이상 코드 작성의 세부사항에 정신적 에너지를 소모하지 않습니다. 대신 높은 수준의 설계와 전략에 집중합니다. 이것은 정신적으로 더 자극적이고 보람 있는 작업입니다.

Diego Mateos, Rakuten의 시니어 머신러닝 엔지니어는 이렇게 말합니다. "나는 원래 테스트 주도 개발을 자연스럽게 사용하지 않았습니다. 하지만 Claude Code는 이것을 너무 쉽게 만들어줍니다. 종합적인 테스트를 즉시 생성하고, 그것을 통과하는 기능을 만듭니다. 이것은 내가 개발하는 방식을 완전히 바꾸었고, 나를 훨씬 더 효율적인 엔지니어로 만들었습니다."

### 번아웃 패턴의 소멸

Boris Cherny의 GitHub 기여 그래프를 보면 놀라운 점이 하나 있습니다. 10월부터 12월까지 지속적으로 높은 강도의 작업이 이루어졌는데, 전형적인 번아웃 패턴이 보이지 않습니다.

전통적인 개발에서 높은 강도로 작업하면 반드시 번아웃이 옵니다. 2-3주 동안 매일 10시간씩 코딩하면, 그다음 주에는 생산성이 급격히 떨어집니다. 정신적, 육체적 피로가 누적되기 때문입니다.

하지만 Continuous Agentic Development에서는 다릅니다. 개발자가 직접 코드를 타이핑하지 않기 때문에, 육체적 피로가 훨씬 적습니다. 그리고 창의적이고 전략적인 작업에 집중하기 때문에, 정신적으로도 더 자극적이고 덜 지루합니다.

결과적으로 개발자는 더 오래, 더 지속적으로, 더 높은 품질로 작업할 수 있습니다.

## 기술적 기반: 무엇이 이것을 가능하게 했는가?

### 모델 능력의 비약적 발전

Boris Cherny는 회상합니다. "1년 전, Claude는 이스케이프 문제 없이 bash 명령어를 생성하는 것조차 어려워했습니다. 몇 초에서 몇 분 정도 작동하는 것이 고작이었습니다."

하지만 Claude 3.7과 4.0으로 진화하면서 상황이 완전히 바뀌었습니다. 모델은 이제 복잡한 코드베이스를 이해하고, 맥락을 유지하고, 일관된 코드를 생성할 수 있습니다.

### "안장(Saddle)"의 중요성

하지만 강력한 모델만으로는 충분하지 않습니다. Boris는 이것을 "안장" 비유로 설명합니다. 아무리 강력한 말이 있어도, 적절한 안장이 없으면 효과적으로 조종할 수 없습니다.

Claude Code는 바로 이 "안장" 역할을 합니다. 모델을 둘러싼 도구와 컨텍스트 관리 시스템입니다. Claude Code는 다음과 같은 기능을 제공합니다.

**컨텍스트 자동 수집**

Claude Code는 대화를 시작할 때 자동으로 프로젝트의 컨텍스트를 수집합니다. 파일 구조, CLAUDE.md 파일, 최근 변경사항 등을 파악합니다. 개발자는 매번 "이 프로젝트는 React를 사용하고, TypeScript로 작성되어 있어"라고 설명할 필요가 없습니다.

**에이전틱 검색**

처음에 Anthropic 팀은 RAG(Retrieval-Augmented Generation)를 시도했습니다. 코드베이스를 인덱싱하고, 벡터 검색을 사용해서 관련 코드를 찾는 방식이었습니다. 하지만 이것은 잘 작동하지 않았습니다.

대신 그들은 "에이전틱 검색"을 선택했습니다. Claude가 스스로 파일 시스템을 탐색하고, 파일을 읽고, import를 따라가고, 필요한 정보를 찾는 방식입니다. Boris는 말합니다. "이것은 모든 것을 압도적으로 능가했습니다. 놀라웠어요."

**권한 시스템**

Claude Code가 로컬에서 실행되기 때문에, 중요한 문제가 있었습니다. AI가 실수로 파일을 삭제하거나 중요한 설정을 변경하면 어떻게 할까요?

Anthropic 팀은 정교한 권한 시스템을 구축했습니다. Claude는 파일을 읽을 수 있지만, 쓰기 전에는 사용자의 승인을 받아야 합니다. 중요한 작업(git push, rm -rf 등)은 특별한 확인을 요구합니다.

이 권한 시스템이 Claude Code의 가장 복잡한 부분입니다. 하지만 이것이 있기 때문에 개발자는 안심하고 AI에게 작업을 맡길 수 있습니다.

### 빠른 반복 주기

Claude Code 팀은 놀라운 속도로 작업합니다. 하루에 60-100번의 내부 릴리스를 진행합니다. 엔지니어가 변경사항을 만들면 즉시 새로운 npm 패키지가 릴리스됩니다.

Anthropic의 모든 직원이 내부 버전을 사용하고, 개발 팀은 즉각적인 피드백을 받습니다. 여름 동안 엔지니어들은 하루에 평균 5개의 Pull Request를 푸시했습니다. 대부분의 기술 회사에서 하루 1-2개의 PR이 일반적인 것과 비교하면 훨씬 빠른 속도입니다.

이 빠른 반복은 Claude Code와 모델의 "공진화(co-evolution)"를 가능하게 했습니다. 모델이 개선되면 Claude Code가 그것을 활용하는 새로운 기능을 추가합니다. Claude Code가 새로운 사용 패턴을 발견하면 모델을 개선하는 데 피드백을 제공합니다.

## 민주화: 비개발자도 코딩하다

### 기술 장벽의 붕괴

Continuous Agentic Development의 또 다른 혁명적 측면은 개발이 더 이상 개발자만의 영역이 아니라는 것입니다.

Rakuten의 Yusuke Kaji는 말합니다. "우리는 비개발자에게도 Claude Code를 사용하도록 했습니다. 터미널 인터페이스 덕분에, 비기술 역할의 동료들도 코드를 직접 편집하지 않고 코딩 프로젝트에 기여할 수 있습니다. 적절한 컨텍스트와 코딩 가이드라인이 있으면, Claude Code가 안전 가드레일 역할을 합니다."

이것은 소프트웨어 개발의 민주화입니다. 프로덕트 매니저가 직접 프로토타입을 만들 수 있습니다. 디자이너가 상호작용 로직을 구현할 수 있습니다. 비즈니스 분석가가 데이터 처리 스크립트를 작성할 수 있습니다.

물론 이들이 생성한 코드는 여전히 전문 개발자의 검토가 필요합니다. 하지만 초기 버전을 만드는 것, 아이디어를 빠르게 테스트하는 것, 요구사항을 명확히 하는 것은 이제 누구나 할 수 있습니다.

### 역량의 증폭

Diego Mateos의 경험은 이것을 잘 보여줍니다. 그는 원래 테스트 주도 개발(TDD)을 자연스럽게 사용하지 않았습니다. TDD는 좋은 방법이지만, 시간이 많이 걸리기 때문에 많은 개발자가 건너뛰곤 했습니다.

하지만 Claude Code는 TDD를 쉽게 만들었습니다. "종합적인 테스트를 즉시 생성하고, 그것을 통과하는 기능을 만듭니다." 결과적으로 Diego는 더 나은 개발자가 되었습니다. AI가 그의 능력을 대체한 것이 아니라 증폭시킨 것입니다.

## 새로운 워크플로우: Plan-Build-Review

### Plan 모드: 실행 전 계획

Claude Code의 핵심 기능 중 하나는 "Plan 모드"입니다. 이것은 즉시 코드를 생성하는 대신, 먼저 계획을 세우고 사용자의 승인을 받는 기능입니다.

당신이 "사용자 인증 시스템을 추가해줘"라고 요청하면, Claude는 즉시 코드를 작성하지 않습니다. 대신 이렇게 응답합니다.

"알겠습니다. 다음과 같은 계획으로 진행하겠습니다.

1. JWT 기반 인증 라이브러리 선택 및 설치
2. 사용자 모델 및 데이터베이스 스키마 생성
3. 로그인/로그아웃 API 엔드포인트 구현
4. 비밀번호 해싱 및 검증 로직 추가
5. 인증 미들웨어 구현
6. 프론트엔드에 로그인 폼 추가
7. 보호된 라우트 설정

이 계획이 맞나요? 수정할 부분이 있나요?"

당신은 계획을 검토하고, 필요하면 조정합니다. "JWT 대신 세션 기반 인증을 사용하자. 그리고 OAuth도 지원해야 해." Claude는 계획을 수정하고, 다시 확인을 받습니다.

계획이 확정되면, Claude는 단계별로 실행합니다. 각 단계를 완료하면 보고하고, 다음 단계로 진행하기 전에 확인을 받습니다.

### Build: 연속적 구현

Build 단계에서 Claude는 연속적으로 작업합니다. 하지만 이것은 맹목적인 실행이 아닙니다. Claude는 작업하면서 문제를 발견하면 멈추고 보고합니다.

"JWT 라이브러리를 설치하려고 했는데, package.json에 이미 다른 인증 라이브러리가 있습니다. 교체해야 할까요, 아니면 둘 다 유지해야 할까요?"

이런 식으로 Claude는 자율적이면서도 통제 가능한 상태를 유지합니다. 당신은 커피를 마시러 가도 되지만, 중요한 결정은 여전히 당신이 내립니다.

### Review: 철저한 검증

구현이 완료되면, Review 단계입니다. Claude는 자신이 생성한 코드를 분석하고 보고서를 제공합니다.

"인증 시스템 구현이 완료되었습니다. 다음 사항을 확인했습니다.

✅ 비밀번호는 bcrypt로 해싱됨
✅ JWT 토큰은 환경 변수에서 시크릿을 가져옴
✅ SQL 인젝션 방지를 위해 PreparedStatement 사용
✅ CORS 설정 확인
✅ 단위 테스트 커버리지 85%

⚠️ 주의사항:
- 현재 토큰 만료 시간이 24시간으로 설정됨. 보안상 더 짧게 할 것을 권장
- 리프레시 토큰 메커니즘이 아직 구현되지 않음

다음 단계 추천:
1. 토큰 만료 시간을 1시간으로 단축
2. 리프레시 토큰 구현
3. 비밀번호 복잡성 검증 추가"

당신은 이 보고서를 검토하고, 필요한 개선사항을 지시합니다.

## 도전과 한계

### 맹목적 신뢰의 위험

Continuous Agentic Development의 가장 큰 위험은 AI를 맹목적으로 신뢰하는 것입니다. Claude는 놀랍도록 능력 있지만, 완벽하지 않습니다.

보안 취약점을 놓칠 수 있습니다. 성능 이슈를 만들 수 있습니다. 비즈니스 로직을 잘못 이해할 수 있습니다. 개발자의 검토는 여전히 필수적입니다.

Rakuten의 사례에서도 이것이 강조됩니다. "Claude Code가 많은 코드를 작성하더라도, 병합하는 개인은 여전히 그 코드에 대한 책임이 있습니다. 잘 유지되고, 잘 문서화되고, 합리적인 추상화를 가진 코드인지 확인하는 것은 개별 개발자의 책임입니다."

### 스킬 퇴화의 우려

AI가 모든 코드를 작성하면, 개발자의 코딩 스킬이 퇴화하지 않을까요? 이것은 정당한 우려입니다.

하지만 역사는 이것이 항상 기우였음을 보여줍니다. 계산기가 나왔을 때, 사람들은 산술 능력이 퇴화할 것을 걱정했습니다. IDE가 나왔을 때, 사람들은 메모리 능력이 떨어질 것을 걱정했습니다.

실제로 일어난 것은 다릅니다. 개발자는 저수준 세부사항에서 해방되어 고수준 설계에 집중할 수 있게 되었습니다. 더 복잡한 시스템을 만들 수 있게 되었습니다. 더 창의적인 해결책을 찾을 수 있게 되었습니다.

중요한 것은 균형입니다. 개발자는 여전히 코드를 읽고 이해할 수 있어야 합니다. 핵심 로직은 직접 작성하는 것이 좋을 수 있습니다. 하지만 반복적이고 기계적인 작업은 AI에게 맡기는 것이 합리적입니다.

### 비용과 한계

Claude Code는 강력하지만 비용이 듭니다. 평균 사용자는 하루에 약 $6를 소비합니다. Cursor 같은 다른 도구가 월 $20인 것과 비교하면 훨씬 비쌉니다.

Anthropic 내부의 일부 엔지니어는 하루에 $1,000 이상을 사용한 적도 있습니다. 이것은 지속 가능하지 않았고, Anthropic은 사용 한도를 도입해야 했습니다.

또한 모델에는 한계가 있습니다. 매우 복잡한 리팩토링, 레거시 시스템 마이그레이션, 미묘한 버그 수정 등은 여전히 인간의 전문성이 필요합니다.

## 미래 전망: 90/10의 세계?

### 비율은 계속 변화할 것인가?

현재 20/80 비율은 최종 상태가 아닐 수 있습니다. 모델이 계속 개선되면서, 생산 활동 감독에 필요한 시간은 더욱 줄어들 수 있습니다.

5년 후에는 10/90이 될 수도 있습니다. 개발자는 시간의 10%만 AI 출력을 확인하고, 나머지 90%는 순수하게 전략과 창의성에 집중하는 것입니다.

심지어 5/95도 가능할 수 있습니다. AI가 자체적으로 테스트하고, 검증하고, 최적화하면서, 인간은 최종 승인만 하는 세상입니다.

### 개발자의 진화

이런 미래에서 "개발자"라는 직업은 어떻게 변할까요?

아마도 직업의 이름 자체가 바뀔 것입니다. "소프트웨어 엔지니어" 대신 "시스템 아키텍트", "프로덕트 엔지니어", "AI 오케스트레이터" 같은 이름이 될 수 있습니다.

필요한 스킬도 변할 것입니다. 코딩 능력보다는 시스템 사고, 비즈니스 이해, 커뮤니케이션 능력이 더 중요해질 것입니다. AI에게 정확한 지시를 내리는 "프롬프트 엔지니어링" 스킬이 핵심이 될 것입니다.

### 조직 구조의 변화

팀 구조도 변할 것입니다. Rakuten의 Yusuke Kaji가 말한 "각 팀이 달성할 수 있는 것을 곱하는 것"이 현실이 되면, 소규모 팀이 대규모 프로젝트를 수행할 수 있게 됩니다.

현재 10명이 필요한 프로젝트를 3-4명이 할 수 있게 됩니다. 이것은 스타트업에게는 엄청난 기회입니다. 소수의 창업자가 과거에는 대기업만 만들 수 있던 복잡한 시스템을 구축할 수 있습니다.

## 실천 가이드: 20/80의 세계로 전환하기

### 1주차: 마인드셋 전환

가장 먼저 해야 할 것은 마인드셋을 바꾸는 것입니다. "나는 코더다"에서 "나는 아키텍트다"로 전환하세요.

코드를 직접 타이핑하는 것에 집착하지 마세요. 대신 "무엇을 만들 것인가"에 80%의 에너지를 쏟으세요. AI에게 구현을 맡기는 것을 두려워하지 마세요.

### 2주차: 작은 작업부터 시작

처음부터 대규모 프로젝트를 AI에게 맡기지 마세요. 작은 기능부터 시작하세요.

"이 컴포넌트에 정렬 기능을 추가해줘"
"이 API에 에러 처리를 개선해줘"
"이 함수의 성능을 최적화해줘"

각 작업에서 Plan-Build-Review 주기를 연습하세요. AI의 출력을 검토하는 눈을 키우세요.

### 3주차: 복잡한 기능 구현

이제 전체 기능을 AI에게 맡겨보세요. 프론트엔드부터 백엔드, 데이터베이스까지 전체 스택을 포함하는 기능입니다.

상세한 계획을 세우고, Claude에게 단계별로 구현하도록 지시하세요. 각 단계를 검토하고, 필요하면 방향을 조정하세요.

### 4주차: 연속 작업 세션

Stop Hooks를 활용한 장시간 세션을 시도하세요. 아침에 하루 치 작업 계획을 Claude에게 주고, 저녁에 결과를 검토하는 방식입니다.

처음에는 불안할 수 있습니다. "AI에게 이렇게 많은 것을 맡겨도 될까?" 하지만 점점 신뢰가 쌓일 것입니다.

### 지속적 개선

매주 회고를 하세요. 무엇이 잘 작동했고, 무엇이 개선이 필요한지 파악하세요.

- AI에게 어떤 지시가 가장 효과적이었는가?
- 어떤 종류의 작업에서 AI가 가장 도움이 되었는가?
- 어떤 부분에서 인간의 개입이 필수적이었는가?

이런 인사이트를 바탕으로 계속 워크플로우를 개선하세요.

## 맺으며: 새로운 시대의 개발자

Continuous Agentic Development는 단순한 도구의 변화가 아닙니다. 개발자라는 직업의 본질이 변화하는 것입니다.

과거에 개발자는 코드를 작성하는 사람이었습니다. 지금 개발자는 시스템을 설계하는 사람입니다. 미래에 개발자는 비즈니스 가치를 창출하는 사람이 될 것입니다.

80%의 시간을 코드 타이핑에 사용하던 시대는 끝나가고 있습니다. 새로운 시대에는 80%의 시간을 전략, 설계, 창의성에 사용합니다. AI가 기계적인 작업을 담당하고, 인간은 의미 있는 결정에 집중합니다.

Boris Cherny가 30일 만에 259개의 Pull Request를 만들 수 있었던 것은 그가 슈퍼맨이어서가 아닙니다. 그가 20/80의 새로운 세계를 받아들였기 때문입니다.

Rakuten이 24일 걸리던 작업을 5일 만에 끝낼 수 있었던 것은 그들이 더 뛰어난 개발자를 고용해서가 아닙니다. 그들이 개발자의 시간을 더 가치 있는 곳에 집중시켰기 때문입니다.

이 변화는 이미 시작되었습니다. 질문은 "이 변화가 일어날 것인가"가 아니라 "언제 당신이 이 변화에 동참할 것인가"입니다.

코드를 작성하는 데 80%의 시간을 쓰는 개발자와, 전략을 세우는 데 80%의 시간을 쓰는 개발자. 5년 후, 이 둘 중 누가 더 큰 영향력을 가질까요? 누가 더 높은 가치를 창출할까요? 누가 더 만족스러운 커리어를 가질까요?

답은 명확합니다. Continuous Agentic Development의 시대가 왔습니다. 환영합니다.

---

**참고 자료:**
- Boris Cherny Twitter/X 발표 (2024년 12월)
- Aakash Gupta 분석: "Continuous Agentic Development" 개념
- Rakuten 사례 연구: 79% 시간 단축 (24일 → 5일)
- Anthropic 공식 블로그: Claude Code 베스트 프랙티스
- Pragmatic Engineer: "How Claude Code is Built" (Gergely Orosz)
- Latent Space 팟캐스트: Boris Cherny & Cat Wu 인터뷰

**작성일:** 2025-12-28

