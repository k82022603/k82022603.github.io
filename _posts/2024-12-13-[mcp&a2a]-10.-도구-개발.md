---
title: "[MCP&A2A] 10. ë„êµ¬ ê°œë°œ"
date: 2024-12-13 10:20:00 +0900
categories: [AI,  MCP & A2A]
mermaid: [True]
tags: [AI,  MCP,  A2A,  Guide,  MCP-A2A-Guide,  Medium,  Claude.write]
---


## MCP Toolì´ë€?

MCP Toolì€ AI ì—ì´ì „íŠ¸ê°€ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” **êµ¬ì¡°í™”ëœ í•¨ìˆ˜**ì…ë‹ˆë‹¤. JSON Schemaë¡œ ì…ë ¥ì„ ì •ì˜í•˜ê³ , ì‹¤í–‰ ê²°ê³¼ë¥¼ í‘œì¤€í™”ëœ í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

### Toolì˜ êµ¬ì„± ìš”ì†Œ

```
MCP Tool
â”œâ”€â”€ Definition (ì •ì˜)
â”‚   â”œâ”€â”€ Name: ë„êµ¬ ì´ë¦„ (ê³ ìœ  ì‹ë³„ì)
â”‚   â”œâ”€â”€ Description: ë„êµ¬ ê¸°ëŠ¥ ì„¤ëª…
â”‚   â””â”€â”€ InputSchema: JSON Schema ì…ë ¥ ì •ì˜
â””â”€â”€ Execute (ì‹¤í–‰)
    â”œâ”€â”€ Input: ê²€ì¦ëœ íŒŒë¼ë¯¸í„°
    â”œâ”€â”€ Logic: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    â””â”€â”€ Output: í‘œì¤€í™”ëœ ê²°ê³¼
```

### Tool vs Function Call

| íŠ¹ì„± | MCP Tool | Function Call (OpenAI) |
|------|----------|----------------------|
| **í‘œì¤€í™”** | âœ… MCP í‘œì¤€ | ê° ëª¨ë¸ë§ˆë‹¤ ë‹¤ë¦„ |
| **ìŠ¤í‚¤ë§ˆ** | JSON Schema | JSON Schema |
| **ì‹¤í–‰** | ì„œë²„ ì‚¬ì´ë“œ | í´ë¼ì´ì–¸íŠ¸ ê²°ì • |
| **ì¬ì‚¬ìš©** | âœ… ì–´ë–¤ AIë“  | OpenAIë§Œ |
| **ë³´ì•ˆ** | âœ… ì„œë²„ í†µì œ | í´ë¼ì´ì–¸íŠ¸ ì‹ ë¢° í•„ìš” |

## Tool ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

### ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤

```go
// internal/tools/tool.go
package tools

import (
    "context"
    "mcp-server/internal/protocol"
)

// Tool ì¸í„°í˜ì´ìŠ¤
type Tool interface {
    // ë„êµ¬ ì •ì˜ ë°˜í™˜
    Definition() protocol.ToolDefinition
    
    // ë„êµ¬ ì‹¤í–‰
    Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error)
}

// ì„ íƒì : ì…ë ¥ ê²€ì¦ ì¸í„°í˜ì´ìŠ¤
type ValidatableTool interface {
    Tool
    Validate(args map[string]interface{}) error
}

// ì„ íƒì : ê¶Œí•œ ì²´í¬ ì¸í„°í˜ì´ìŠ¤
type AuthorizableTool interface {
    Tool
    RequiredPermissions() []string
    CheckPermission(ctx context.Context, permission string) bool
}
```

### Tool Registry

```go
// internal/tools/registry.go
package tools

import (
    "fmt"
    "sync"
    
    "mcp-server/internal/protocol"
)

type Registry struct {
    tools map[string]Tool
    mu    sync.RWMutex
}

func NewRegistry() *Registry {
    return &Registry{
        tools: make(map[string]Tool),
    }
}

// ë„êµ¬ ë“±ë¡
func (r *Registry) Register(tool Tool) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    def := tool.Definition()
    
    // ì¤‘ë³µ ì²´í¬
    if _, exists := r.tools[def.Name]; exists {
        return fmt.Errorf("tool already registered: %s", def.Name)
    }
    
    r.tools[def.Name] = tool
    return nil
}

// ë„êµ¬ ì¡°íšŒ
func (r *Registry) Get(name string) (Tool, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    tool, ok := r.tools[name]
    if !ok {
        return nil, fmt.Errorf("tool not found: %s", name)
    }
    
    return tool, nil
}

// ëª¨ë“  ë„êµ¬ ì •ì˜ ëª©ë¡
func (r *Registry) List() []protocol.ToolDefinition {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    var definitions []protocol.ToolDefinition
    for _, tool := range r.tools {
        definitions = append(definitions, tool.Definition())
    }
    
    return definitions
}

// ë„êµ¬ ê°œìˆ˜
func (r *Registry) Count() int {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    return len(r.tools)
}
```

## JSON Schema ì‘ì„±

### Schema ê¸°ë³¸ êµ¬ì¡°

```json
{
  "type": "object",
  "properties": {
    "property_name": {
      "type": "string",
      "description": "ì„¤ëª…",
      "default": "ê¸°ë³¸ê°’",
      "enum": ["ì˜µì…˜1", "ì˜µì…˜2"],
      "pattern": "ì •ê·œì‹",
      "minLength": 1,
      "maxLength": 100
    }
  },
  "required": ["í•„ìˆ˜_í•„ë“œ"]
}
```

### ì£¼ìš” íƒ€ì…ê³¼ ê²€ì¦

```go
// ë¬¸ìì—´
map[string]interface{}{
    "type": "string",
    "description": "ì‚¬ìš©ì ì´ë¦„",
    "minLength": 1,
    "maxLength": 50,
    "pattern": "^[a-zA-Z0-9_]+$",
}

// ì •ìˆ˜
map[string]interface{}{
    "type": "integer",
    "description": "í˜ì´ì§€ í¬ê¸°",
    "default": 10,
    "minimum": 1,
    "maximum": 100,
}

// ìˆ«ì (ì‹¤ìˆ˜)
map[string]interface{}{
    "type": "number",
    "description": "ê°€ì¤‘ì¹˜",
    "default": 0.5,
    "minimum": 0.0,
    "maximum": 1.0,
}

// ë¶ˆë¦¬ì–¸
map[string]interface{}{
    "type": "boolean",
    "description": "í™œì„±í™” ì—¬ë¶€",
    "default": true,
}

// ë°°ì—´
map[string]interface{}{
    "type": "array",
    "description": "íƒœê·¸ ëª©ë¡",
    "items": map[string]interface{}{
        "type": "string",
    },
    "minItems": 1,
    "maxItems": 10,
}

// ê°ì²´
map[string]interface{}{
    "type": "object",
    "description": "í•„í„° ì¡°ê±´",
    "properties": map[string]interface{}{
        "field": map[string]interface{}{
            "type": "string",
        },
        "operator": map[string]interface{}{
            "type": "string",
            "enum": []string{"eq", "ne", "gt", "lt"},
        },
    },
    "required": []string{"field", "operator"},
}

// Enum (ì„ íƒì§€)
map[string]interface{}{
    "type": "string",
    "description": "ì •ë ¬ ìˆœì„œ",
    "enum": []string{"asc", "desc"},
    "default": "desc",
}

// OneOf (ì—¬ëŸ¬ íƒ€ì… ì¤‘ í•˜ë‚˜)
map[string]interface{}{
    "oneOf": []map[string]interface{}{
        {"type": "string"},
        {"type": "integer"},
    },
}
```

## ì‹¤ì „ ë„êµ¬ ê°œë°œ

### 1. ê³„ì‚°ê¸° ë„êµ¬

ê°„ë‹¨í•œ ìˆ˜ì‹ ê³„ì‚° ë„êµ¬:

```go
// internal/tools/calculator.go
package tools

import (
    "context"
    "fmt"
    "math"
    "strconv"
    "strings"
    
    "mcp-server/internal/protocol"
)

type CalculatorTool struct{}

func NewCalculatorTool() *CalculatorTool {
    return &CalculatorTool{}
}

func (t *CalculatorTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "calculator",
        Description: "ê°„ë‹¨í•œ ìˆ˜í•™ ê³„ì‚°ê¸° (ë§ì…ˆ, ëº„ì…ˆ, ê³±ì…ˆ, ë‚˜ëˆ—ì…ˆ, ì œê³±)",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "expression": map[string]interface{}{
                    "type":        "string",
                    "description": "ê³„ì‚°í•  ìˆ˜ì‹ (ì˜ˆ: 2 + 3 * 4)",
                },
            },
            "required": []string{"expression"},
        },
    }
}

func (t *CalculatorTool) Validate(args map[string]interface{}) error {
    expr, ok := args["expression"].(string)
    if !ok || expr == "" {
        return fmt.Errorf("expressionì€ ë¹„ì–´ìˆì§€ ì•Šì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
    }
    
    // í—ˆìš©ëœ ë¬¸ìë§Œ í¬í•¨í•˜ëŠ”ì§€ ì²´í¬
    allowed := "0123456789+-*/(). "
    for _, char := range expr {
        if !strings.ContainsRune(allowed, char) {
            return fmt.Errorf("í—ˆìš©ë˜ì§€ ì•Šì€ ë¬¸ì: %c", char)
        }
    }
    
    return nil
}

func (t *CalculatorTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    if err := t.Validate(args); err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ê²€ì¦ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    expr := args["expression"].(string)
    
    // ìˆ˜ì‹ ê³„ì‚° (ê°„ë‹¨í•œ êµ¬í˜„)
    result, err := t.evaluate(expr)
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ê³„ì‚° ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: fmt.Sprintf("%s = %v", expr, result),
                Metadata: map[string]interface{}{
                    "expression": expr,
                    "result":     result,
                },
            },
        },
    }, nil
}

func (t *CalculatorTool) evaluate(expr string) (float64, error) {
    // ê°„ë‹¨í•œ ìˆ˜ì‹ í‰ê°€ê¸°
    // ì‹¤ë¬´ì—ì„œëŠ” github.com/Knetic/govaluate ê°™ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
    expr = strings.TrimSpace(expr)
    
    // ìˆ«ìë§Œ ìˆëŠ” ê²½ìš°
    if num, err := strconv.ParseFloat(expr, 64); err == nil {
        return num, nil
    }
    
    // ê°„ë‹¨í•œ ì—°ì‚° ì²˜ë¦¬ (ì˜ˆì‹œ)
    // ì‹¤ì œë¡œëŠ” íŒŒì‹± íŠ¸ë¦¬ êµ¬ì„± í•„ìš”
    return 0, fmt.Errorf("ë³µì¡í•œ ìˆ˜ì‹ì€ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤")
}
```

### 2. ë‚ ì”¨ ì¡°íšŒ ë„êµ¬

ì™¸ë¶€ API í˜¸ì¶œ ì˜ˆì œ:

```go
// internal/tools/weather.go
package tools

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "net/url"
    
    "mcp-server/internal/protocol"
)

type WeatherTool struct {
    apiKey     string
    httpClient *http.Client
}

func NewWeatherTool(apiKey string) *WeatherTool {
    return &WeatherTool{
        apiKey:     apiKey,
        httpClient: &http.Client{Timeout: 10 * time.Second},
    }
}

func (t *WeatherTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "get_weather",
        Description: "íŠ¹ì • ë„ì‹œì˜ í˜„ì¬ ë‚ ì”¨ ì •ë³´ ì¡°íšŒ",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "city": map[string]interface{}{
                    "type":        "string",
                    "description": "ë„ì‹œ ì´ë¦„ (ì˜ˆ: Seoul, Tokyo, New York)",
                },
                "units": map[string]interface{}{
                    "type":        "string",
                    "description": "ì˜¨ë„ ë‹¨ìœ„",
                    "enum":        []string{"metric", "imperial"},
                    "default":     "metric",
                },
            },
            "required": []string{"city"},
        },
    }
}

func (t *WeatherTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    city := args["city"].(string)
    
    units := "metric"
    if u, ok := args["units"].(string); ok {
        units = u
    }
    
    // OpenWeatherMap API í˜¸ì¶œ
    weatherData, err := t.fetchWeather(ctx, city, units)
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ë‚ ì”¨ ì¡°íšŒ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // ê²°ê³¼ í¬ë§·íŒ…
    temp := weatherData.Main.Temp
    tempUnit := "Â°C"
    if units == "imperial" {
        tempUnit = "Â°F"
    }
    
    text := fmt.Sprintf(
        "ğŸŒ %s ë‚ ì”¨\n"+
        "ğŸŒ¡ï¸ ì˜¨ë„: %.1f%s\n"+
        "ğŸ’§ ìŠµë„: %d%%\n"+
        "â˜ï¸ ìƒíƒœ: %s\n"+
        "ğŸ’¨ í’ì†: %.1f m/s",
        city,
        temp,
        tempUnit,
        weatherData.Main.Humidity,
        weatherData.Weather[0].Description,
        weatherData.Wind.Speed,
    )
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: text,
                Metadata: map[string]interface{}{
                    "city":        city,
                    "temperature": temp,
                    "units":       units,
                },
            },
        },
    }, nil
}

type WeatherResponse struct {
    Main struct {
        Temp     float64 `json:"temp"`
        Humidity int     `json:"humidity"`
    } `json:"main"`
    Weather []struct {
        Description string `json:"description"`
    } `json:"weather"`
    Wind struct {
        Speed float64 `json:"speed"`
    } `json:"wind"`
}

func (t *WeatherTool) fetchWeather(ctx context.Context, city, units string) (*WeatherResponse, error) {
    baseURL := "https://api.openweathermap.org/data/2.5/weather"
    
    params := url.Values{}
    params.Set("q", city)
    params.Set("appid", t.apiKey)
    params.Set("units", units)
    
    req, err := http.NewRequestWithContext(
        ctx,
        "GET",
        baseURL+"?"+params.Encode(),
        nil,
    )
    if err != nil {
        return nil, err
    }
    
    resp, err := t.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("API error: status %d", resp.StatusCode)
    }
    
    var weatherData WeatherResponse
    if err := json.NewDecoder(resp.Body).Decode(&weatherData); err != nil {
        return nil, err
    }
    
    return &weatherData, nil
}
```

### 3. ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ë„êµ¬

ë™ì  ì¿¼ë¦¬ ìƒì„±:

```go
// internal/tools/database_query.go
package tools

import (
    "context"
    "fmt"
    "strings"
    
    "mcp-server/internal/database"
    "mcp-server/internal/protocol"
)

type DatabaseQueryTool struct {
    db *database.DB
}

func NewDatabaseQueryTool(db *database.DB) *DatabaseQueryTool {
    return &DatabaseQueryTool{db: db}
}

func (t *DatabaseQueryTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "query_documents",
        Description: "ê³ ê¸‰ í•„í„°ë§ìœ¼ë¡œ ë¬¸ì„œ ê²€ìƒ‰",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "filters": map[string]interface{}{
                    "type":        "array",
                    "description": "í•„í„° ì¡°ê±´ ëª©ë¡",
                    "items": map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                            "field": map[string]interface{}{
                                "type": "string",
                                "enum": []string{"title", "source", "created_at"},
                            },
                            "operator": map[string]interface{}{
                                "type": "string",
                                "enum": []string{"eq", "ne", "like", "gt", "lt"},
                            },
                            "value": map[string]interface{}{
                                "description": "ë¹„êµ ê°’",
                            },
                        },
                        "required": []string{"field", "operator", "value"},
                    },
                },
                "sort_by": map[string]interface{}{
                    "type":    "string",
                    "enum":    []string{"created_at", "updated_at", "title"},
                    "default": "created_at",
                },
                "sort_order": map[string]interface{}{
                    "type":    "string",
                    "enum":    []string{"asc", "desc"},
                    "default": "desc",
                },
                "limit": map[string]interface{}{
                    "type":    "integer",
                    "default": 10,
                    "minimum": 1,
                    "maximum": 100,
                },
            },
        },
    }
}

func (t *DatabaseQueryTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    tenantID := ctx.Value("tenant_id").(string)
    
    // í•„í„° íŒŒì‹±
    var filters []Filter
    if f, ok := args["filters"].([]interface{}); ok {
        for _, filter := range f {
            fm := filter.(map[string]interface{})
            filters = append(filters, Filter{
                Field:    fm["field"].(string),
                Operator: fm["operator"].(string),
                Value:    fm["value"],
            })
        }
    }
    
    // ì •ë ¬ íŒŒë¼ë¯¸í„°
    sortBy := "created_at"
    if s, ok := args["sort_by"].(string); ok {
        sortBy = s
    }
    
    sortOrder := "desc"
    if s, ok := args["sort_order"].(string); ok {
        sortOrder = s
    }
    
    limit := 10
    if l, ok := args["limit"].(float64); ok {
        limit = int(l)
    }
    
    // ì¿¼ë¦¬ ìƒì„±
    query, queryArgs := t.buildQuery(tenantID, filters, sortBy, sortOrder, limit)
    
    // ì¿¼ë¦¬ ì‹¤í–‰
    results, err := t.db.ExecuteQuery(ctx, query, queryArgs...)
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ì¿¼ë¦¬ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // ê²°ê³¼ í¬ë§·íŒ…
    var text strings.Builder
    text.WriteString(fmt.Sprintf("ê²€ìƒ‰ ê²°ê³¼ (%dê°œ):\n\n", len(results)))
    
    for i, result := range results {
        text.WriteString(fmt.Sprintf("%d. %s\n", i+1, result.Title))
        text.WriteString(fmt.Sprintf("   ìƒì„±: %s\n", result.CreatedAt.Format("2006-01-02")))
        if result.Source != "" {
            text.WriteString(fmt.Sprintf("   ì¶œì²˜: %s\n", result.Source))
        }
        text.WriteString("\n")
    }
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: text.String(),
                Metadata: map[string]interface{}{
                    "count":   len(results),
                    "filters": filters,
                },
            },
        },
    }, nil
}

type Filter struct {
    Field    string
    Operator string
    Value    interface{}
}

func (t *DatabaseQueryTool) buildQuery(
    tenantID string,
    filters []Filter,
    sortBy, sortOrder string,
    limit int,
) (string, []interface{}) {
    query := "SELECT id, title, content, source, created_at FROM documents WHERE tenant_id = $1"
    args := []interface{}{tenantID}
    argIndex := 2
    
    // í•„í„° ì¶”ê°€
    for _, filter := range filters {
        var condition string
        
        switch filter.Operator {
        case "eq":
            condition = fmt.Sprintf("%s = $%d", filter.Field, argIndex)
        case "ne":
            condition = fmt.Sprintf("%s != $%d", filter.Field, argIndex)
        case "like":
            condition = fmt.Sprintf("%s LIKE $%d", filter.Field, argIndex)
            filter.Value = "%" + filter.Value.(string) + "%"
        case "gt":
            condition = fmt.Sprintf("%s > $%d", filter.Field, argIndex)
        case "lt":
            condition = fmt.Sprintf("%s < $%d", filter.Field, argIndex)
        }
        
        query += " AND " + condition
        args = append(args, filter.Value)
        argIndex++
    }
    
    // ì •ë ¬
    query += fmt.Sprintf(" ORDER BY %s %s", sortBy, strings.ToUpper(sortOrder))
    
    // ì œí•œ
    query += fmt.Sprintf(" LIMIT $%d", argIndex)
    args = append(args, limit)
    
    return query, args
}
```

### 4. íŒŒì¼ ì—…ë¡œë“œ ë„êµ¬

ë©€í‹°íŒŒíŠ¸ ì—…ë¡œë“œ ì²˜ë¦¬:

```go
// internal/tools/file_upload.go
package tools

import (
    "context"
    "fmt"
    "io"
    "os"
    "path/filepath"
    "time"
    
    "github.com/google/uuid"
    
    "mcp-server/internal/database"
    "mcp-server/internal/protocol"
)

type FileUploadTool struct {
    db          *database.DB
    uploadDir   string
    maxFileSize int64  // bytes
}

func NewFileUploadTool(db *database.DB, uploadDir string, maxFileSizeMB int) *FileUploadTool {
    return &FileUploadTool{
        db:          db,
        uploadDir:   uploadDir,
        maxFileSize: int64(maxFileSizeMB) * 1024 * 1024,
    }
}

func (t *FileUploadTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "upload_document",
        Description: "í…ìŠ¤íŠ¸ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  ë¬¸ì„œë¡œ ì €ì¥",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "filename": map[string]interface{}{
                    "type":        "string",
                    "description": "íŒŒì¼ ì´ë¦„",
                },
                "content": map[string]interface{}{
                    "type":        "string",
                    "description": "íŒŒì¼ ë‚´ìš© (base64 ì¸ì½”ë”©)",
                },
                "title": map[string]interface{}{
                    "type":        "string",
                    "description": "ë¬¸ì„œ ì œëª©",
                },
            },
            "required": []string{"filename", "content", "title"},
        },
    }
}

func (t *FileUploadTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    filename := args["filename"].(string)
    content := args["content"].(string)
    title := args["title"].(string)
    
    tenantID := ctx.Value("tenant_id").(string)
    
    // íŒŒì¼ í¬ê¸° ì²´í¬
    if int64(len(content)) > t.maxFileSize {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("íŒŒì¼ í¬ê¸°ê°€ ì œí•œ(%dMB)ì„ ì´ˆê³¼í•©ë‹ˆë‹¤", t.maxFileSize/1024/1024)},
            },
        }, nil
    }
    
    // íŒŒì¼ ì €ì¥
    fileID := uuid.New().String()
    filePath := filepath.Join(t.uploadDir, tenantID, fileID+"_"+filename)
    
    // ë””ë ‰í† ë¦¬ ìƒì„±
    if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ë””ë ‰í† ë¦¬ ìƒì„± ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // íŒŒì¼ ì“°ê¸°
    if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    // DBì— ë¬¸ì„œ ìƒì„±
    doc := &database.Document{
        TenantID: tenantID,
        Title:    title,
        Content:  content,
        Source:   filePath,
    }
    
    if err := t.db.InsertDocument(ctx, doc); err != nil {
        // íŒŒì¼ ì‚­ì œ
        os.Remove(filePath)
        
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ë¬¸ì„œ ì €ì¥ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: fmt.Sprintf("âœ… íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ\në¬¸ì„œ ID: %s\níŒŒì¼: %s", doc.ID, filename),
                Metadata: map[string]interface{}{
                    "document_id": doc.ID,
                    "filename":    filename,
                    "size":        len(content),
                },
            },
        },
    }, nil
}
```

### 5. ì´ë©”ì¼ ì „ì†¡ ë„êµ¬

SMTP í†µí•©:

```go
// internal/tools/email.go
package tools

import (
    "context"
    "fmt"
    "net/smtp"
    "strings"
    
    "mcp-server/internal/protocol"
)

type EmailTool struct {
    smtpHost string
    smtpPort string
    username string
    password string
    fromAddr string
}

func NewEmailTool(smtpHost, smtpPort, username, password, fromAddr string) *EmailTool {
    return &EmailTool{
        smtpHost: smtpHost,
        smtpPort: smtpPort,
        username: username,
        password: password,
        fromAddr: fromAddr,
    }
}

func (t *EmailTool) Definition() protocol.ToolDefinition {
    return protocol.ToolDefinition{
        Name:        "send_email",
        Description: "ì´ë©”ì¼ ì „ì†¡",
        InputSchema: map[string]interface{}{
            "type": "object",
            "properties": map[string]interface{}{
                "to": map[string]interface{}{
                    "type":        "string",
                    "description": "ìˆ˜ì‹ ì ì´ë©”ì¼",
                    "format":      "email",
                },
                "subject": map[string]interface{}{
                    "type":        "string",
                    "description": "ì œëª©",
                },
                "body": map[string]interface{}{
                    "type":        "string",
                    "description": "ë³¸ë¬¸",
                },
                "cc": map[string]interface{}{
                    "type":        "array",
                    "description": "ì°¸ì¡° ìˆ˜ì‹ ì",
                    "items": map[string]interface{}{
                        "type":   "string",
                        "format": "email",
                    },
                },
            },
            "required": []string{"to", "subject", "body"},
        },
    }
}

func (t *EmailTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    to := args["to"].(string)
    subject := args["subject"].(string)
    body := args["body"].(string)
    
    var cc []string
    if ccList, ok := args["cc"].([]interface{}); ok {
        for _, addr := range ccList {
            cc = append(cc, addr.(string))
        }
    }
    
    // ì´ë©”ì¼ ë©”ì‹œì§€ êµ¬ì„±
    msg := t.buildMessage(to, cc, subject, body)
    
    // SMTP ì¸ì¦
    auth := smtp.PlainAuth("", t.username, t.password, t.smtpHost)
    
    // ìˆ˜ì‹ ì ëª©ë¡
    recipients := append([]string{to}, cc...)
    
    // ì´ë©”ì¼ ì „ì†¡
    addr := t.smtpHost + ":" + t.smtpPort
    err := smtp.SendMail(addr, auth, t.fromAddr, recipients, []byte(msg))
    
    if err != nil {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: fmt.Sprintf("ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨: %v", err)},
            },
        }, nil
    }
    
    return protocol.ToolCallResult{
        Content: []protocol.ContentBlock{
            {
                Type: "text",
                Text: fmt.Sprintf("âœ… ì´ë©”ì¼ ì „ì†¡ ì™„ë£Œ\nìˆ˜ì‹ : %s\nì œëª©: %s", to, subject),
                Metadata: map[string]interface{}{
                    "to":      to,
                    "cc":      cc,
                    "subject": subject,
                },
            },
        },
    }, nil
}

func (t *EmailTool) buildMessage(to string, cc []string, subject, body string) string {
    var msg strings.Builder
    
    msg.WriteString("From: " + t.fromAddr + "\r\n")
    msg.WriteString("To: " + to + "\r\n")
    
    if len(cc) > 0 {
        msg.WriteString("Cc: " + strings.Join(cc, ",") + "\r\n")
    }
    
    msg.WriteString("Subject: " + subject + "\r\n")
    msg.WriteString("MIME-Version: 1.0\r\n")
    msg.WriteString("Content-Type: text/plain; charset=UTF-8\r\n")
    msg.WriteString("\r\n")
    msg.WriteString(body)
    
    return msg.String()
}
```

## ë„êµ¬ í…ŒìŠ¤íŠ¸

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```go
// internal/tools/calculator_test.go
package tools

import (
    "context"
    "testing"
)

func TestCalculatorTool_Definition(t *testing.T) {
    tool := NewCalculatorTool()
    def := tool.Definition()
    
    if def.Name != "calculator" {
        t.Errorf("Expected name 'calculator', got '%s'", def.Name)
    }
    
    if def.InputSchema == nil {
        t.Error("InputSchema should not be nil")
    }
}

func TestCalculatorTool_Validate(t *testing.T) {
    tool := NewCalculatorTool()
    
    tests := []struct {
        name    string
        args    map[string]interface{}
        wantErr bool
    }{
        {
            name: "valid expression",
            args: map[string]interface{}{
                "expression": "2 + 3",
            },
            wantErr: false,
        },
        {
            name: "empty expression",
            args: map[string]interface{}{
                "expression": "",
            },
            wantErr: true,
        },
        {
            name: "invalid character",
            args: map[string]interface{}{
                "expression": "2 + 3; DROP TABLE users",
            },
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := tool.Validate(tt.args)
            if (err != nil) != tt.wantErr {
                t.Errorf("Validate() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}

func TestCalculatorTool_Execute(t *testing.T) {
    tool := NewCalculatorTool()
    ctx := context.Background()
    
    args := map[string]interface{}{
        "expression": "5",
    }
    
    result, err := tool.Execute(ctx, args)
    
    if err != nil {
        t.Fatalf("Execute() error = %v", err)
    }
    
    if result.IsError {
        t.Error("Expected successful result")
    }
    
    if len(result.Content) == 0 {
        t.Error("Expected non-empty content")
    }
}
```

### í†µí•© í…ŒìŠ¤íŠ¸

```go
// internal/tools/integration_test.go
package tools

import (
    "context"
    "testing"
    
    "mcp-server/internal/database"
)

func TestHybridSearchTool_Integration(t *testing.T) {
    // í…ŒìŠ¤íŠ¸ DB ì„¤ì •
    db := setupTestDB(t)
    defer db.Close()
    
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì‚½ì…
    tenantID := "test-tenant-123"
    doc := &database.Document{
        TenantID: tenantID,
        Title:    "Test Document",
        Content:  "Machine learning is awesome",
    }
    
    err := db.InsertDocument(context.Background(), doc)
    if err != nil {
        t.Fatalf("Failed to insert document: %v", err)
    }
    
    // ë„êµ¬ ìƒì„±
    tool := NewHybridSearchTool(db)
    
    // ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
    ctx := context.WithValue(context.Background(), "tenant_id", tenantID)
    
    // ê²€ìƒ‰ ì‹¤í–‰
    args := map[string]interface{}{
        "query": "machine learning",
        "limit": float64(10),
    }
    
    result, err := tool.Execute(ctx, args)
    
    if err != nil {
        t.Fatalf("Execute() error = %v", err)
    }
    
    if result.IsError {
        t.Errorf("Expected successful result, got error: %v", result.Content[0].Text)
    }
    
    // ê²°ê³¼ ê²€ì¦
    if len(result.Content) == 0 {
        t.Error("Expected non-empty results")
    }
    
    text := result.Content[0].Text
    if !strings.Contains(text, "Test Document") {
        t.Errorf("Expected to find 'Test Document' in results, got: %s", text)
    }
}
```

## ë„êµ¬ ë“±ë¡ ë° ì‚¬ìš©

### main.goì—ì„œ ë“±ë¡

```go
// cmd/server/main.go
func main() {
    // ... DB ì´ˆê¸°í™” ...
    
    // ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬ ìƒì„±
    toolRegistry := tools.NewRegistry()
    
    // ê¸°ë³¸ ë„êµ¬ ë“±ë¡
    toolRegistry.Register(tools.NewHybridSearchTool(db))
    toolRegistry.Register(tools.NewGetDocumentTool(db))
    toolRegistry.Register(tools.NewListDocumentsTool(db))
    
    // ì¶”ê°€ ë„êµ¬ ë“±ë¡
    toolRegistry.Register(tools.NewCalculatorTool())
    
    // ì¡°ê±´ë¶€ ë“±ë¡ (API í‚¤ ìˆì„ ë•Œë§Œ)
    if weatherAPIKey := os.Getenv("WEATHER_API_KEY"); weatherAPIKey != "" {
        toolRegistry.Register(tools.NewWeatherTool(weatherAPIKey))
        log.Println("âœ… Weather tool registered")
    }
    
    // ì´ë©”ì¼ ë„êµ¬ (SMTP ì„¤ì • ìˆì„ ë•Œë§Œ)
    if smtpHost := os.Getenv("SMTP_HOST"); smtpHost != "" {
        emailTool := tools.NewEmailTool(
            smtpHost,
            os.Getenv("SMTP_PORT"),
            os.Getenv("SMTP_USERNAME"),
            os.Getenv("SMTP_PASSWORD"),
            os.Getenv("FROM_EMAIL"),
        )
        toolRegistry.Register(emailTool)
        log.Println("âœ… Email tool registered")
    }
    
    log.Printf("âœ… Registered %d tools", toolRegistry.Count())
    
    // í•¸ë“¤ëŸ¬ ìƒì„±
    mcpHandler := handlers.NewMCPHandler(toolRegistry)
    
    // ... ì„œë²„ ì‹œì‘ ...
}
```

## ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 1. ì…ë ¥ ê²€ì¦

```go
// í•­ìƒ ì…ë ¥ì„ ê²€ì¦í•˜ì„¸ìš”
func (t *Tool) Validate(args map[string]interface{}) error {
    // SQL ì¸ì ì…˜ ë°©ì§€
    if strings.ContainsAny(input, "';\"") {
        return fmt.Errorf("invalid characters")
    }
    
    // ê²½ë¡œ íƒìƒ‰ ë°©ì§€
    if strings.Contains(filepath, "..") {
        return fmt.Errorf("path traversal not allowed")
    }
    
    // ìµœëŒ€ í¬ê¸° ì œí•œ
    if len(data) > MAX_SIZE {
        return fmt.Errorf("data too large")
    }
    
    return nil
}
```

### 2. ê¶Œí•œ ì²´í¬

```go
type AuthorizableTool struct {
    requiredRole string
}

func (t *AuthorizableTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    // ì‚¬ìš©ì ì—­í•  í™•ì¸
    userRole := ctx.Value("user_role").(string)
    
    if userRole != t.requiredRole {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: "ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤"},
            },
        }, nil
    }
    
    // ì‹¤ì œ ë¡œì§ ì‹¤í–‰
    // ...
}
```

### 3. Rate Limiting

```go
type RateLimitedTool struct {
    limiter *rate.Limiter
}

func (t *RateLimitedTool) Execute(ctx context.Context, args map[string]interface{}) (protocol.ToolCallResult, error) {
    // Rate limit ì²´í¬
    if !t.limiter.Allow() {
        return protocol.ToolCallResult{
            IsError: true,
            Content: []protocol.ContentBlock{
                {Type: "text", Text: "ìš”ì²­ í•œë„ ì´ˆê³¼"},
            },
        }, nil
    }
    
    // ì‹¤í–‰
    // ...
}
```

## í•µì‹¬ ìš”ì•½

### Tool ê°œë°œ ì²´í¬ë¦¬ìŠ¤íŠ¸

- âœ… **Definition**: ëª…í™•í•œ ì´ë¦„, ì„¤ëª…, JSON Schema
- âœ… **Validate**: ëª¨ë“  ì…ë ¥ ê²€ì¦
- âœ… **Execute**: ì—ëŸ¬ ì²˜ë¦¬, ê²°ê³¼ í¬ë§·íŒ…
- âœ… **Test**: ë‹¨ìœ„ + í†µí•© í…ŒìŠ¤íŠ¸
- âœ… **Security**: ê¶Œí•œ, Rate limit, ì…ë ¥ ê²€ì¦
- âœ… **Documentation**: ì‚¬ìš© ì˜ˆì œ

### JSON Schema í•„ìˆ˜ ìš”ì†Œ

- âœ… **type**: ë°ì´í„° íƒ€ì…
- âœ… **description**: ëª…í™•í•œ ì„¤ëª…
- âœ… **required**: í•„ìˆ˜ í•„ë“œ
- âœ… **default**: ê¸°ë³¸ê°’ (ì„ íƒì‚¬í•­)
- âœ… **enum**: í—ˆìš© ê°’ ëª©ë¡ (ì„ íƒì‚¬í•­)
- âœ… **validation**: min/max, pattern ë“±

### ì‹¤ë¬´ íŒ

```
DO:
âœ… ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€
âœ… ë©”íƒ€ë°ì´í„° í¬í•¨
âœ… íƒ€ì„ì•„ì›ƒ ì„¤ì •
âœ… êµ¬ì¡°í™”ëœ ë¡œê¹…

DON'T:
âŒ ë¯¼ê° ì •ë³´ ë…¸ì¶œ
âŒ ë¬´ì œí•œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
âŒ ê²€ì¦ ì—†ëŠ” ì…ë ¥
âŒ í•˜ë“œì½”ë”©ëœ ì„¤ì •
```

---

**ì°¸ê³  ìë£Œ**:
- JSON Schema: https://json-schema.org/
- MCP Spec: https://spec.modelcontextprotocol.io/
- Go Testing: https://go.dev/doc/tutorial/add-a-test

**ì‘ì„±ì¼**: 2024-12-13
