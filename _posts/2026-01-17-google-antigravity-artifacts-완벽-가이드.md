---
title: "Google Antigravity Artifacts 완벽 가이드"
date: 2026-01-17 15:00:00 +0900
categories: [AI,  Antigravity]
mermaid: [True]
tags: [AI,  Artifacts,  Collaboration,  ai-agent,  Claude.write]
---


## 목차
1. [개요](#개요)
2. [Artifacts의 핵심 개념](#artifacts의-핵심-개념)
3. [Artifacts의 종류와 특징](#artifacts의-종류와-특징)
4. [실전 활용 워크플로우](#실전-활용-워크플로우)
5. [피드백 및 협업 시스템](#피드백-및-협업-시스템)
6. [설정 및 정책 관리](#설정-및-정책-관리)
7. [실전 활용 팁](#실전-활용-팁)
8. [주의사항 및 제한사항](#주의사항-및-제한사항)

---

## 관련 영상

[**How to better understand, follow, and collaborate with the agent**](https://www.youtube.com/watch?v=eqLqAMDgL5U)

---

## 개요

Google Antigravity는 2025년 11월 18일 Gemini 3와 함께 발표된 에이전트 우선(Agent-first) 개발 플랫폼입니다. 기존의 AI 코딩 도구들이 단순히 코드 자동완성이나 채팅 기반 코드 생성에 머물렀다면, Antigravity는 개발자가 고차원적인 작업 지시를 내리면 AI 에이전트가 자율적으로 계획을 세우고, 코드를 작성하며, 테스트까지 수행하는 완전히 새로운 개발 패러다임을 제시합니다.

이러한 에이전트 중심 개발에서 가장 핵심적인 역할을 하는 것이 바로 **Artifacts**(아티팩트)입니다. Artifacts는 단순한 결과물이 아니라, AI 에이전트와 개발자 사이의 **"공유된 진실의 근거(Shared Source of Truth)"** 로 작동하며, 에이전트가 무엇을 하려고 하는지, 현재 어디까지 진행되었는지, 그리고 결과가 제대로 작동하는지를 명확하게 보여주는 동적인 커뮤니케이션 매개체입니다.

### Antigravity의 핵심 철학

전통적인 IDE에서는 개발자가 모든 코드를 직접 타이핑하고, 터미널 명령어를 실행하며, 브라우저에서 수동으로 테스트를 진행해야 했습니다. 그러나 Antigravity는 이러한 반복적이고 기계적인 작업들을 AI 에이전트에게 위임하고, 개발자는 **아키텍트(Architect)** 로서 고차원적인 의사결정과 검증에 집중할 수 있도록 설계되었습니다.

여기서 중요한 질문이 하나 생깁니다. "AI 에이전트가 자동으로 코드를 작성하고 실행한다면, 개발자는 어떻게 그 결과를 신뢰할 수 있을까?" 바로 이 **신뢰 격차(Trust Gap)** 를 해결하기 위해 Artifacts 시스템이 탄생했습니다.

---

## Artifacts의 핵심 개념

### Artifacts란 무엇인가?

Artifacts는 Google이 정의한 바에 따르면 **"에이전트의 의도(Intent)와 진행 상황(Progress)을 전달하기 위해 설계된 동적인 중간 매개체"** 입니다. 기존 AI 도구들이 긴 로그나 대화 기록으로 에이전트의 작업 과정을 보여주었다면, Antigravity는 구조화되고 시각화된 Artifacts를 통해 훨씬 더 명확하고 검증 가능한 형태로 정보를 제공합니다.

Artifacts는 단순히 보는 것에 그치지 않습니다. 개발자는 Artifacts 위에 직접 코멘트를 달고, 특정 부분을 드래그하여 선택한 뒤 정확한 피드백을 제공할 수 있습니다. 마치 Google Docs에서 문서에 댓글을 다는 것처럼 자연스럽고 직관적인 협업이 가능합니다.

### 왜 Artifacts가 중요한가?

AI 에이전트가 "버그를 수정했습니다"라고 말할 때, 과거에는 개발자가 직접 코드 전체를 읽고 변경사항을 확인해야 했습니다. 이는 시간이 많이 걸릴 뿐만 아니라, AI의 자율성을 제한하는 요인이 되었습니다. 개발자가 일일이 확인해야 한다면, 에이전트를 완전히 자율적으로 작동시킬 수 없기 때문입니다.

Antigravity의 Artifacts는 이 문제를 해결합니다. 에이전트는 작업을 수행하면서 **증거(Proof)** 를 함께 제공합니다. 구현 계획(Implementation Plan)을 통해 "무엇을 할 것인지" 미리 보여주고, 작업 목록(Task List)을 통해 "어디까지 진행되었는지" 실시간으로 체크하며, 스크린샷이나 브라우저 녹화를 통해 "실제로 작동하는지" 시각적으로 증명합니다.

이러한 투명성 덕분에 개발자는 에이전트를 더 신뢰할 수 있고, 결과적으로 더 많은 자율성을 부여할 수 있게 됩니다.

### Artifacts의 핵심 가치

1. **투명성(Transparency)**: 에이전트가 내부적으로 어떻게 조직화되어 있는지, 어떤 논리로 작업을 진행하는지 명확하게 볼 수 있습니다.

2. **검증 가능성(Verifiability)**: 단순히 "완료되었습니다"가 아니라, 실제로 작동하는 모습을 스크린샷과 영상으로 확인할 수 있습니다.

3. **상호작용성(Interactivity)**: 정적인 보고서가 아니라 개발자가 직접 피드백을 주고받을 수 있는 살아있는 문서입니다.

4. **비동기 협업(Asynchronous Collaboration)**: 에이전트가 작업을 멈출 필요 없이, 개발자는 원하는 타이밍에 피드백을 제공할 수 있습니다.

---

## Artifacts의 종류와 특징

Antigravity에서 생성되는 Artifacts는 크게 다섯 가지 주요 유형으로 나뉩니다. 각각은 개발 프로세스의 서로 다른 단계에서 생성되며, 명확한 목적과 역할을 가지고 있습니다.

### 1. 구현 계획 (Implementation Plan)

구현 계획은 에이전트가 **단 한 줄의 코드를 작성하기 전에** 생성하는 청사진입니다. 이는 프로젝트 매니저가 작성하는 기획서나 아키텍트가 그리는 설계도와 유사한 역할을 합니다.

**특징:**
- 에이전트가 어떤 파일을 수정할 것인지
- 각 파일에서 어떤 변경을 가할 것인지
- 전체 아키텍처가 어떻게 구성될 것인지
- 사용할 라이브러리나 프레임워크는 무엇인지

**실전 활용:**
복잡한 기능 추가나 리팩토링 작업을 요청했을 때, 구현 계획을 먼저 검토하면 에이전트가 잘못된 방향으로 가는 것을 사전에 차단할 수 있습니다. 예를 들어, "사용자 인증 기능을 추가해줘"라고 요청했는데 구현 계획을 보니 보안에 취약한 방식으로 설계되어 있다면, 코드 작성 전에 "JWT 토큰 기반으로 변경해줘"라고 피드백을 줄 수 있습니다.

**Planning 모드와의 관계:**
Antigravity에는 Planning 모드와 Fast 모드가 있습니다. Planning 모드를 선택하면 에이전트는 항상 구현 계획을 먼저 생성하고, 개발자의 검토를 받은 후 작업을 시작합니다. 복잡한 프로젝트일수록 Planning 모드를 권장합니다.

### 2. 작업 목록 (Task List)

작업 목록은 구현 계획이 승인된 후, 에이전트가 실제로 작업을 수행하는 동안 생성되는 실시간 체크리스트입니다.

**특징:**
- 구조화된 단계별 작업 항목
- 각 작업의 완료 여부를 실시간으로 체크
- 현재 진행 중인 작업 하이라이트
- 예상 소요 시간 정보 (일부 버전에서 지원)

**실전 활용:**
Task List를 통해 에이전트가 지금 무엇을 하고 있는지 한눈에 파악할 수 있습니다. 만약 에이전트가 특정 단계에서 오랫동안 멈춰있다면, 문제가 생긴 것일 수 있으므로 개입할 타이밍을 판단할 수 있습니다.

예를 들어:
```
✓ 프로젝트 구조 생성
✓ 의존성 패키지 설치
✓ API 엔드포인트 생성
⏳ 데이터베이스 마이그레이션 실행 (진행 중)
☐ 테스트 코드 작성
☐ 브라우저 검증
```

### 3. 워크스루 (Walkthrough)

워크스루는 작업이 완료된 후 생성되는 최종 보고서입니다. 이는 프로젝트 매니저에게 제출하는 완료 보고서와 유사하며, 무엇이 변경되었고 어떻게 검증되었는지를 상세히 기록합니다.

**특징:**
- 변경된 파일 목록과 변경 내용 요약
- 주요 의사결정 사항과 그 이유
- 발견된 이슈와 해결 방법
- 추가로 필요한 작업 제안

**실전 활용:**
워크스루 문서는 나중에 다른 팀원에게 인수인계하거나, 몇 달 후 자신이 다시 프로젝트를 볼 때 매우 유용합니다. 단순히 코드 변경사항만 보는 것이 아니라, "왜 이렇게 구현했는지"에 대한 맥락을 이해할 수 있습니다.

### 4. 스크린샷 (Screenshots)

에이전트가 브라우저를 통해 UI 변경사항을 검증할 때, 자동으로 스크린샷을 캡처합니다.

**특징:**
- 변경 전(Before)과 변경 후(After) 비교
- 특정 UI 요소에 대한 클로즈업
- 반응형 디자인 검증을 위한 다양한 화면 크기
- 에러 상태나 엣지 케이스 스크린샷

**실전 활용:**
UI 개발에서 특히 강력합니다. "로그인 버튼을 녹색으로 변경하고 크기를 키워줘"라고 요청하면, 에이전트가 코드를 수정하고 실제로 브라우저에서 확인한 후 스크린샷으로 결과를 보여줍니다. 개발자는 직접 브라우저를 열어볼 필요 없이 스크린샷만으로 변경사항을 확인할 수 있습니다.

**드래그 앤 셀렉트 피드백:**
스크린샷 위에서 특정 영역을 드래그하여 선택하고 "이 부분의 여백을 줄여줘"와 같이 정밀한 피드백을 줄 수 있습니다. 이는 디자이너와 개발자가 협업할 때 매우 유용합니다.

### 5. 브라우저 녹화 (Browser Recordings)

브라우저 녹화는 Antigravity만의 독특한 기능으로, 다른 AI 코딩 도구(Cursor, GitHub Copilot 등)에는 없는 차별화 포인트입니다.

**특징:**
- 에이전트가 브라우저를 실제로 조작하는 전체 과정 녹화
- 클릭, 스크롤, 폼 입력 등 동적 상호작용 기록
- 페이지 로딩, 애니메이션, 상태 전환 확인
- DevTools 콘솔 로그와 네트워크 요청 정보

**실전 활용:**
복잡한 사용자 플로우를 테스트할 때 매우 강력합니다. 예를 들어, "회원가입 플로우를 테스트해줘"라고 요청하면 에이전트가:
1. 회원가입 페이지로 이동
2. 이메일과 비밀번호 입력
3. 가입 버튼 클릭
4. 이메일 인증 페이지 로드 확인
5. 전체 과정을 영상으로 녹화

개발자는 이 영상을 보고 실제로 플로우가 잘 작동하는지, 중간에 깜빡임이나 오류가 없는지 확인할 수 있습니다.

**브라우저 서브에이전트 (Browser Subagent):**
브라우저 녹화는 `browser_subagent`라는 전용 도구가 실행될 때만 자동으로 수행됩니다. 에이전트가 "브라우저를 열어 확인해줘"라는 요청을 받거나, 스스로 웹페이지 테스트가 필요하다고 판단할 때 이 도구를 사용합니다. Chrome 확장 프로그램 설치가 필요하며, 에이전트가 브라우저를 제어하는 동안 파란색 테두리가 표시됩니다.

**녹화 파일 관리:**
녹화 파일은 로컬 경로(`~/.gemini/antigravity/`)에 저장되며, 용량이 꽤 크기 때문에 주기적인 관리가 필요합니다. 중요한 검증 영상만 별도로 백업하고 나머지는 삭제하는 것이 좋습니다.

### 6. 코드 차이 (Code Diffs)

기술적으로는 Artifact가 아니지만, Antigravity에서 매우 중요한 역할을 하므로 여기에 포함시킵니다.

**특징:**
- Git 스타일의 diff 뷰
- 줄 단위 변경사항 하이라이트
- 특정 코드 라인에 직접 코멘트 가능
- 변경 사유와 컨텍스트 정보

**실전 활용:**
코드 리뷰를 할 때와 동일한 방식으로 사용할 수 있습니다. 특정 코드 라인에 "이 부분은 에러 핸들링이 필요해"라고 코멘트를 달면, 에이전트가 해당 피드백을 반영하여 코드를 수정합니다.

---

## 실전 활용 워크플로우

Artifacts를 효과적으로 활용하는 전형적인 워크플로우는 다음과 같습니다. 이는 실제 프로젝트 개발 과정을 단계별로 설명한 것입니다.

### 1단계: 작업 정의 및 계획 검토

**개발자의 요청:**
```
"Next.js로 항공편 조회 앱을 만들어줘. 
Mock API를 사용하고, 날짜별로 항공편을 검색할 수 있어야 해. 
TailwindCSS로 스타일링하고, TypeScript를 사용해줘."
```

**에이전트의 동작 (Planning 모드):**
1. 먼저 구현 계획(Implementation Plan) Artifact를 생성합니다.
2. Inbox에 알림이 전송되고, 개발자에게 검토를 요청합니다.

**구현 계획 내용 예시:**
```markdown
# 항공편 조회 앱 구현 계획

## 프로젝트 구조
- /app: Next.js 14 App Router 기반
- /components: 재사용 가능한 React 컴포넌트
- /lib: API 호출 및 유틸리티 함수
- /types: TypeScript 타입 정의

## 주요 컴포넌트
1. FlightSearchForm: 출발지, 도착지, 날짜 입력
2. FlightList: 검색 결과 리스트
3. FlightCard: 개별 항공편 정보 카드

## 기술 스택
- Next.js 14 (App Router)
- TypeScript
- TailwindCSS
- Mock API (JSON 파일 기반)

## 구현 순서
1. 프로젝트 초기 설정 및 의존성 설치
2. Mock API 데이터 생성
3. 컴포넌트 개발
4. 스타일링
5. 브라우저 테스트
```

**개발자의 검토와 피드백:**
개발자는 구현 계획을 읽고 다음과 같이 피드백을 줄 수 있습니다:
- "Mock API 대신 실제 API를 연동하고 싶어. OpenSky Network API를 사용해줘."
- "달력 UI는 react-datepicker 라이브러리를 사용해줘."
- "승인합니다. 진행해주세요."

### 2단계: 작업 실행 및 실시간 모니터링

구현 계획이 승인되면, 에이전트는 Task List Artifact를 생성하고 작업을 시작합니다.

**Task List 예시:**
```
프로젝트 초기 설정
✓ Next.js 프로젝트 생성
✓ TypeScript 설정
✓ TailwindCSS 설치 및 설정
✓ 필요한 의존성 패키지 설치

API 및 데이터 레이어
✓ API 유틸리티 함수 작성
✓ TypeScript 타입 정의
⏳ OpenSky Network API 통합 (진행 중)

컴포넌트 개발
☐ FlightSearchForm 구현
☐ FlightList 구현
☐ FlightCard 구현

스타일링 및 레이아웃
☐ 반응형 레이아웃 구현
☐ 로딩 상태 UI
☐ 에러 처리 UI

테스트 및 검증
☐ 로컬 개발 서버 실행
☐ 브라우저 기능 테스트
☐ 최종 워크스루 작성
```

**비동기 피드백:**
에이전트가 작업을 진행하는 동안, 개발자는 다른 일을 하다가도 언제든지 Task List를 확인하고 진행 상황을 파악할 수 있습니다. 만약 특정 단계에서 문제가 생겼다고 판단되면, 작업을 멈추지 않고도 피드백을 남길 수 있습니다.

### 3단계: 중간 검증 및 UI 확인

에이전트가 컴포넌트 개발을 완료하면, 자동으로 브라우저를 실행하고 스크린샷을 캡처합니다.

**스크린샷 Artifact:**
- 초기 화면 (검색 폼만 보이는 상태)
- 검색어 입력 후 상태
- 검색 결과 리스트
- 반응형 디자인 (모바일 뷰)

**개발자의 피드백:**
스크린샷에서 "항공편 카드의 여백이 너무 넓어 보여"라고 드래그 선택 후 코멘트를 남기면, 에이전트가 즉시 TailwindCSS 클래스를 조정합니다.

### 4단계: 동적 테스트 및 검증

에이전트는 브라우저 서브에이전트를 활용하여 실제 사용자 플로우를 시뮬레이션하고 녹화합니다.

**브라우저 녹화 시나리오:**
1. 페이지 로드
2. 출발지 입력 (예: "Incheon")
3. 도착지 입력 (예: "San Francisco")
4. 날짜 선택
5. 검색 버튼 클릭
6. 로딩 스피너 확인
7. 검색 결과 렌더링 확인
8. 개별 항공편 카드 클릭
9. 상세 정보 모달 확인

**검증 포인트:**
- API 호출이 제대로 이루어지는가?
- 로딩 상태가 올바르게 표시되는가?
- 에러 처리가 적절한가?
- UI 애니메이션이 부드러운가?

### 5단계: 최종 워크스루 및 완료

모든 작업이 완료되면, 에이전트는 Walkthrough Artifact를 생성합니다.

**Walkthrough 내용 예시:**
```markdown
# 항공편 조회 앱 개발 완료 보고

## 구현된 기능
✓ Next.js 14 App Router 기반 프로젝트 구조
✓ TypeScript 전면 적용
✓ TailwindCSS를 활용한 반응형 디자인
✓ OpenSky Network API 실시간 연동
✓ react-datepicker를 활용한 날짜 선택
✓ 로딩 및 에러 상태 처리

## 변경된 파일
- app/page.tsx (메인 페이지)
- components/FlightSearchForm.tsx
- components/FlightList.tsx
- components/FlightCard.tsx
- lib/api.ts (API 호출 함수)
- types/flight.ts (타입 정의)

## 테스트 결과
✓ 검색 기능 정상 작동
✓ API 응답 처리 확인
✓ 반응형 디자인 검증 (데스크톱, 태블릿, 모바일)
✓ 에러 처리 시나리오 테스트 완료

## 추가 권장사항
- 검색 결과 캐싱 구현 (React Query 추천)
- 즐겨찾기 기능 추가
- 가격 비교 기능 확장
- E2E 테스트 추가 (Playwright)
```

**개발자의 최종 검토:**
Walkthrough를 읽고, 스크린샷과 브라우저 녹화를 확인한 후, 만족스러우면 승인하고 다음 단계로 넘어갑니다.

---

## 피드백 및 협업 시스템

Antigravity의 Artifacts가 다른 AI 도구와 가장 크게 차별화되는 부분이 바로 피드백 시스템입니다. 단순히 결과물을 보여주는 것이 아니라, 개발자가 적극적으로 개입하고 에이전트의 방향을 조정(Steering)할 수 있습니다.

### Google Docs 스타일 코멘트

Artifacts는 Google Docs와 유사한 코멘트 시스템을 제공합니다. 텍스트 기반 Artifact(구현 계획, 워크스루 등)에서는 특정 문장이나 섹션을 선택하고 코멘트를 달 수 있습니다.

**예시 시나리오:**
구현 계획에 "Redis를 캐싱 레이어로 사용"이라고 적혀있을 때:
1. "Redis를 캐싱 레이어로 사용" 텍스트를 선택
2. 코멘트 아이콘 클릭
3. "Redis 대신 메모리 캐시를 먼저 사용하고, 나중에 확장하자" 입력
4. 제출

에이전트는 이 피드백을 읽고 구현 계획을 수정한 후, 업데이트된 버전을 다시 제시합니다.

### 드래그 앤 셀렉트 피드백

이미지 기반 Artifact(스크린샷)에서는 드래그하여 특정 영역을 선택하고 피드백을 줄 수 있습니다.

**실전 활용:**
1. 스크린샷에서 헤더 부분을 드래그하여 선택
2. 코멘트 창에 "헤더 높이를 64px에서 80px로 늘려줘" 입력
3. 제출

에이전트는 해당 영역에 대한 CSS 코드를 찾아 수정하고, 다시 브라우저에서 확인한 후 새로운 스크린샷을 제공합니다.

**정밀도:**
이 방식의 장점은 **정밀한 피드백**이 가능하다는 것입니다. "버튼이 좀 작아 보여"라는 모호한 피드백 대신, 정확히 어느 버튼을 말하는지 시각적으로 지정할 수 있습니다.

### 코드 라인 코멘트

코드 차이(Diff) 뷰에서는 특정 코드 라인에 직접 코멘트를 달 수 있습니다.

**예시:**
```typescript
// 에이전트가 작성한 코드
const fetchFlights = async (from: string, to: string) => {
  const response = await fetch(`/api/flights?from=${from}&to=${to}`);
  return response.json(); // 👈 여기에 코멘트: "에러 처리 추가해줘"
};
```

코멘트를 받은 에이전트는 다음과 같이 수정합니다:
```typescript
const fetchFlights = async (from: string, to: string) => {
  try {
    const response = await fetch(`/api/flights?from=${from}&to=${to}`);
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    return response.json();
  } catch (error) {
    console.error('Failed to fetch flights:', error);
    throw error;
  }
};
```

### 비동기 피드백의 장점

Antigravity의 피드백 시스템은 **비동기적(Asynchronous)**으로 작동합니다. 이것이 무엇을 의미하는지 이해하는 것이 중요합니다.

**기존 동기식 방식:**
- 개발자: "이 부분 수정해줘"
- AI: (작업 중단, 수정, 완료 대기)
- 개발자: (결과 확인 후) "이제 다음 단계 진행해줘"

**Antigravity 비동기 방식:**
- 개발자: (Artifact에 피드백 남김)
- AI: (현재 작업 계속 진행)
- AI: (적절한 시점에 피드백 확인 및 반영)
- 개발자: (다른 일 하다가) "아, Inbox에 알림 왔네. 확인해보자"

이 방식의 장점은 **흐름이 끊기지 않는다**는 것입니다. 에이전트는 자율적으로 작업을 진행하고, 개발자는 원하는 타이밍에 개입할 수 있습니다. 마치 팀원에게 "나중에 시간 날 때 이 부분 확인해줘"라고 슬랙 메시지를 남기는 것과 유사합니다.

### Inbox 시스템

Antigravity의 Inbox는 에이전트와 개발자 사이의 비동기 커뮤니케이션 허브입니다.

**Inbox에 나타나는 것들:**
- 에이전트의 승인 요청 (예: "구현 계획을 검토해주세요")
- 에이전트의 질문 (예: "API 키를 어디서 가져와야 하나요?")
- 에이전트의 완료 보고 (예: "테스트가 완료되었습니다")
- 개발자의 피드백에 대한 에이전트의 응답

**실전 활용:**
하루에 여러 프로젝트를 동시에 진행할 때, Inbox를 통해 각 에이전트의 상태를 한눈에 파악할 수 있습니다. "Pending" 필터를 사용하면 승인이 필요한 항목만 빠르게 확인할 수 있습니다.

### 에이전트 학습 (Agent Memory)

Antigravity의 에이전트는 개발자와의 상호작용을 통해 학습합니다. 피드백을 받을 때마다 내부 지식 베이스(Internal Knowledge Base)에 정보를 축적합니다.

**학습 내용:**
- 명시적 정보: 유용한 코드 스니펫, 아키텍처 패턴, 선호하는 라이브러리
- 암묵적 정보: 개발자의 코딩 스타일, 네이밍 컨벤션, 에러 처리 방식

**실전 예시:**
처음에는 "버튼 컴포넌트 만들어줘"라고 하면 일반적인 코드를 생성하지만, 여러 번 피드백을 주고받은 후에는 개발자가 선호하는 스타일(예: Radix UI 기반, 다크모드 지원, 접근성 속성 포함)을 자동으로 적용합니다.

---

## 설정 및 정책 관리

Antigravity는 에이전트의 자율성 수준을 세밀하게 조정할 수 있는 설정 시스템을 제공합니다. 이를 통해 프로젝트의 성격과 개발자의 선호도에 맞게 에이전트를 커스터마이징할 수 있습니다.

### 개발 모드 선택

Antigravity는 초기 설정 시 네 가지 개발 모드를 제시합니다.

**1. Agent-driven Development (에이전트 주도)**
- 에이전트가 거의 모든 결정을 독자적으로 내립니다.
- 터미널 명령어를 자동으로 실행하고, Artifact 검토 없이 진행합니다.
- 간단하고 반복적인 작업, 프로토타이핑에 적합합니다.

**언제 사용하나요?**
- "빠르게 MVP를 만들고 싶을 때"
- "새로운 기술 스택을 실험할 때"
- "중요하지 않은 내부 도구를 개발할 때"

**주의사항:**
- 보안이 중요한 프로젝트에는 부적합
- 에이전트가 실수로 중요한 파일을 삭제할 수 있음
- 예상치 못한 비용 발생 가능 (API 과다 호출 등)

**2. Agent-assisted Development (에이전트 보조) [권장]**
- 에이전트가 계획을 세우고 개발자가 승인하면 실행합니다.
- 중요한 결정에 대해서는 개발자에게 확인을 요청합니다.
- 균형 잡힌 접근 방식으로, 대부분의 프로젝트에 적합합니다.

**언제 사용하나요?**
- "생산성은 높이되 통제력은 유지하고 싶을 때"
- "실제 프로덕션 코드를 개발할 때"
- "팀 프로젝트에서 다른 사람과 협업할 때"

**장점:**
- 에이전트의 효율성과 개발자의 판단력을 조화롭게 결합
- 대부분의 반복 작업은 자동화하되, 중요한 순간에는 사람이 개입
- 학습 곡선이 완만함

**3. Review-driven Development (검토 주도)**
- 에이전트가 거의 모든 작업에 대해 승인을 요청합니다.
- 터미널 명령어 실행, 파일 수정, API 호출 등 모든 단계에서 확인이 필요합니다.
- 보안이 중요하거나 학습 목적으로 사용할 때 적합합니다.

**언제 사용하나요?**
- "Antigravity를 처음 배우는 단계"
- "금융, 의료 등 민감한 데이터를 다룰 때"
- "에이전트가 어떻게 작동하는지 자세히 관찰하고 싶을 때"

**단점:**
- 매우 느리고 번거로움
- 에이전트의 자율성이 크게 제한됨
- 생산성 향상 효과가 미미함

**4. Custom (사용자 정의)**
- 모든 설정을 직접 세밀하게 조정합니다.
- Terminal Policy, Artifact Review Policy, Browser Policy 등을 개별적으로 설정합니다.
- 고급 사용자나 특수한 요구사항이 있을 때 사용합니다.

### Artifact Review Policy (아티팩트 검토 정책)

에이전트가 Artifact를 생성했을 때, 개발자의 검토를 언제 요청할지 결정하는 정책입니다.

**Always Review (항상 검토)**
- 모든 Artifact(구현 계획, 워크스루 등)에 대해 검토를 요청합니다.
- 개발자가 승인하기 전까지 다음 단계로 진행하지 않습니다.

**Agent Decides (에이전트 판단)**
- 에이전트가 Artifact의 중요도를 판단하여 검토 필요 여부를 결정합니다.
- 간단한 변경은 자동으로 진행하고, 중요한 변경만 검토를 요청합니다.

**Always Proceed (항상 진행)**
- 검토 없이 모든 Artifact를 자동으로 승인하고 다음 단계로 진행합니다.
- 빠른 프로토타이핑에 적합하지만 위험할 수 있습니다.

**권장 설정:**
대부분의 경우 "Agent Decides"를 권장합니다. 이는 에이전트에게 적절한 자율성을 부여하면서도, 중요한 순간에는 사람의 판단을 요구하기 때문입니다.

### Terminal Command Auto Execution Policy (터미널 명령어 자동 실행 정책)

에이전트가 터미널에서 명령어를 실행할 때의 정책입니다.

**Always Proceed (항상 실행)**
- `npm install`, `npm run dev` 같은 안전한 명령어를 자동으로 실행합니다.
- Deny List에 등록된 위험한 명령어(`rm -rf /`, `sudo` 등)만 차단합니다.

**Request Review (검토 요청)**
- 모든 터미널 명령어 실행 전에 개발자에게 확인을 요청합니다.
- 보안이 매우 중요한 환경에서 사용합니다.

**주의사항:**
Antigravity 에이전트는 때때로 위험한 명령어를 실수로 실행할 수 있습니다. 예를 들어, 파일 정리를 요청했을 때 `rm -rf /`처럼 치명적인 명령어를 사용할 수 있습니다. 따라서 처음 설정 시 `.scratch` 폴더 외에는 파일 접근을 차단하는 것이 기본 설정으로 지정되어 있습니다.

**권장 설정:**
- 로컬 개발 환경: Always Proceed + Deny List
- 프로덕션 서버: Request Review
- 학습 목적: Request Review

### Browser Policy (브라우저 정책)

에이전트가 브라우저 서브에이전트를 사용하여 웹페이지를 제어할 때의 정책입니다.

**허용 리스트 (Allow List)**
- 에이전트가 접근할 수 있는 도메인을 명시적으로 지정합니다.
- 예: `localhost`, `example.com`, `api.github.com`

**차단 리스트 (Deny List)**
- 에이전트가 절대 접근하지 못하도록 차단하는 도메인입니다.
- 예: 결제 시스템, 프로덕션 데이터베이스, 민감한 내부 도구

**실전 활용:**
개발 환경에서는 `localhost`와 스테이징 서버만 허용하고, 프로덕션 URL은 차단하는 것이 안전합니다.

### MCP Servers 설정

MCP(Model Context Protocol) Servers를 통해 에이전트가 외부 데이터소스에 접근할 수 있도록 설정할 수 있습니다.

**설정 방법:**
1. Agent Manager 우측 상단의 `...` 클릭
2. "MCP Servers" 선택
3. 사용할 서버 추가 (예: FireCrawl, Supabase, Google Drive)

**OAuth 인증:**
Google Workspace API를 사용하려면 OAuth 자격 증명을 설정해야 합니다. 이를 통해 에이전트가 Drive, Docs, Calendar 등에 접근할 수 있습니다.

**권한 관리 (Least Privilege Principle):**
필요한 최소한의 권한만 부여하는 것이 중요합니다. 예를 들어, 에이전트가 Google Drive에서 문서를 읽기만 하면 되는 경우, 읽기 전용 권한만 부여합니다.

---

## 실전 활용 팁

Antigravity와 Artifacts를 효과적으로 활용하기 위한 실전 노하우를 소개합니다.

### 1. Planning 모드 vs Fast 모드 선택

**Planning 모드를 사용해야 할 때:**
- 복잡한 아키텍처 변경
- 새로운 기능 추가
- 리팩토링
- 여러 파일에 걸친 수정
- 데이터베이스 마이그레이션

**Fast 모드를 사용해야 할 때:**
- 간단한 버그 수정
- 스타일 조정
- 텍스트 변경
- 단일 파일 수정
- 급하게 프로토타입이 필요할 때

**실전 조언:**
프로젝트 초반에는 Planning 모드로 시작하여 전체 구조를 잡고, 이후 세부 조정은 Fast 모드로 빠르게 진행하는 것이 효율적입니다.

### 2. 명확한 프롬프트 작성

에이전트가 좋은 구현 계획을 세우려면 명확한 요구사항이 필요합니다.

**나쁜 예:**
```
"쇼핑몰 앱 만들어줘"
```

**좋은 예:**
```
"Next.js로 전자상거래 플랫폼을 만들어줘.
- Stripe 결제 연동
- Supabase로 데이터베이스 및 인증 처리
- TailwindCSS와 shadcn/ui로 UI 구성
- 관리자 대시보드 포함
- 상품 검색 및 필터링 기능
- 장바구니 및 주문 내역 관리"
```

**핵심 요소:**
1. 기술 스택 명시
2. 주요 기능 나열
3. 외부 서비스 연동 명시
4. UI/UX 요구사항
5. 비기능 요구사항 (성능, 보안 등)

### 3. 단계별 검증

모든 것을 한 번에 요청하기보다는, 단계별로 나누어 검증하는 것이 좋습니다.

**단계적 접근:**
1. "프로젝트 초기 설정만 해줘" → 검증
2. "인증 시스템을 구현해줘" → 검증
3. "상품 목록 페이지를 만들어줘" → 검증
4. "결제 시스템을 연동해줘" → 검증

이렇게 하면 문제가 생겼을 때 어느 단계에서 잘못되었는지 쉽게 파악할 수 있고, 롤백도 간단합니다.

### 4. 스크린샷에 주석 활용

UI 관련 피드백을 줄 때는 드래그 선택과 함께 구체적인 수치를 제공하는 것이 좋습니다.

**예시:**
- "이 버튼의 패딩을 px-4 py-2에서 px-6 py-3으로 변경"
- "헤더 높이를 64px로 고정"
- "카드 간 간격을 gap-4에서 gap-6으로 증가"

### 5. 브라우저 녹화 활용

복잡한 사용자 플로우는 직접 설명하기보다 에이전트가 녹화한 영상을 확인하는 것이 효율적입니다.

**활용 시나리오:**
- "회원가입부터 첫 구매까지 전체 플로우를 테스트하고 녹화해줘"
- "모바일 환경에서 결제 과정을 시뮬레이션하고 녹화해줘"
- "에러 발생 시나리오를 재현하고 녹화해줘"

### 6. Workspace 분리

여러 프로젝트를 동시에 진행할 때는 Workspace를 분리하여 관리합니다.

**Workspace 활용:**
- 각 프로젝트마다 별도의 Workspace 생성
- Playground Workspace로 실험적인 기능 테스트
- 프로젝트별로 다른 모델 사용 (예: 프로토타입은 Gemini 3 Flash, 프로덕션은 Gemini 3 Pro High)

### 7. Git 통합

Antigravity는 Git 통합을 지원하므로, 에이전트가 생성한 코드를 즉시 커밋할 수 있습니다.

**권장 워크플로우:**
1. 에이전트가 기능 구현 완료
2. 개발자가 코드 리뷰 (Code Diff 확인)
3. 문제 없으면 Git 커밋
4. 문제 있으면 피드백 후 수정
5. 최종 검증 후 푸시

**주의사항:**
에이전트가 실수로 잘못된 코드를 커밋할 수 있으므로, 자동 커밋 설정은 신중하게 사용해야 합니다.

### 8. Nano Banana Pro 활용

Nano Banana Pro는 Antigravity에 통합된 AI 이미지 생성 도구입니다.

**활용 방법:**
1. "웹사이트에 히어로 섹션 이미지를 생성해줘. 주제는 우주 탐험"
2. 에이전트가 Nano Banana Pro를 사용하여 이미지 생성
3. 생성된 이미지를 자동으로 프로젝트에 포함

**실전 팁:**
- 프로토타입 단계에서 빠르게 비주얼을 채울 때 유용
- 유료 계정 필요 (무료는 제한적)

### 9. Rules & Workflows 설정

반복적인 작업을 자동화하기 위해 Rules와 Workflows를 설정할 수 있습니다.

**예시 Rule:**
```markdown
모든 코드는 PEP 8 스타일 가이드 준수
모든 함수에 한글 주석 작성 필수
main.py는 진입점만, 기능은 별도 파일로 분리
```

**예시 Workflow:**
```
/유닛테스트생성
→ 현재 파일에 대한 유닛 테스트 자동 생성
→ pytest 프레임워크 사용
→ 커버리지 80% 이상 목표
```

### 10. 멀티모델 전략

Antigravity는 여러 모델을 지원하므로, 작업 특성에 따라 모델을 전환할 수 있습니다.

**모델 선택 가이드:**
- **Gemini 3 Pro (High)**: 복잡한 아키텍처, 중요한 비즈니스 로직
- **Gemini 3 Pro (Low)**: 일반적인 기능 개발, 균형 잡힌 성능
- **Gemini 3 Flash**: 간단한 수정, 빠른 프로토타이핑
- **Claude Sonnet 4.5**: 코드 품질이 중요한 프로젝트
- **Claude Sonnet 4.5 (Thinking)**: 복잡한 알고리즘, 최적화 문제
- **Claude Opus 4.5**: 최고 수준의 코드 품질, 아키텍처 설계
- **GPT-OSS 120B (Medium)**: 오픈소스 프로젝트, 커뮤니티 기여

---

## 주의사항 및 제한사항

Antigravity와 Artifacts를 사용할 때 주의해야 할 점들을 정리했습니다.

### 1. 토큰 사용량 제한

Antigravity는 현재 무료 프리뷰 단계이지만, 사용량 제한이 있습니다.

**제한사항:**
- 정확한 사용 횟수는 공개되지 않음
- 제한에 걸리면 5시간마다 초기화
- Google AI Pro 또는 AI Ultra 구독자는 더 높은 한도

**대응 방법:**
- 복잡한 작업은 한꺼번에 요청하지 말고 단계별로 나누기
- Fast 모드를 남용하지 않기 (Planning 모드가 더 효율적일 수 있음)
- 간단한 작업은 직접 코딩하는 것이 나을 수 있음

**에러 메시지:**
```
Agent execution terminated due to model provider overload.
Please try again in 5 hours.
```

### 2. 파일 시스템 접근 제한

에이전트가 실수로 중요한 파일을 삭제하는 것을 방지하기 위해, 기본적으로 `.scratch` 폴더 외에는 파일 접근이 제한됩니다.

**설정 변경:**
Antigravity Settings에서 허용 경로를 추가할 수 있지만, 신중하게 설정해야 합니다.

**권장사항:**
- 중요한 프로젝트는 Git으로 버전 관리
- 정기적으로 백업
- 가상 환경에서 테스트

### 3. 브라우저 녹화 파일 용량

브라우저 녹화 파일은 용량이 크므로 주기적인 관리가 필요합니다.

**저장 위치:**
- macOS/Linux: `~/.gemini/antigravity/`
- Windows: `C:\Users\[사용자명]\.gemini\antigravity\`

**관리 팁:**
- 중요한 녹화만 별도로 백업
- 오래된 녹화는 정기적으로 삭제
- 프로젝트별로 폴더 구조 정리

### 4. 네트워크 보안

에이전트가 외부 API를 호출하거나 브라우저로 웹페이지에 접근할 때 보안에 주의해야 합니다.

**주의사항:**
- API 키를 코드에 직접 하드코딩하지 말 것
- 환경 변수나 `.env` 파일 사용
- `.env` 파일을 `.gitignore`에 추가
- 민감한 데이터를 다룰 때는 Review-driven 모드 사용

### 5. 모델별 특성 이해

각 모델마다 강점과 약점이 다릅니다.

**Gemini 3 Pro:**
- 빠르고 효율적
- Google 생태계와 잘 통합
- 때때로 과도하게 낙관적인 구현 계획

**Claude Sonnet 4.5:**
- 높은 코드 품질
- 상세한 주석과 문서화
- Gemini보다 느릴 수 있음

**GPT-OSS:**
- 오픈소스 친화적
- 커뮤니티 베스트 프랙티스 반영
- 상업 프로젝트에는 라이선스 확인 필요

### 6. 한국어 프롬프트 지원

Antigravity는 한국어 프롬프트를 완벽하게 이해하지만, 기술 용어는 영어로 사용하는 것이 더 정확합니다.

**권장 방식:**
```
"간단한 테트리스 게임을 Python으로 만들어줘. 
Pygame 라이브러리 사용하고, 키보드로 조작 가능하게 해줘."
```

### 7. Artifacts 저장 및 공유

Artifacts는 프로젝트 내부에만 저장되며, 현재는 별도의 내보내기 기능이 제한적입니다.

**대응 방법:**
- 중요한 구현 계획이나 워크스루는 별도로 복사하여 문서화
- 스크린샷은 직접 저장
- 브라우저 녹화는 별도로 백업

### 8. 버전 호환성

Antigravity는 현재 프리뷰 단계이므로 빈번한 업데이트가 있을 수 있습니다.

**권장사항:**
- 중요한 프로젝트 작업 전 버전 확인
- 릴리스 노트 읽기
- 주요 업데이트 후에는 테스트부터 진행

### 9. 확장 프로그램 호환성

Antigravity는 VS Code 기반이지만, VS Code Marketplace 대신 OpenVSX를 사용합니다.

**주의사항:**
- 모든 VS Code 확장이 지원되는 것은 아님
- 수동으로 VSIX 파일 설치가 필요할 수 있음
- 공급망 보안 위험 (확장 출처 확인 필요)

### 10. 데이터 프라이버시

에이전트는 Google 서버와 통신하므로 민감한 정보 처리 시 주의가 필요합니다.

**권장사항:**
- 민감한 데이터는 로컬에서만 처리
- 필요시 자체 호스팅 모델 사용 고려
- 회사 정책 확인 (일부 기업은 AI 도구 사용 제한)

---

## 마치며

Google Antigravity의 Artifacts 시스템은 AI 에이전트 개발의 새로운 패러다임을 제시합니다. 단순히 코드를 자동 생성하는 것을 넘어서, 에이전트와 개발자가 **투명하게 협업**할 수 있는 환경을 구축했습니다.

핵심은 **신뢰(Trust)**입니다. Artifacts를 통해 에이전트는 자신의 의도와 진행 상황을 명확히 보여주고, 개발자는 그 결과를 검증할 수 있습니다. 이러한 투명성 덕분에 개발자는 에이전트에게 더 많은 자율성을 부여할 수 있고, 결과적으로 생산성이 크게 향상됩니다.

물론 Antigravity는 아직 프리뷰 단계이며, 완벽하지 않습니다. 때때로 에이전트가 실수를 하거나, 예상치 못한 동작을 할 수 있습니다. 그러나 Artifacts 시스템이 있기에, 이러한 문제들을 빠르게 발견하고 수정할 수 있습니다.

앞으로 Antigravity와 Artifacts는 더욱 발전할 것입니다. Google은 이미 더 풍부한 형태의 Artifacts와 다양한 피드백 방식을 개발 중이라고 밝혔습니다. 지금이야말로 이 혁신적인 도구를 배우고 익힐 최적의 시기입니다.

**시작하는 방법:**
1. https://antigravity.google 에서 다운로드
2. Agent-assisted 모드로 시작
3. 간단한 프로젝트로 실험
4. Artifacts를 꼼꼼히 검토하는 습관 기르기
5. 점진적으로 에이전트에게 더 많은 자율성 부여

이 가이드가 Google Antigravity의 Artifacts를 이해하고 효과적으로 활용하는 데 도움이 되기를 바랍니다. 새로운 AI 개발 시대를 함께 경험해봅시다!

---

**작성 일자: 2026-01-17**
