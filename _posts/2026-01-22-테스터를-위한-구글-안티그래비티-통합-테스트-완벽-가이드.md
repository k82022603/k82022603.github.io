---
title: "테스터를 위한 구글 안티그래비티 통합 테스트 완벽 가이드"
date: 2026-01-22 20:20:00 +0900
categories: [AI,  Antigravity]
mermaid: [True]
tags: [AI,  Antigravity,  integration-test,  Guide,  Claude.write]
---

## Workflow 활용 중심

---

## 서론: 코딩 없이 만드는 전문가급 통합 테스트

"테스트 자동화는 개발자만 할 수 있다." 이 오래된 편견은 2026년 현재, 구글 안티그래비티(Google Antigravity)의 등장으로 완전히 깨지고 있다. 안티그래비티는 테스터가 코드 한 줄 작성하지 않고도, 자연어로 복잡한 통합 테스트를 설계하고 실행할 수 있게 해주는 혁명적인 플랫폼이다.

통합 테스트(Integration Testing)는 개별 컴포넌트들이 함께 작동할 때 제대로 기능하는지 검증하는 과정이다. 로그인 → 상품 검색 → 장바구니 추가 → 결제라는 전체 사용자 플로우가 끊김 없이 작동하는가? 프론트엔드와 백엔드 API가 올바르게 통신하는가? 이런 질문들에 답하는 것이 통합 테스트의 핵심이다.

기존에는 Selenium이나 Cypress 같은 도구로 복잡한 스크립트를 작성해야 했다. `cy.get('#user-email').type('test@example.com')` 같은 코드를 수백 줄 작성하고, 셀렉터가 바뀔 때마다 수동으로 수정해야 했다. 하지만 안티그래비티는 다르다. "로그인 페이지에서 유효하지 않은 이메일로 로그인 시도하면 적절한 에러 메시지가 표시되는지 확인해줘"라고 자연어로 요청하면, AI 에이전트가 알아서 테스트를 작성하고 실행하고 결과를 보고한다.

이 가이드는 테스터 관점에서 안티그래비티의 Workflow 시스템을 중심으로, 반복 가능하고 유지보수하기 쉬운 통합 테스트를 만드는 실전 방법을 제시한다.

## 통합 테스트 vs 단위 테스트 vs E2E 테스트

### 테스팅 피라미드 이해하기

효과적인 테스트 전략을 수립하려면 먼저 각 테스트 레벨의 차이를 이해해야 한다.

**단위 테스트(Unit Testing)** 는 가장 작은 단위의 코드 조각(함수, 클래스, 컴포넌트)을 독립적으로 검증한다. "로그인 버튼 컴포넌트가 올바른 props를 받으면 올바르게 렌더링되는가?"를 테스트한다. 빠르고 많이 작성하지만, 실제 사용자 경험과는 거리가 있다.

**통합 테스트(Integration Testing)** 는 여러 컴포넌트나 서비스가 함께 작동할 때를 검증한다. "로그인 폼이 인증 서비스와 통신해서 사용자 세션을 올바르게 생성하는가?"를 테스트한다. 실제 사용자 플로우와 가깝지만, 전체 시스템은 아니다.

**E2E 테스트(End-to-End Testing)** 는 사용자가 실제로 경험하는 전체 플로우를 처음부터 끝까지 검증한다. "사용자가 회원가입부터 첫 구매까지 완료할 수 있는가?"를 실제 브라우저에서 테스트한다. 가장 신뢰도가 높지만, 느리고 유지보수가 어렵다.

**안티그래비티가 빛나는 영역**은 바로 통합 테스트와 E2E 테스트다. Browser Agent가 실제 브라우저를 제어하면서 다양한 서비스들의 상호작용을 검증할 수 있고, 테스터는 코드 없이 자연어로 복잡한 시나리오를 표현할 수 있다.

### 통합 테스트가 중요한 이유

실제 버그의 대부분은 경계(boundary)에서 발생한다. 프론트엔드는 완벽하게 작동하고, 백엔드도 완벽하게 작동하지만, 둘이 통신할 때 데이터 형식이 맞지 않아 오류가 발생하는 경우가 흔하다.

예를 들어:
- 프론트엔드는 날짜를 "YYYY-MM-DD" 형식으로 보내는데, 백엔드는 "DD/MM/YYYY"를 기대한다
- API는 페이지네이션을 지원하는데, 프론트엔드는 모든 데이터를 한 번에 로드하려고 한다
- 결제 게이트웨이가 특정 에러를 반환하는데, 프론트엔드가 이를 제대로 처리하지 못한다

단위 테스트만으로는 이런 문제를 잡아낼 수 없다. 통합 테스트가 필수적인 이유다.

## 안티그래비티 시작하기: 테스터 관점

### 설치 및 초기 설정

안티그래비티는 Windows, macOS, Linux를 모두 지원한다. antigravity.google/download에서 운영체제에 맞는 버전을 다운로드하고 설치한다.

**시스템 요구사항**은 다소 높은 편이다. Browser Agent가 실제 브라우저를 구동하고 AI 모델이 로컬에서 작동하기 때문이다. 권장 사양은:
- **macOS**: Apple Silicon(M3/M4) 추천, 16GB RAM
- **Windows**: Windows 11, WSL2 활성화, 16GB RAM
- **Linux**: Ubuntu 24.04 LTS 이상

첫 실행 시 Gmail 계정으로 로그인한다. 현재는 개인 Gmail 계정만 지원되며, 2025년 말 대기 명단은 대부분 해소되어 즉시 사용할 수 있다.

### 테스터를 위한 인터페이스 이해

안티그래비티는 VS Code를 기반으로 만들어졌지만, 코딩 경험이 없어도 충분히 사용할 수 있다. 핵심은 세 가지 영역이다.

**1. Chat Panel(채팅 패널)**
우측에 위치한 이 패널이 테스터의 주요 작업 공간이다. 여기서 자연어로 테스트를 요청하고, AI 에이전트와 대화하며, 결과를 검토한다. 마치 숙련된 자동화 엔지니어와 채팅하는 것과 같다.

**2. Manager View(관리자 뷰)**
Mission Control이라고도 불리는 이 화면에서는 여러 테스트 에이전트를 동시에 실행하고 관리할 수 있다. 하나의 에이전트가 로그인 플로우를 테스트하는 동안, 다른 에이전트는 결제 플로우를 테스트할 수 있다.

**3. Browser Preview(브라우저 미리보기)**
안티그래비티의 가장 혁신적인 기능이다. 내장된 Browser Agent가 실제로 웹사이트를 열고, 클릭하고, 폼을 작성하는 모습을 실시간으로 볼 수 있다. 마치 누군가가 자동으로 테스트하는 것을 지켜보는 것 같다.

### 첫 번째 간단한 테스트

설치가 완료되면 간단한 테스트로 시작해보자. Chat Panel에 다음과 같이 입력한다:

```
https://example-ecommerce.com 사이트를 열고,
로그인 버튼이 제대로 표시되는지 확인해줘.
그리고 스크린샷을 찍어줘.
```

AI 에이전트가 다음과 같이 작동한다:
1. 내장 브라우저를 실행한다
2. 해당 URL로 이동한다
3. 페이지를 분석하여 로그인 버튼을 찾는다
4. 버튼이 존재하고 클릭 가능한지 확인한다
5. 스크린샷을 촬영한다
6. Walkthrough Artifact를 생성하여 결과를 보고한다

몇 초 만에 테스트가 완료되고, 스크린샷과 함께 "로그인 버튼이 정상적으로 표시됩니다"라는 보고서를 받게 된다. 코드는 한 줄도 작성하지 않았다.

## Workflow 시스템: 테스트 표준화의 핵심

### Workflow란 무엇인가

안티그래비티의 **Workflow**는 테스터에게 가장 강력한 도구다. Workflow는 반복적으로 수행하는 테스트 패턴을 템플릿화한 것이다. 한 번 정의해두면, 짧은 명령어만으로 언제든 동일한 품질의 테스트를 실행할 수 있다.

예를 들어 "로그인 테스트"라는 Workflow를 만들어두면, 매번 긴 설명을 반복할 필요 없이 `/test-login`만 입력하면 된다. 에이전트는 자동으로 다음을 수행한다:
- 로그인 페이지로 이동
- 유효한 계정으로 로그인 시도
- 유효하지 않은 계정으로 로그인 시도
- 빈 필드로 제출 시도
- 각 경우의 응답 확인
- 스크린샷과 보고서 생성

Workflow는 팀 내 테스트 표준을 정의하고, 일관성을 유지하며, 신입 테스터도 즉시 전문가급 테스트를 실행할 수 있게 해준다.

### 첫 번째 Workflow 만들기: 로그인 테스트

실제로 Workflow를 만들어보자. Chat Panel 우측 상단의 `...` 메뉴를 클릭하고 "Customizations" → "Workflows" 탭으로 이동한다. "+ Workspace"를 클릭하여 새 Workflow를 생성한다.

다음 내용을 작성한다:

```yaml
name: test-login-flow
description: 로그인 기능에 대한 포괄적인 통합 테스트

# 목표
로그인 기능이 다양한 입력 조건에서 올바르게 작동하는지 검증하고,
백엔드 API와의 통신이 정상적으로 이루어지는지 확인한다.

# 테스트 시나리오
1. **정상 로그인**
   - 유효한 이메일과 비밀번호로 로그인
   - 대시보드로 리다이렉트 확인
   - 사용자 세션이 올바르게 생성되었는지 확인

2. **실패 케이스**
   - 잘못된 비밀번호: "비밀번호가 일치하지 않습니다" 메시지 확인
   - 존재하지 않는 계정: "계정을 찾을 수 없습니다" 메시지 확인
   - 빈 필드: "필수 항목입니다" 유효성 검증 메시지 확인

3. **보안 확인**
   - 비밀번호가 마스킹 처리되는지 확인
   - 로그인 실패 시 계정 정보가 노출되지 않는지 확인

4. **네트워크 통신**
   - API 요청이 올바른 엔드포인트로 전송되는지 확인
   - 응답 형식이 예상과 일치하는지 확인
   - 에러 처리가 적절한지 확인

# 실행 단계
1. 테스트 환경 URL로 이동 (환경 변수 ${TEST_URL} 사용)
2. 각 시나리오를 순차적으로 실행
3. 각 단계마다 스크린샷 촬영
4. 네트워크 요청/응답 로그 수집
5. 통합 보고서 생성

# 성공 기준
- 모든 정상 케이스가 예상대로 작동
- 모든 실패 케이스에서 적절한 에러 메시지 표시
- 네트워크 응답 시간 < 2초
- API 응답 형식이 스키마와 일치

# 출력
- 각 시나리오별 스크린샷
- 전체 테스트 비디오 녹화
- 네트워크 로그 파일
- Pass/Fail 상태가 포함된 HTML 리포트
```

파일을 저장(Cmd+S 또는 Ctrl+S)하면 Workflow가 활성화된다.

### Workflow 실행하기

이제 Chat Panel에서 `/test-login-flow`를 입력하고 엔터를 누르기만 하면 된다. 에이전트가 Planning Artifact를 먼저 생성한다:

```markdown
## 로그인 플로우 테스트 실행 계획

### 환경 설정
- 테스트 URL: https://staging.example-ecommerce.com
- 테스트 계정: test@example.com / TestPass123!
- 잘못된 계정: wrong@example.com / WrongPass!

### 실행 순서
1. 브라우저 초기화 및 네트워크 모니터링 시작
2. 시나리오 1: 정상 로그인 테스트
3. 로그아웃 및 초기 상태 복원
4. 시나리오 2: 실패 케이스 테스트 (3가지)
5. 시나리오 3: 보안 확인
6. 시나리오 4: 네트워크 통신 검증
7. 결과 수집 및 리포트 생성

예상 소요 시간: 약 3분
```

계획을 승인하면 에이전트가 실제로 테스트를 실행한다. Browser Preview 창에서 실시간으로 진행 상황을 볼 수 있다. 브라우저가 자동으로 열리고, 폼이 작성되고, 버튼이 클릭되는 모습이 마치 투명한 유령이 테스트하는 것처럼 보인다.

테스트가 완료되면 Walkthrough Artifact가 생성된다:

```markdown
## 로그인 플로우 테스트 결과

### 실행 요약
- 총 실행 시간: 2분 47초
- 통과: 8/9 (89%)
- 실패: 1/9 (11%)

### 시나리오별 결과

#### ✅ 시나리오 1: 정상 로그인
- 로그인 성공: ✓
- 대시보드 리다이렉트: ✓
- 사용자 세션 생성: ✓
- 스크린샷: login-success.png

#### ⚠️ 시나리오 2: 실패 케이스
- 잘못된 비밀번호: ✓ (적절한 메시지 표시)
- 존재하지 않는 계정: ✓ (적절한 메시지 표시)
- 빈 필드: ❌ **실패** - 유효성 검증 메시지가 표시되지 않음

#### ✅ 시나리오 3: 보안 확인
- 비밀번호 마스킹: ✓
- 정보 노출 방지: ✓

#### ✅ 시나리오 4: 네트워크 통신
- API 엔드포인트: ✓ (POST /api/auth/login)
- 응답 시간: 1.2초 ✓
- 응답 형식: ✓ (스키마 일치)

### 발견된 이슈
**[BUG-001] 빈 필드 제출 시 유효성 검증 실패**
- 재현 단계: 이메일과 비밀번호를 입력하지 않고 로그인 버튼 클릭
- 예상 결과: "필수 항목입니다" 메시지 표시
- 실제 결과: API 요청이 전송됨 (400 Bad Request 응답)
- 심각도: Medium
- 스크린샷: empty-field-bug.png

### 첨부 파일
- 📹 전체 테스트 비디오: test-login-flow-2026-01-22.mp4
- 📊 네트워크 로그: network-log.har
- 📄 HTML 리포트: test-report.html
```

이제 발견된 버그를 개발팀에 보고하고, Workflow를 다시 실행하여 수정 여부를 확인할 수 있다.

### 고급 Workflow: 매개변수화

동일한 테스트를 다른 환경(개발, 스테이징, 프로덕션)이나 다른 계정으로 실행해야 할 때가 있다. Workflow에 매개변수를 추가하면 된다:

```yaml
name: test-login-flow-parameterized
description: 매개변수를 받는 로그인 테스트

# 매개변수 정의
parameters:
  environment:
    description: "테스트 환경 (dev, staging, production)"
    type: string
    default: "staging"
  
  test_account:
    description: "테스트 계정 이메일"
    type: string
    default: "test@example.com"
  
  test_password:
    description: "테스트 계정 비밀번호"
    type: string
    default: "TestPass123!"

# 환경별 URL 매핑
environment_urls:
  dev: "https://dev.example-ecommerce.com"
  staging: "https://staging.example-ecommerce.com"
  production: "https://www.example-ecommerce.com"

# 테스트 로직 (매개변수 사용)
- ${environment_urls[environment]}로 이동
- ${test_account}와 ${test_password}로 로그인
...
```

이제 실행할 때 매개변수를 지정할 수 있다:

```
/test-login-flow-parameterized environment=production test_account=vip@example.com
```

## Browser Agent 심화: 복잡한 사용자 플로우 테스트

### 다단계 플로우 검증

실제 사용자는 여러 단계를 거쳐 목표를 달성한다. E-commerce 사이트에서 구매를 완료하려면 로그인 → 상품 검색 → 상품 상세 → 장바구니 → 결제 정보 입력 → 주문 확인이라는 긴 플로우를 거친다. 이런 다단계 플로우를 테스트하는 것이 통합 테스트의 핵심이다.

안티그래비티로 다음과 같이 요청할 수 있다:

```
전체 구매 플로우를 처음부터 끝까지 테스트해줘:

1. 신규 사용자로 회원가입
2. "무선 이어폰"으로 상품 검색
3. 검색 결과에서 첫 번째 상품 클릭
4. 상품 상세 페이지에서 "장바구니에 추가" 클릭
5. 장바구니 페이지로 이동
6. "결제하기" 버튼 클릭
7. 배송 정보 입력 (테스트 주소 사용)
8. 결제 수단 선택 (테스트 카드 사용)
9. 주문 확인 버튼 클릭
10. 주문 완료 페이지가 표시되는지 확인
11. 주문 번호가 생성되었는지 확인

각 단계마다 스크린샷을 찍고,
문제가 발생하면 즉시 중단하고 보고해줘.
```

에이전트가 Planning Artifact를 생성한 후, 실제로 전체 플로우를 실행한다. 중요한 점은 에이전트가 각 단계의 완료를 확인한 후 다음 단계로 진행한다는 것이다. 예를 들어:

- 회원가입 후 실제로 이메일 인증 메시지가 표시되는지 확인
- 상품이 장바구니에 추가되었을 때 장바구니 아이콘의 숫자가 증가하는지 확인
- 결제 페이지에서 입력한 주소가 제대로 표시되는지 확인

만약 중간에 문제가 발생하면 (예: 결제 버튼을 클릭했는데 아무 반응이 없음), 에이전트는 즉시 테스트를 중단하고 상세한 에러 리포트를 제공한다.

### 조건부 로직이 있는 테스트

실제 애플리케이션은 조건에 따라 다르게 작동한다. 예를 들어:
- 쿠폰 코드가 유효하면 할인이 적용되고, 유효하지 않으면 에러 메시지가 표시된다
- 재고가 있으면 "구매하기" 버튼이 활성화되고, 없으면 "품절" 메시지가 표시된다

안티그래비티는 이런 조건부 로직도 자연어로 표현할 수 있다:

```
결제 페이지에서 쿠폰 적용 기능을 테스트해줘:

1. 장바구니에 총 50,000원 상당의 상품을 추가
2. 결제 페이지로 이동

3. 시나리오 A: 유효한 쿠폰
   - 쿠폰 코드 "WELCOME10" 입력
   - "적용" 버튼 클릭
   - 10% 할인(5,000원)이 적용되는지 확인
   - 최종 금액이 45,000원인지 확인
   
4. 시나리오 B: 유효하지 않은 쿠폰
   - 쿠폰 코드 "INVALID" 입력
   - "적용" 버튼 클릭
   - "유효하지 않은 쿠폰입니다" 메시지 표시 확인
   - 할인이 적용되지 않는지 확인

5. 시나리오 C: 만료된 쿠폰
   - 쿠폰 코드 "EXPIRED" 입력
   - "적용" 버튼 클릭
   - "만료된 쿠폰입니다" 메시지 표시 확인

각 시나리오를 독립적으로 실행하고, 결과를 비교해줘.
```

에이전트는 각 시나리오를 분리하여 실행하고, 결과를 표로 정리해서 보여준다.

### 반응형 디자인 테스트

모바일, 태블릿, 데스크톱에서 모두 테스트해야 한다면:

```
로그인 페이지를 다양한 화면 크기에서 테스트해줘:

1. 데스크톱 (1920x1080)
2. 태블릿 (768x1024)
3. 모바일 (375x667)

각 화면 크기에서:
- 모든 UI 요소가 올바르게 표시되는지 확인
- 버튼을 클릭할 수 있는지 확인
- 텍스트가 잘리지 않는지 확인
- 스크린샷을 나란히 비교할 수 있게 찍어줘
```

에이전트가 자동으로 뷰포트 크기를 변경하면서 각각을 테스트하고, 3개의 스크린샷을 나란히 보여주는 비교 리포트를 생성한다.

## API 통합 테스트: 프론트엔드-백엔드 검증

### 네트워크 요청 모니터링

통합 테스트의 핵심은 프론트엔드와 백엔드가 올바르게 통신하는지 확인하는 것이다. 안티그래비티는 브라우저의 네트워크 활동을 모니터링하고 분석할 수 있다.

```
사용자 프로필 업데이트 기능을 테스트하면서 
네트워크 통신을 상세히 분석해줘:

1. 프로필 페이지로 이동
2. 이름을 "테스트 사용자"로 변경
3. 이메일을 "test@example.com"으로 변경
4. "저장" 버튼 클릭

네트워크 분석:
- 어떤 API 엔드포인트로 요청이 전송되는가?
- HTTP 메소드는 무엇인가? (PUT, PATCH, POST?)
- 요청 바디에 어떤 데이터가 포함되는가?
- 응답 상태 코드는 무엇인가?
- 응답 시간은 얼마나 걸리는가?
- 응답 바디의 구조는 무엇인가?

문제 발견 시:
- 401/403: 인증 문제
- 400: 잘못된 요청 형식
- 500: 서버 에러
각각에 대해 상세히 보고해줘.
```

에이전트가 다음과 같은 리포트를 생성한다:

~~~markdown
## 프로필 업데이트 API 통합 테스트

### 요청 분석
- **엔드포인트**: PUT /api/users/profile
- **요청 헤더**:
  - Content-Type: application/json
  - Authorization: Bearer eyJhbGc...
- **요청 바디**:
  ```json
  {
    "name": "테스트 사용자",
    "email": "test@example.com"
  }
  ```

### 응답 분석
- **상태 코드**: 200 OK ✅
- **응답 시간**: 387ms ✅
- **응답 바디**:
  ```json
  {
    "success": true,
    "data": {
      "id": "user_123",
      "name": "테스트 사용자",
      "email": "test@example.com",
      "updated_at": "2026-01-22T12:34:56Z"
    }
  }
  ```

### 검증 결과
✅ API 엔드포인트가 RESTful 규칙을 따름 (PUT for update)
✅ 요청 형식이 올바름
✅ 인증 토큰이 포함됨
✅ 응답 시간이 양호함 (< 500ms)
✅ 응답 데이터가 요청과 일치함

### UI 업데이트 확인
✅ 프로필 페이지가 새로운 정보로 업데이트됨
✅ 성공 토스트 메시지 표시됨: "프로필이 업데이트되었습니다"
~~~

### API 에러 처리 테스트

실제 환경에서는 네트워크 오류, 서버 에러, 인증 만료 등 다양한 문제가 발생할 수 있다. 이런 에러 상황에서 애플리케이션이 어떻게 반응하는지 테스트하는 것이 중요하다.

```
API 에러 시나리오를 체계적으로 테스트해줘:

테스트 환경: 네트워크 조건 시뮬레이션 사용

시나리오 1: 네트워크 오프라인
- 네트워크를 차단한 상태에서 로그인 시도
- 예상: "네트워크 연결을 확인해주세요" 메시지

시나리오 2: 느린 네트워크
- 3G 속도로 제한
- 로딩 인디케이터가 표시되는지 확인
- 타임아웃 처리가 적절한지 확인

시나리오 3: 서버 에러 (500)
- 서버가 500 에러를 반환하도록 시뮬레이션
- 예상: "일시적인 오류가 발생했습니다" 메시지

시나리오 4: 인증 만료 (401)
- 만료된 토큰으로 API 요청
- 예상: 자동으로 로그인 페이지로 리다이렉트

각 시나리오에서 사용자 경험이 어떻게 되는지 상세히 기록해줘.
```

안티그래비티는 이런 네트워크 조건을 실제로 시뮬레이션할 수 있다. Chrome DevTools Protocol을 활용하여 네트워크 속도를 제한하거나, 특정 요청을 차단하거나, 응답을 수정할 수 있다.

## 다중 서비스 통합 테스트

### 마이크로서비스 아키텍처 테스트

현대적인 애플리케이션은 여러 개의 독립적인 서비스로 구성되어 있다. 사용자 서비스, 상품 서비스, 주문 서비스, 결제 서비스가 각각 독립적으로 작동하지만, 전체 플로우가 작동하려면 이들이 완벽하게 협력해야 한다.

```
마이크로서비스 간 통합을 테스트해줘:

시나리오: 신규 주문 생성

1. **인증 서비스** (https://auth.example.com)
   - 사용자 로그인
   - JWT 토큰 획득
   - 토큰이 이후 모든 요청에 포함되는지 확인

2. **상품 서비스** (https://products.example.com)
   - 상품 목록 조회 API 호출
   - 응답 데이터 형식 확인
   - 특정 상품 선택

3. **장바구니 서비스** (https://cart.example.com)
   - 선택한 상품을 장바구니에 추가 API 호출
   - 장바구니 조회 API로 추가 확인
   - 사용자 ID와 상품 ID가 올바르게 연결되었는지 확인

4. **주문 서비스** (https://orders.example.com)
   - 주문 생성 API 호출
   - 장바구니 데이터가 올바르게 전달되는지 확인
   - 주문 ID가 반환되는지 확인

5. **결제 서비스** (https://payments.example.com)
   - 결제 처리 API 호출
   - 주문 ID가 올바르게 참조되는지 확인
   - 결제 성공 후 주문 상태 업데이트 확인

6. **알림 서비스** (https://notifications.example.com)
   - 주문 확인 이메일이 전송되는지 확인
   - (실제 이메일 대신 API 로그 확인)

각 서비스 간 데이터 흐름을 추적하고,
어디서든 문제가 발생하면 즉시 중단하고 보고해줘.
```

에이전트가 각 서비스의 API를 순차적으로 호출하면서 다음을 검증한다:
- 각 서비스가 올바른 데이터를 반환하는가
- 이전 단계의 데이터가 다음 단계로 올바르게 전달되는가
- 에러가 발생했을 때 적절히 전파되는가
- 전체 플로우가 일관성 있게 작동하는가

### 서비스 의존성 테스트

한 서비스가 다운되었을 때 전체 시스템이 어떻게 반응하는지 테스트하는 것도 중요하다.

```
서비스 장애 시나리오를 테스트해줘:

시나리오 1: 추천 서비스 다운
- 상품 페이지를 열었을 때 추천 서비스가 응답하지 않으면
- 추천 섹션이 우아하게 숨겨지거나 대체 콘텐츠가 표시되는지 확인
- 나머지 페이지는 정상적으로 작동하는지 확인

시나리오 2: 결제 서비스 느림
- 결제 서비스가 10초 이상 응답하지 않으면
- 적절한 로딩 인디케이터가 표시되는지 확인
- 타임아웃 후 재시도 옵션이 제공되는지 확인
- 사용자에게 명확한 안내 메시지가 표시되는지 확인

각 장애 상황에서 사용자 경험이 어떻게 되는지,
그리고 시스템이 부분 장애에서도 작동 가능한지(graceful degradation) 확인해줘.
```

## 회귀 테스트 자동화: 지속적인 품질 보장

### Workflow 스케줄링

통합 테스트를 한 번 작성하고 끝내는 것이 아니라, 지속적으로 실행해야 한다. 새로운 기능이 추가되거나 코드가 변경될 때마다 기존 기능이 깨지지 않았는지 확인하는 것이 회귀 테스트다.

안티그래비티에서는 Workflow를 스케줄에 따라 자동으로 실행할 수 있다:

```
다음 회귀 테스트 스위트를 매일 오전 9시에 자동으로 실행해줘:

테스트 스위트: 핵심 사용자 플로우
1. /test-login-flow
2. /test-product-search
3. /test-add-to-cart
4. /test-checkout-flow
5. /test-order-confirmation

실행 조건:
- 스테이징 환경에서 실행
- 모든 테스트가 통과하면 Slack #qa-alerts 채널에 성공 메시지
- 하나라도 실패하면 Slack에 @channel 멘션과 함께 상세 리포트
- 실패한 테스트의 스크린샷과 비디오를 자동으로 첨부

추가 옵션:
- 프로덕션 배포 전에도 동일한 스위트 실행
- 프로덕션에서는 읽기 전용 테스트만 실행 (데이터 변경 없음)
```

이렇게 설정하면 매일 아침 자동으로 전체 핵심 플로우가 테스트되고, 문제가 발견되면 즉시 팀에 알림이 간다.

### 스냅샷 비교

시각적 회귀를 감지하는 것도 중요하다. 코드 변경으로 인해 UI가 의도치 않게 바뀌는 경우가 많다.

```
상품 상세 페이지의 시각적 회귀 테스트를 설정해줘:

1. 기준 스냅샷 생성
   - 현재 프로덕션의 상품 페이지 스크린샷
   - 다양한 상품 종류별로 각각 촬영
   - 다양한 화면 크기별로 각각 촬영

2. 회귀 테스트
   - 스테이징 환경의 동일한 페이지 스크린샷
   - 기준 스냅샷과 픽셀 단위로 비교
   - 차이가 5% 이상이면 경고

3. 차이 리포트
   - 변경된 영역을 빨간색으로 하이라이트
   - Before/After를 나란히 표시
   - 승인하거나 버그로 리포트할 수 있는 옵션 제공
```

에이전트가 자동으로 스냅샷을 촬영하고, 이전 버전과 비교하여 변경사항을 감지한다. 의도된 디자인 변경이면 새 스냅샷을 기준으로 승인하고, 의도하지 않은 변경이면 버그로 리포트할 수 있다.

## 테스트 데이터 관리

### Fixture 생성 및 관리

반복 가능한 테스트를 위해서는 일관된 테스트 데이터가 필요하다. 매번 수동으로 테스트 계정을 만들거나 상품을 등록하는 것은 비효율적이다.

```
테스트를 위한 Fixture 데이터를 생성해줘:

1. 테스트 사용자 계정
   - 일반 사용자: test-user-001@example.com
   - VIP 사용자: test-vip-001@example.com
   - 관리자: test-admin-001@example.com

2. 테스트 상품 데이터
   - 재고 있는 상품 (10개)
   - 품절 상품 (3개)
   - 할인 중인 상품 (5개)

3. 테스트 쿠폰
   - 유효한 10% 할인 쿠폰: TEST10
   - 만료된 쿠폰: EXPIRED
   - 최소 금액 조건 쿠폰: MIN50K (50,000원 이상 구매 시)

4. 테스트 결제 정보
   - 성공하는 카드: 4242-4242-4242-4242
   - 거부되는 카드: 4000-0000-0000-0002
   - 잔액 부족 카드: 4000-0000-0000-9995

이 데이터들을 JSON 파일로 저장하고,
모든 Workflow에서 참조할 수 있게 해줘.
```

에이전트가 `test-fixtures.json` 파일을 생성한다:

```json
{
  "users": {
    "regular": {
      "email": "test-user-001@example.com",
      "password": "TestPass123!",
      "name": "테스트 사용자"
    },
    "vip": {
      "email": "test-vip-001@example.com",
      "password": "VipPass123!",
      "name": "VIP 사용자"
    }
  },
  "products": {
    "in_stock": [
      {
        "id": "prod_001",
        "name": "무선 이어폰",
        "price": 89000,
        "stock": 50
      }
    ],
    "out_of_stock": [
      {
        "id": "prod_999",
        "name": "품절 상품",
        "price": 49000,
        "stock": 0
      }
    ]
  },
  "coupons": {
    "valid": "TEST10",
    "expired": "EXPIRED",
    "min_amount": "MIN50K"
  }
}
```

이제 모든 Workflow에서 `${fixtures.users.regular.email}` 같은 방식으로 일관된 테스트 데이터를 사용할 수 있다.

### 테스트 격리 및 정리

각 테스트는 독립적이어야 하며, 이전 테스트의 영향을 받지 않아야 한다. 테스트 후에는 생성한 데이터를 정리해야 한다.

```
각 테스트 실행 전후에 다음을 수행해줘:

Before Each Test:
1. 브라우저 캐시 및 쿠키 삭제
2. 로컬 스토리지 초기화
3. 테스트 데이터베이스를 초기 상태로 리셋
4. 신선한 세션으로 시작

After Each Test:
1. 생성한 테스트 데이터 삭제
   - 테스트 주문
   - 테스트 장바구니 항목
   - 임시 사용자 (필요시)
2. 로그아웃
3. 브라우저 종료

Exception:
- 실패한 테스트의 경우 디버깅을 위해 상태 보존
- 스크린샷, 네트워크 로그, 콘솔 로그 수집
```

이렇게 하면 각 테스트가 깨끗한 상태에서 시작하므로, "테스트 A를 먼저 실행하면 테스트 B가 실패한다"는 식의 순서 의존성 문제를 방지할 수 있다.

## 협업 및 리포팅

### 팀원과 Workflow 공유

Workflow 파일은 일반 파일이므로 Git으로 버전 관리할 수 있다. 프로젝트 리포지토리의 `.antigravity/workflows` 디렉토리에 저장하면, 팀 전체가 동일한 테스트 표준을 사용할 수 있다.

```
workflows/
  ├── test-login-flow.yaml
  ├── test-checkout-flow.yaml
  ├── test-product-search.yaml
  └── test-user-profile.yaml
```

새로운 팀원이 합류하면, 안티그래비티를 설치하고 리포지토리를 클론하기만 하면 모든 Workflow를 즉시 사용할 수 있다.

### 버그 리포트 자동 생성

테스트에서 버그를 발견하면, 안티그래비티가 자동으로 상세한 버그 리포트를 생성할 수 있다.

```
버그 리포트 템플릿을 만들어줘:

테스트 실패 시 자동으로 다음 정보를 수집:

## 버그 요약
- 발견 일시: ${timestamp}
- 테스트명: ${workflow_name}
- 환경: ${environment}
- 심각도: ${severity}

## 재현 단계
${reproduction_steps}

## 예상 결과
${expected_result}

## 실제 결과
${actual_result}

## 첨부 자료
- 스크린샷: ${screenshot_url}
- 비디오 녹화: ${video_url}
- 네트워크 로그: ${network_log_url}
- 콘솔 로그: ${console_log_url}

## 환경 정보
- 브라우저: ${browser_version}
- OS: ${os_version}
- 화면 해상도: ${screen_resolution}

이 리포트를 Jira 티켓으로 자동 생성하고,
#bugs Slack 채널에도 요약본을 포스팅해줘.
```

이제 테스트가 실패하면 모든 정보가 자동으로 수집되고, 개발팀에 즉시 전달된다. 테스터는 매번 수동으로 정보를 정리할 필요가 없다.

### 대시보드 및 메트릭

테스트 결과를 시각화하면 팀 전체가 품질 상태를 한눈에 파악할 수 있다.

```
테스트 대시보드를 생성해줘:

메트릭:
- 전체 테스트 통과율 (지난 7일)
- 각 Workflow별 성공/실패 추세
- 평균 테스트 실행 시간
- 가장 자주 실패하는 테스트 Top 5
- 발견된 버그 심각도 분포

시각화:
- 라인 차트: 일별 통과율 추세
- 바 차트: Workflow별 실행 시간
- 파이 차트: 버그 카테고리 분포

업데이트 주기: 매 테스트 실행 후 자동 업데이트
접근 권한: 팀 전체가 읽기 가능
```

안티그래비티가 자동으로 HTML 대시보드를 생성하고, 매번 테스트 실행 후 업데이트한다. 팀원들은 브라우저에서 언제든 최신 테스트 상태를 확인할 수 있다.

## 베스트 프랙티스: 효과적인 통합 테스트

### 테스트 범위 결정

모든 것을 테스트할 수는 없다. 우선순위를 정해야 한다.

**높은 우선순위:**
- 핵심 비즈니스 플로우 (회원가입, 로그인, 구매)
- 금전 거래 관련 기능 (결제, 환불)
- 보안 관련 기능 (인증, 권한)
- 자주 사용되는 기능
- 과거에 버그가 많았던 영역

**낮은 우선순위:**
- 정적 콘텐츠 페이지
- 관리자 전용 기능 (별도 테스트)
- 실험적 기능 (아직 안정화되지 않음)

### 명확하고 구체적인 지시

AI 에이전트는 모호한 지시보다 구체적인 지시에 훨씬 잘 반응한다.

**나쁜 예:**
```
로그인을 테스트해줘.
```

**좋은 예:**
```
로그인 기능을 테스트해줘:
1. https://staging.example.com/login 페이지로 이동
2. 이메일 필드에 test@example.com 입력
3. 비밀번호 필드에 TestPass123! 입력
4. "로그인" 버튼 클릭
5. 대시보드 페이지 (URL: /dashboard)로 리다이렉트되는지 확인
6. 페이지에 "안녕하세요, 테스트 사용자님" 텍스트가 표시되는지 확인
```

### 적절한 대기 시간

웹 애플리케이션은 비동기적으로 작동한다. 버튼을 클릭한 후 즉시 결과가 나타나지 않을 수 있다.

```
로그인 버튼을 클릭한 후:
- 로딩 스피너가 사라질 때까지 대기 (최대 5초)
- 그 다음 대시보드 URL로 변경되었는지 확인
- 페이지 요소가 완전히 로드될 때까지 대기

주의: 고정된 시간(예: 3초 대기) 대신,
특정 조건이 만족될 때까지 대기하는 방식 사용
```

### 에러 메시지의 구체성

테스트가 실패했을 때 "로그인 실패"보다는 구체적인 정보가 필요하다.

```
각 검증 단계에서 실패 시 다음 정보를 포함해줘:
- 어느 단계에서 실패했는가?
- 예상한 것은 무엇인가?
- 실제로 무엇이 나타났는가?
- 관련 요소의 스크린샷
- 해당 시점의 콘솔 로그

예:
❌ "로그인 테스트 실패"
✅ "로그인 테스트 실패: 5단계(대시보드 리다이렉트 확인)에서
    예상 URL '/dashboard'가 아닌 '/login?error=invalid'로 이동됨.
    콘솔 에러: 'Token expired'"
```

### Workflow 버전 관리

Workflow를 수정할 때는 버전을 명시하고, 중요한 변경사항을 문서화한다.

```yaml
name: test-login-flow
version: 2.1.0
description: 로그인 기능 통합 테스트

# 변경 이력
changelog:
  - version: 2.1.0
    date: 2026-01-22
    changes: 
      - "2단계 인증 시나리오 추가"
      - "소셜 로그인 테스트 추가"
  
  - version: 2.0.0
    date: 2026-01-15
    changes:
      - "OAuth 지원으로 전체 재작성"
      - "비밀번호 찾기 플로우 추가"
```

## 트러블슈팅

### 문제 1: 에이전트가 요소를 찾지 못함

**증상**: "로그인 버튼을 찾을 수 없습니다"

**해결책**: 더 명확한 셀렉터 제공
```
"로그인" 텍스트를 가진 버튼을 찾되,
다음 중 하나를 사용해서 찾아줘:
- role="button"과 name="로그인"
- class에 "login-btn"이 포함된 요소
- id="login-button"
- data-testid="login-submit"

여러 요소가 일치하면 가장 중요해 보이는 것을 선택해줘.
```

### 문제 2: 테스트가 간헐적으로 실패함 (Flaky Test)

**증상**: 같은 테스트가 때로는 통과하고 때로는 실패한다.

**해결책**: 명시적 대기 조건 추가
```
버튼 클릭 후 다음 조건이 만족될 때까지 대기:
1. 로딩 스피너가 사라짐 (최대 10초)
2. URL이 /dashboard로 변경됨
3. 텍스트 "대시보드"가 페이지에 표시됨

세 조건이 모두 만족된 후에만 다음 단계로 진행해줘.
```

### 문제 3: 테스트가 너무 느림

**증상**: 전체 테스트 스위트 실행에 1시간 이상 소요

**해결책**: 병렬 실행 및 최적화
```
Manager View에서 다음 테스트를 병렬로 실행해줘:
- Agent 1: 로그인 플로우 테스트
- Agent 2: 상품 검색 테스트
- Agent 3: 장바구니 테스트
- Agent 4: 프로필 관리 테스트

서로 독립적인 테스트만 병렬 실행하고,
의존성이 있는 테스트(예: 로그인 → 구매)는 순차 실행해줘.
```

## 결론: 테스터의 역할 진화

구글 안티그래비티는 테스터의 역할을 근본적으로 변화시키고 있다. 더 이상 반복적인 수동 테스트나 복잡한 테스트 스크립트 작성에 시간을 쓰지 않아도 된다. 대신 테스터는 다음에 집중할 수 있다:

1. **테스트 전략 수립**: 무엇을 테스트할 것인가, 어떤 시나리오가 중요한가
2. **사용자 경험 검증**: 기술적으로는 작동하지만 사용자 관점에서 문제가 있는 것 찾기
3. **예외 상황 발견**: AI가 생각하지 못한 엣지 케이스 찾기
4. **품질 메트릭 분석**: 테스트 결과를 분석하여 품질 트렌드 파악
5. **Workflow 최적화**: 더 효율적이고 포괄적인 테스트 프로세스 설계

안티그래비티의 Workflow 시스템은 테스터가 한 번 정의한 테스트 시나리오를 무한히 재사용하고, 지속적으로 개선하며, 팀 전체와 공유할 수 있게 해준다. 코딩 없이도 전문가급 통합 테스트를 만들 수 있는 이 도구를 활용하여, 더 높은 품질의 소프트웨어를 더 빠르게 제공할 수 있을 것이다.

지금 바로 안티그래비티를 설치하고 첫 Workflow를 만들어보자. 테스팅의 미래는 이미 시작되었다.

---

**문서 작성 일자: 2026-01-22**

## 추가 리소스

- Google Antigravity 공식 문서: antigravity.google
- Google Codelabs: Getting Started with Antigravity
- Workflow 예제 저장소: github.com/google/antigravity-workflows
- 테스팅 베스트 프랙티스: testing-best-practices.dev

## 실전 Workflow 예제

프로젝트에 바로 적용할 수 있는 Workflow 템플릿:
- E-commerce 전체 구매 플로우
- SaaS 회원가입 및 온보딩
- 소셜 미디어 포스팅 및 상호작용
- 금융 거래 및 결제
- 다국어/다지역 테스트

## 커뮤니티

- Discord: Antigravity QA 커뮤니티
- Reddit r/antigravity: 테스터 경험 공유
- LinkedIn: Antigravity Testers Group
