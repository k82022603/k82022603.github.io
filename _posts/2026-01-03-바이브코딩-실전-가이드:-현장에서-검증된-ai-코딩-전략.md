---
title: "바이브코딩 실전 가이드: 현장에서 검증된 AI 코딩 전략"
date: 2026-01-03 09:00:00 +0900
categories: [AI,  Vibe Coding]
tags: [AI,  coding-agents,  vibe-coding,  SDD,  spec-driven-development,  persona-pattern,  Developer,  Guide,  Claude.write]
---


## 서론: 이론을 넘어 실전으로

바이브코딩(Vibe Coding)이 등장한 지 1년이 지났습니다. 2025년 2월 Andrej Karpathy가 이 용어를 만들었을 때, 많은 개발자들은 회의적이었습니다. "AI가 코드를 작성한다고? 그건 장난감일 뿐이야." 하지만 2026년 초 현재, 상황은 완전히 달라졌습니다. 

본 문서는 실제로 바이브코딩으로 4개 이상의 프로젝트를 완성한 개발자의 경험을 바탕으로, 웹 검색을 통해 검증하고 확장한 실전 가이드입니다. 이론이 아닌 현장에서 부딪히며 얻은 통찰, 실패를 통해 배운 교훈, 그리고 실제로 작동하는 전략을 담았습니다.

## 에이전트 역할 분담: 대리-과장-상무 전략

### [원본](https://www.threads.com/@z0nmang/post/DTAQjwtkrbe?xmt=AQF0r_SoWKBE3yk3xnF4-4QyvrRekUO6zfgaLL6soIupE8mtq03gp2NkpGIss5z2n_ZfieE&slof=1) 주장

"Cursor를 대리, Claude Code를 과장, Codex를 상무 컨설턴트로 생각하고 일을 나눈다. Cursor가 가장 빠르고, Codex가 가장 느리지만 더 생각하는 느낌이다."

### 검증 결과: 완전히 타당함

이 직관적인 비유는 실제로 각 도구의 특성을 정확하게 파악하고 있습니다. 웹 검색 결과 여러 전문가들의 벤치마크와 사용 경험이 이를 뒷받침합니다.

#### Cursor의 특성: 속도와 통합

DoltHub의 비교 분석에 따르면, "Cursor Agent는 Claude Code보다 약간 더 나은 코딩 속도(Code/Prompt)를 보이며, GPT-5를 기본 모델로 사용할 때 Claude Code보다 약간 더 똑똑하다." 하지만 핵심은 속도보다 **통합**에 있습니다.

Cursor는 VS Code 포크로서 다음과 같은 강점이 있습니다:

**즉각적인 피드백**: Tab 자동완성, Cmd+K 인라인 편집, Cmd+I 채팅은 모두 에디터 내에서 즉시 실행됩니다. 생각과 실행 사이의 지연이 거의 없습니다.

**시각적 워크플로우**: Diff 미리보기, 버전 체크포인트, 통합 터미널이 모두 GUI로 제공됩니다. 변경 사항을 "보면서" 승인할 수 있습니다.

**Auto-run 모드**: 허용/거부 목록을 신중하게 설정하면, Cursor는 테스트를 작성하고, 실행하고, 실패를 보고, 자동으로 수정합니다. Builder.io는 이것을 "섬뜩할 정도로 자율적(eerily autonomous)"이라고 표현했습니다.

**권한 관리의 완화**: Cursor는 "YOLO mode"를 발명했으며, 권한 체크를 훨씬 덜 요구합니다. 이것이 초기 반복 속도를 높이는 이유입니다.

이러한 특성은 "대리" 역할에 완벽히 부합합니다. 명확한 지시를 받으면 빠르게 실행하고, 즉각적인 피드백을 제공하며, 반복 작업을 효율적으로 처리합니다.

#### Claude Code의 특성: 깊이와 계획

Render Blog의 벤치마크는 "Claude Code는 빠른 프로토타입과 생산적인 터미널 UX에 최적"이라고 평가합니다. 하지만 이는 표면적인 설명일 뿐입니다.

Claude Code의 진짜 강점은 다음과 같습니다:

**200K 토큰 컨텍스트**: Cursor도 200K를 광고하지만, 실제로는 70K-120K에서 제한됩니다. Claude Code는 실제로 200K를 사용할 수 있습니다. Cyrus의 분석: "대규모 리팩토링에서 Claude Code의 컨텍스트 윈도우와 자율 실행이 빛난다."

**Plan Mode와 opusplan**: Boris Cherny의 실전 사례에서 확인했듯이, Plan Mode는 복잡한 작업을 체계적으로 접근하게 합니다. "좋은 계획이 정말 중요하다"는 그의 강조는 Claude Code가 "과장" 역할에 적합한 이유를 설명합니다.

**Subagent 시스템**: Claude Code는 복잡한 작업을 자동으로 subagent에 위임합니다. Explore subagent는 코드베이스를 빠르게 검색하고, Plan subagent는 아키텍처 결정을 돕습니다. 이는 "과장"이 "대리"에게 일을 나눠주는 것과 유사합니다.

**Git 안전성**: Claude Code 2.0.71은 force push 금지, pre-commit hook 존중 등 팀 안정성을 위한 안전장치를 강화했습니다. 이는 개인 프로젝트보다 팀 프로젝트에서 중요한 "과장"의 책임입니다.

Vertu의 분석은 이를 요약합니다: "Cursor는 '바이브 코딩'에 적합하고, Claude Code는 'Engineering Agent'로 포지셔닝되고 있다. 2.0.71 업데이트는 속도보다는 유지보수성과 복잡한 리팩토링에 초점을 맞춘다."

#### GPT-5.2 Codex의 특성: 디버깅과 리뷰

"느리지만 더 생각한다"는 표현은 정확합니다. OpenAI의 공식 발표에 따르면, GPT-5.2 Codex는 "context compaction을 통한 장기 작업 개선"과 "significantly stronger cybersecurity capabilities"를 특징으로 합니다.

SSOJet의 리뷰는 명확합니다: "GPT-5.2 Codex는 코드의 버그와 불일치를 찾는 데 뛰어나다. 신중하고 체계적인 문제 탐지에서 Claude Code 같은 다른 모델을 능가한다. Claude Code는 raw 코딩에 능숙하지만, GPT-5.2 Codex는 이슈 식별에서 우수한 성능을 보인다."

**Effort 파라미터**: GPT-5.2 Codex는 high, xhigh effort 모드를 제공합니다. 이는 문자 그대로 모델에게 "더 생각할 시간"을 줍니다. "상무 컨설턴트"가 중요한 결정을 내릴 때 심사숙고하는 것과 같습니다.

**사후 분석 능력**: Codex는 이미 작성된 코드를 분석하고, 미묘한 버그를 찾고, 보안 취약점을 탐지하는 데 특화되어 있습니다. 이는 "상무"가 팀의 작업을 검토하고 전략적 조언을 제공하는 역할과 일치합니다.

**비용 vs 가치**: Codex는 느리고 비쌉니다. 하지만 critical한 버그를 배포 전에 발견하는 것의 가치는 비용을 훨씬 능가합니다. "상무 컨설턴트"의 시간당 비용이 높지만, 그들의 조언이 회사를 큰 실수로부터 구할 수 있는 것과 같습니다.

#### 최적 워크플로우

검증 결과, 제시된 역할 분담은 이상적입니다:

1. **Claude Code(과장)**: 일감을 받고 작은 기능 단위로 설계와 체크리스트를 작성합니다. Plan Mode로 상세한 계획을 수립합니다.

2. **Cursor(대리)**: 나뉜 일감을 빠르게 실행하고, 가벼운 오류를 즉시 해결합니다. 반복 작업에 최적화되어 있습니다.

3. **GPT-5.2 Codex(상무)**: 큰 일감 덩어리(에픽)가 끝나거나 오류가 해결되지 않을 때 깊이 있는 리뷰와 개선점을 제시합니다.

Render Blog의 권장사항: "Cursor는 설정 속도, Docker/Render 배포, 코드 품질에서 선두이고, Claude Code는 빠른 프로토타입과 생산적인 터미널 UX에 최적이며, Codex의 모델은 강력하다."

실전 사례들을 종합하면, 많은 전문 개발자들이 정확히 이러한 하이브리드 접근을 사용하고 있습니다. "Claude로 생성, Codex로 리뷰"는 표준 패턴이 되고 있습니다.

### 비용 최적화 전략

"돈이 없어 하나씩 잘라가야 한다면, Codex, 클코를 자를 것"이라는 판단도 합리적입니다.

**비용 분석**:
- Cursor: $20/월 (가장 경제적)
- Claude Code: $20-100/월 (사용량에 따라)
- Codex (ChatGPT Plus): $20/월 (제한적 사용)

Cursor 하나로 버틸 경우:
- Auto mode의 속도를 활용하여 빠른 반복
- 복잡한 작업도 명확한 프롬프팅으로 해결 시도
- 디버깅은 웹 검색과 수동 분석으로 보완

하지만 총 $60/월 투자 시:
- Claude Code로 30-50% 개발 시간 단축 (Boris Cherny 사례)
- Codex로 배포 전 critical 버그 탐지 (수천-수만 달러 손실 방지 가능)
- ROI는 첫 달부터 양수

DoltHub의 결론: "Cursor Agent는 Claude Code와 비슷한 품질의 코드를 1/10 비용으로 생산한다." 하지만 이는 단순 작업 기준이며, 복잡한 작업에서는 Claude Code의 가치가 커집니다.

## 개발 가이드: CLAUDE.md를 넘어서

### 원본 주장

"에이전트가 같은 실수를 반복한다. 해결책은 '개발 가이드' 문서를 작성하여 프로젝트 구조, 목표, 반복되는 오류와 해결방식을 담고 언제나 참조하게 하는 것이다."

### 검증 결과: 핵심 베스트 프랙티스

이것은 단순한 개인 경험이 아니라, AI 코딩의 가장 중요한 원칙 중 하나입니다. Anthropic의 공식 블로그 "Using CLAUDE.MD files"는 이를 공식적으로 권장합니다.

#### CLAUDE.md의 본질

Anthropic 공식 문서: "CLAUDE.md는 Claude의 시스템 프롬프트의 일부가 됩니다. 모든 대화는 이 컨텍스트가 이미 로드된 상태로 시작하므로, 기본 프로젝트 정보를 반복 설명할 필요가 없습니다."

**핵심 원리**:
- CLAUDE.md는 문서가 아니라 **명령어**입니다
- 한 번 작성하면 모든 세션에 자동 적용됩니다
- 팀원들이 저장소를 클론하면 즉시 동일한 컨텍스트를 공유합니다

#### 무엇을 포함해야 하는가

Sid Bharath의 가이드는 CLAUDE.md를 "critical project infrastructure"로 취급할 것을 권장합니다:

**항상 참일 정보**:
- 빌드 명령어: `npm run build`, `cargo test`
- 핵심 디렉토리: `src/components/`는 React 컴포넌트, `src/db/`는 데이터베이스 레이어
- 코딩 컨벤션: "항상 TypeScript strict mode 사용", "함수형 컴포넌트만 사용"
- 테스트 지침: "모든 API 엔드포인트는 통합 테스트 필요"

**절대 하지 말아야 할 것**:
- "NEVER use force push"
- "NEVER skip pre-commit hooks"
- "Do NOT modify files in /generated/ - they are auto-generated"

**반복되는 오류와 해결책**:
```markdown
## Common Mistakes

### Authentication Token Refresh
WRONG: Storing tokens in localStorage without refresh logic
RIGHT: Use secure httpOnly cookies + refresh token rotation
See: src/auth/TokenManager.ts for implementation

### Database Migrations
WRONG: Manually editing production database
RIGHT: Always create migration files with `npm run migrate:create`
Previous incidents: 2025-01-15 production outage from manual ALTER TABLE
```

#### 개발 가이드 vs CLAUDE.md

중요한 구분이 필요합니다:

**CLAUDE.md**: 
- 짧고 간결 (200-300 lines)
- 보편적으로 적용되는 규칙
- 모든 세션에 로드되므로 토큰 효율 중요
- Git에 체크인

**개발 가이드 (별도 문서)**:
- 상세한 설명과 예시
- 특정 작업에만 필요한 정보
- 필요시 명시적으로 참조
- 사람이 읽기에 최적화

Alexop.dev의 조언: "CLAUDE.md는 짧고 항상 참인 프로젝트 컨벤션과 표준을 담는다. 작업별 지침은 skills나 slash commands로 분리한다."

#### 실전 예시

ClaudeLog의 사례: WearOS 앱 개발 중 컴파일 오류가 반복 발생했습니다. CLAUDE.md를 "모듈화된 작업 컨텍스트, 규칙, 번호가 매겨진 단계, 예시"로 반복 개선한 결과, Claude가 성공적으로 작업을 수행했습니다.

핵심은 **반복**입니다:
1. Claude가 실수를 합니다
2. CLAUDE.md에 "이렇게 하지 마, 대신 저렇게 해"를 추가합니다
3. 다음 세션에서 같은 실수가 사라집니다
4. 시간이 지날수록 CLAUDE.md는 팀의 집단 지성을 담게 됩니다

#### 자동 유지보수

Frank Bernhardt의 가이드는 GitHub Actions로 CLAUDE.md 자동 업데이트를 제안합니다:

**PR-triggered workflow**: PR에 코드 변경이 있을 때 자동으로 관련 문서 업데이트
**Scheduled workflow**: 매일 자정에 지난 24시간의 커밋을 검토하고 문서 PR 생성

이는 "문서 드리프트(documentation drift)"를 자동으로 방지합니다. 코드는 빠르게 진화하지만 문서는 뒤처지는 문제를 해결합니다.

#### Boris Cherny의 팀 사례

Boris의 팀은 전체가 하나의 CLAUDE.md를 공유하며:
- Git에 체크인하여 버전 관리
- 주당 여러 번 전체 팀이 기여
- Claude가 실수할 때마다 즉시 추가
- 코드 리뷰 시 @.claude 태깅으로 CLAUDE.md 업데이트

이것은 **Compounding Engineering**입니다. 오늘 해결한 문제는 내일 자동으로 처리되며, 이것이 주, 월, 년 단위로 누적되면 엄청난 생산성 향상을 가져옵니다.

### 검증 결론

"개발 가이드를 작성하고 언제나 참조하게 한다"는 전략은 완벽히 검증되었습니다. 이것은 개인의 발견이 아니라, AI 코딩의 가장 중요한 베스트 프랙티스 중 하나입니다.

## 백로그 관리: 집중력 유지의 기술

### 원본 주장

"고쳐야 할 것이 많아 개발이 삼천포로 빠진다. 백로그를 활용하여 '템플릿에 맞게 백로그에 남겨줘'라고 하고, 다음 일감 선정 시 확인한다."

### 검증 결과: AI 시대의 필수 실천

이 통찰은 AI 코딩의 특수한 문제를 정확히 파악하고 있습니다.

#### AI 코딩의 "Rabbit Hole" 문제

전통적 개발에서는 개발자가 의식적으로 범위를 제한합니다. "지금은 X만 하고, Y는 나중에 하자." 하지만 AI 에이전트는 다릅니다:

**문제 발견의 속도**: AI는 코드를 읽는 속도가 인간보다 훨씬 빠릅니다. 한 파일을 수정하다가 관련된 10개 파일의 문제를 즉시 발견합니다.

**완벽주의 경향**: Claude는 특히 "도움이 되고 싶어하는(helpfulness)" 경향이 강합니다. 요청하지 않은 개선사항을 추가하려 합니다.

**컨텍스트 확장**: AI는 관련된 모든 것을 한 번에 고치려 합니다. "버튼 색상 변경" 요청이 "전체 디자인 시스템 재작업"으로 확장됩니다.

Atlassian의 Rovo Dev 가이드는 이를 "scope creep"이라고 부르며, SDD의 핵심 해결 과제로 지적합니다.

#### 백로그 시스템의 중요성

Zencoder의 SDD 가이드는 작업 관리를 명시적으로 다룹니다:

**작업 분해**:
- 큰 작업을 작은, 검증 가능한 단계로 나눕니다
- 각 작업은 독립적으로 구현하고 테스트할 수 있어야 합니다
- "인증 구축" 대신 "이메일 형식 검증하는 사용자 등록 엔드포인트 생성"

**템플릿 사용**:
```markdown
## Backlog Item

**Title**: [간결한 제목]
**Priority**: [High/Medium/Low]
**Estimated Effort**: [Small/Medium/Large]
**Description**: [무엇을, 왜]
**Acceptance Criteria**:
- [ ] 기준 1
- [ ] 기준 2
**Related Issues**: #123, #456
**Notes**: [발견 당시의 컨텍스트]
```

#### 실전 워크플로우

GitHub Spec-Kit 접근법:

**발견 단계**: 작업 중 개선 사항을 발견하면 즉시 백로그에 기록
**리뷰 단계**: 현재 작업 완료 후 백로그를 검토하고 우선순위 결정
**실행 단계**: 선택된 항목만 명시적으로 시작

명령어 예시:
```
"이 UI 개선 아이디어를 백로그에 추가해줘. 
템플릿: Title, Priority, Description, Acceptance Criteria"
```

#### 집중력 유지 기법

Thoughtworks의 SDD 가이드는 "인간이 루프에 있어야(human-in-the-loop)" 함을 강조합니다:

**명시적 승인**: "이 추가 개선을 해도 될까요?"라고 AI가 물을 때, "아니요, 백로그에 추가만 해주세요"
**범위 재확인**: 작업 시작 시 "이 세션에서는 X만 한다. 다른 발견사항은 백로그에 기록"
**주기적 점검**: 30분마다 "현재 목표에서 벗어나지 않았는지" 확인

#### 도구 통합

현대적 접근법은 백로그를 도구와 통합합니다:

**Jira/Linear 연동**: MCP 서버로 Jira에 직접 이슈 생성
**GitHub Issues**: Claude Code가 발견사항을 자동으로 이슈로 생성
**Notion/Obsidian**: 구조화된 백로그를 지식 베이스와 연결

Spec-Kit의 `tasks.md` 파일은 이러한 백로그 시스템의 한 구현입니다.

### 검증 결론

백로그 관리는 AI 코딩의 필수 실천입니다. AI의 빠른 발견 속도와 인간의 전략적 우선순위 결정을 결합하는 핵심 메커니즘입니다.

## SDD (Spec-Driven Development): 구조화의 힘

### 원본 주장

"Cursor Plan mode, Kiro, spec-kit, taskmaster mcp를 써봤는데, 모두 해야 할 일을 구체화하고 작은 단위로 나누는 방법을 택했다. 4번째 프로젝트는 체계적으로 일감을 나누는 데 집중했다."

### 검증 결과: 2025년의 핵심 트렌드

이 관찰은 2025년 AI 개발의 가장 중요한 패러다임 전환을 정확히 포착하고 있습니다.

#### SDD의 등장 배경

GitHub의 공식 발표: "코딩 에이전트를 검색 엔진처럼 취급할 때 잘 작동했지만, 심각하고 미션 크리티컬한 애플리케이션을 구축할 때는 무너진다."

**Vibe Coding의 한계**:
- 일회성 프롬프트는 아이디어를 불러일으키지만 시스템을 만들지 못함
- 코드가 컴파일되지 않거나 의도를 놓치는 경우가 많음
- 복잡도가 증가하면 에이전트가 컨텍스트를 잊고 이전 결정과 모순됨

Dave Patten의 분석: "AI가 소프트웨어 구축 방식을 바꿨지만, 거의 모든 워크플로우가 여전히 단일하고 일회성인 프롬프트로 시작한다. 프롬프트는 아이디어를 촉발하지, 시스템을 만들지 않는다."

#### SDD의 핵심 철학

Spec-Driven Development는 "design before code"를 AI 시대에 재해석합니다:

**4단계 워크플로우** (GitHub Spec-Kit):

1. **Specify**: 고수준 설명을 제공하면 AI가 상세한 스펙 생성
2. **Plan**: 스펙을 기반으로 기술적 구현 계획 수립
3. **Tasks**: 계획을 작고 검토 가능한 작업 단위로 분해
4. **Implement**: AI가 작업을 하나씩(또는 병렬로) 처리

**핵심 원리**:
- Spec이 코드가 아닌 **source of truth**
- 각 단계에는 **human checkpoint** 존재
- 작업은 **독립적으로 구현하고 테스트** 가능해야 함

#### Kiro, Spec-Kit, Plan Mode 비교

Martin Fowler의 분석은 실무자들의 경험을 요약합니다:

**Amazon Kiro**:
- VS Code 기반 IDE
- Spec Mode로 상세한 스펙과 작업 분해 생성
- Requirements → Design → Tasks 구조
- 문제: 작은 버그 수정에도 너무 verbose

**GitHub Spec-Kit**:
- CLI 도구 (`uvx specify init`)
- 템플릿 기반 (`spec.md`, `plan.md`, `tasks.md`)
- Agent-agnostic (Copilot, Claude Code, Gemini CLI 모두 지원)
- 문제: 초기 설정과 학습 곡선

**Cursor Plan Mode**:
- IDE에 통합된 계획 단계
- To-do 리스트 자동 생성 및 실시간 업데이트
- Slack 연동 가능
- 문제: Cursor에 종속

**Claude Code Plan Mode**:
- Shift+Tab 두 번으로 활성화
- `.claude/plans/`에 plan.md 생성
- Opus로 계획, Sonnet으로 실행 (opusplan)
- askUserQuestion으로 명확화 질문

#### 적용 시나리오

Frontend at Scale의 분석: "SDD는 모든 것에 적합하지 않다."

**SDD가 적합한 경우**:
- Greenfield 프로젝트
- 중대형 기능 (며칠 이상 소요)
- 코드 품질이 중요한 경우
- 여러 팀원이 협업하는 경우
- 복잡한 비즈니스 로직

**SDD가 과도한 경우**:
- UI 중심 작업 (시각적 스펙이 더 유용)
- 작은 버그 수정
- 빠른 프로토타이핑
- 실험과 탐색 단계

**스펙트럼 접근**: 
대부분의 일상 작업은 스펙트럼의 중간에 위치합니다. UI 작업은 수동 검토 → 가벼운 프롬프팅 → 수동 편집을 혼합하고, 백엔드/풀스택 기능은 spec 작성 → AI 실행에 가깝게 진행합니다.

#### 실전 팁

Zencoder의 가이드는 실무 적용을 상세히 다룹니다:

**모델 선택**: Claude Sonnet 4.5가 state management와 긴 세션 컨텍스트 유지에 탁월
**반복 개선**: 스펙 → 계획 → 작업 → 구현 각 단계에서 반복적으로 정제
**테스트 주도**: 수용 기준을 테스트로 변환하여 검증 자동화

**문서화 자동**: 스펙이 살아있는 문서가 됨. 요구사항 변경 시 스펙 업데이트 → AI가 코드, 테스트, 다이어그램 재생성

#### SDD의 미래

Thoughtworks의 전망: "SDD는 고립된 사건이 아니다. 생태계 전반에서 'plan-before-code'가 표준이 되고 있다."

**통합 트렌드**:
- Cursor Plan Mode: IDE 워크플로우에 계획 자동 생성
- Gemini CLI: 계획 단계와 MCP 확장으로 안전한 코드 생성 조정
- OpenAI Codex 2025: 구조화된 엔지니어링 작업 강조

**거버넌스**: ISO 42001, NIST RMF-AI, SOC 2 증거 체인에 스펙이 깔끔하게 매핑됨

### 검증 결론

"일감을 구체화하고 작은 단위로 나눈다"는 접근법은 단순한 개인 선호가 아닙니다. 이것은 2025년 AI 개발의 핵심 패러다임이며, 주요 기업들이 모두 같은 방향으로 수렴하고 있습니다.

귀하의 4번째 프로젝트에서 "체계적으로 일감을 나누는 데 집중"한 것은 정확히 올바른 진화입니다.

## 페르소나와 Skills: 역할 부여의 과학

### 원본 주장

"프롬프트 엔지니어링에서 '역할'을 부여하면 AI 성능이 올라간다는 연구가 있다. Bmad와 Claude Skills를 가볍게 써봤는데, 있을 때와 없을 때를 직접 비교하지 않아 명확히 말 못하겠다."

### 검증 결과: 효과는 있으나 트레이드오프 존재

이것은 AI 연구의 잘 확립된 원리이지만, 실전에서는 뉘앙스가 있습니다.

#### 역할 부여의 과학적 근거

**Persona Pattern** (프롬프트 엔지니어링 연구):
- "당신은 시니어 소프트웨어 아키텍트입니다" → 더 구조화된 응답
- "당신은 보안 전문가입니다" → 보안 취약점에 더 집중
- "당신은 UX 디자이너입니다" → 사용성과 접근성 고려 증가

**Chain-of-Thought**: 역할은 모델이 특정 "사고 방식"으로 추론하도록 유도합니다.

#### Claude Skills의 실체

Anthropic 공식 문서는 Skills를 다음과 같이 정의합니다:

**구조**:
```markdown
---
description: Dexie.js 데이터베이스 가이드
allowed-tools: WebSearch, WebFetch, Read, Write
---
# Dexie Expert Skill

당신은 Dexie.js 전문가입니다. IndexedDB, 스키마, 쿼리 작업 시:
1. https://dexie.org/llms.txt에서 관련 문서 페이지 파싱
2. WhereClause, Collection 문서 참조
3. TypeScript 인터페이스로 테이블 스키마 정의
```

**자동 활성화**: 
- Claude는 작업 내용에서 키워드 감지 시 자동으로 적절한 skill 활성화
- 사용자가 "Dexie"를 언급하면 dexie-expert skill이 자동으로 활성화됨
- 개발자가 명시적으로 "Use the dexie-expert skill"이라고 말할 수도 있음

#### Bmad Method의 접근

Bmad는 더 구조화된 접근입니다:

**가상 팀 시뮬레이션**:
- Analyst: 요구사항 분석
- Product Manager: PRD 작성
- Architect: 기술 설계
- Developer: 구현
- QA: 테스트

**분리된 에이전트**: 각 역할이 독립적인 에이전트로 실행되어 전문화된 출력 생성

Microsoft 개발자 블로그: "Bmad의 Analyst, PM, Architect 에이전트는 협업하여 Spec-Kit이 입력으로 기대하는 살아있는, 실행 가능한 스펙(PRD, 아키텍처, 기술 계획)을 생성할 수 있다."

#### 실전에서의 효과

**긍정적 사례** (ClaudeLog):
- WearOS 앱 개발에서 CLAUDE.md에 역할과 단계별 지침 추가 후 성공률 향상
- 구체적인 역할 정의 → 일관된 출력 패턴

**부정적 사례** (Alexop.dev):
- 과도한 페르소나는 토큰 낭비
- "당신은 세계 최고의 프로그래머이며..."같은 과장된 역할 부여는 효과 미미
- 단순 작업에 복잡한 skill은 오버헤드

#### 권장 접근법

**최소 효과 원칙**:
```markdown
# CLAUDE.md - Minimal Persona

## Your Role
Senior full-stack developer familiar with:
- React + TypeScript + Tailwind
- Node.js + Express + PostgreSQL
- Git workflow (feature branches, PR reviews)

## Quality Standards
- Write tests for all API endpoints
- Follow existing code patterns in /src
- Ask clarifying questions before making architectural decisions
```

**Skills는 선택적으로**:
- 복잡하거나 특수한 라이브러리/프레임워크를 다룰 때만
- 예: Dexie.js, specific AWS services, uncommon frameworks
- 일반적인 React/Node.js에는 불필요 (Claude가 이미 알고 있음)

**Bmad는 대규모에만**:
- 여러 팀이 협업하는 엔터프라이즈 프로젝트
- 명확한 역할 분리가 필요한 경우
- 개인 프로젝트나 소규모 팀에는 과도한 복잡성

### 검증 결론

역할 부여는 효과가 있지만, "항상 더 많이"가 정답은 아닙니다. 최소한의 명확한 역할 정의로 시작하고, 필요시 점진적으로 확장하는 것이 최적입니다.

귀하의 "명확히 말 못하겠다"는 정직한 평가가 맞습니다. 효과는 미묘하며, 프로젝트 특성에 따라 다릅니다.

## 문서 동기화: 가장 어려운 문제

### 원본 주장

"추가되는 문서가 많아질수록 코드와의 동기화가 어려워진다. 과거 문서를 참고하다가 잘못 구현할 수도 있다. 일감 단위 문서와 전반적 문서를 나누어 잘 작성하는 것이 중요하다."

### 검증 결과: 핵심 도전 과제이자 활발한 연구 영역

이것은 AI 코딩의 가장 어려운 문제 중 하나이며, 완벽한 해결책은 아직 없습니다.

#### Documentation Drift의 실체

Anthropic의 Skills 문서는 이 문제를 명시적으로 다룹니다:

**문서 드리프트는 불가피합니다**: 
- 코드는 빠르게 진화
- 문서는 뒤처짐
- AI는 구식 문서를 읽고 잘못된 가정을 함

**자동 유지보수 skill**: 
```markdown
# Maintaining Documentation After Code Changes

CRITICAL: If you changed code, you MUST update corresponding docs.
"Don't proactively create docs" ≠ "Don't maintain existing docs"

Goal: Understand what changed and what docs need updating
```

#### 계층화된 문서 전략

귀하의 "일감 단위 문서와 전반적 문서를 나눈다"는 접근법은 정확합니다.

**계층 1: 영구 문서** (CLAUDE.md, README.md):
- 프로젝트 전체에 적용
- 자주 변경되지 않음
- 아키텍처 결정, 코딩 컨벤션
- 모든 세션에 로드

**계층 2: 모듈 문서** (각 디렉토리의 README):
- 특정 서브시스템 설명
- 비교적 안정적
- 디자인 결정, invariants, 알려진 제약
- 필요시 참조

**계층 3: 작업 문서** (spec/, tasks/):
- 특정 기능/버그에만 관련
- 작업 완료 후 아카이브 또는 삭제
- 짧은 수명
- 실행 중인 작업에만 로드

Doc-Sync Skill의 구조:
```markdown
## Documentation Hierarchy
- CLAUDE.md: Project-wide navigation index
- /docs/README.md: Architecture overview
- /src/auth/README.md: Authentication subsystem design
- /spec/user-registration-2025-01-15.md: Specific feature spec (archive after completion)
```

#### 자동화 전략

Frank Bernhardt의 GitHub Actions 접근법:

**PR-triggered**: 코드 변경 시 자동으로 관련 문서 업데이트 제안
**Scheduled**: 매일 자정, 지난 24시간 커밋 검토 후 문서 PR 생성

**핵심 원리**:
- 코드 변경과 문서 업데이트를 **동시에** 발생시킴
- 시간 지연 최소화
- 자동 감지로 인간의 기억에 의존하지 않음

#### Git-based 버전 관리

SDD의 한 가지 이점은 spec이 Git에 있다는 것입니다:

**코드와 동기화**:
```bash
# 코드와 스펙이 같은 커밋에
git commit -am "feat: add user registration

- Implemented spec/user-registration.md
- See tasks/user-reg-001.md for details"
```

**브랜치별 스펙**:
- Feature branch에 해당 스펙도 포함
- Merge 시 스펙도 함께 merge
- 코드와 문서의 버전이 항상 일치

#### 실전 권장사항

**최소 원칙**:
- 문서를 최소화하되, 각 문서는 명확한 목적을 가져야 함
- "좋으면 좋은" 문서는 만들지 않음
- 모든 문서는 정기적 검토 대상

**명확한 책임**:
```markdown
# /src/auth/README.md
Last Updated: 2026-01-03
Owner: Authentication Team
Review Frequency: Monthly or after major changes
```

**문서 타입별 전략**:

| 문서 타입 | 갱신 방법 | 위치 | 수명 |
|----------|----------|------|-----|
| CLAUDE.md | 수동 + 팀 기여 | 루트 | 영구 |
| Architecture docs | 주요 변경 시 수동 | /docs | 준영구 |
| Feature specs | SDD 워크플로우 | /spec | 작업 기간 |
| API docs | 자동 생성 (OpenAPI) | /api-docs | 코드와 동기 |
| Code comments | Inline, 코드와 함께 | 소스 파일 | 코드와 함께 |

#### 실패 사례와 교훈

Martin Fowler의 SDD 분석에서 언급된 문제:

**과도한 verbose**:
- Kiro가 작은 버그에도 3개 파일 (requirements, design, tasks) 생성
- "코드보다 마크다운 파일을 검토하는 것이 더 힘들었다"

**잘못된 지침 무시**:
- "많은 파일, 템플릿, 프롬프트, 워크플로우, 체크리스트에도 불구하고 에이전트가 모든 지침을 따르지 않았다"
- 컨텍스트 윈도우가 크다고 AI가 모든 것을 제대로 이해하는 것은 아님

**해결책**:
- 문서를 짧고 집중적으로 유지
- 핵심 규칙만 CLAUDE.md에
- 세부사항은 필요시 동적으로 로드 (skills, slash commands)

### 검증 결론

문서 동기화는 해결된 문제가 아닙니다. 귀하의 우려는 정당하며, 업계 전체가 이 문제와 씨름하고 있습니다.

최선의 접근법은:
1. 문서 계층화 (영구 vs 일시적)
2. 자동화 (GitHub Actions, skills)
3. 최소주의 (필요한 것만, 명확한 목적)
4. 정기 리뷰 (문서 부패 점검)

완벽한 해결책은 없지만, 의식적인 전략이 있으면 관리 가능합니다.

## 통합 워크플로우: 실전 종합

지금까지 검증한 모든 원칙을 하나의 워크플로우로 통합하면:

### 프로젝트 시작 단계

1. **초기 설정** (한 번만):
```bash
# Claude Code로 CLAUDE.md 생성
claude /init

# 수동으로 정제:
# - 팀 코딩 컨벤션
# - "NEVER do X" 규칙
# - 빌드/테스트 명령어
```

2. **역할 정의** (선택적):
```markdown
# CLAUDE.md

## Your Role
Senior full-stack developer on e-commerce platform
Tech stack: React + TypeScript + Node.js + PostgreSQL
```

3. **백로그 설정**:
```bash
mkdir -p backlog spec tasks
```

### 기능 개발 단계 (SDD 적용)

#### Phase 1: Specification (Claude Code - "과장")

```bash
# Plan Mode로 시작
claude --model opusplan
# Shift+Tab 두 번으로 Plan Mode 활성화
```

대화:
```
User: 사용자 등록 기능을 구현해야 해. 이메일/비밀번호 방식으로.

Claude (Plan Mode): 
스펙을 작성하겠습니다. 다음을 확인해주세요:
1. 비밀번호 최소 요구사항은?
2. 이메일 검증 프로세스 (즉시 vs 이메일 확인)?
3. 중복 이메일 처리 방식?
...

[대화 후 spec/user-registration.md 생성]
```

검토 → 승인 후 계획 수립:
```
User: 좋아. 이제 구현 계획을 세워줘.

Claude: 
.claude/plans/user-registration-plan.md 생성했습니다.
1. DB 마이그레이션: users 테이블 생성
2. API: POST /auth/register 엔드포인트
3. 유효성 검사: 이메일 형식, 비밀번호 강도
4. 비밀번호 해싱: bcrypt
5. 테스트: 단위 + 통합 테스트
6. 문서: API docs 업데이트

각 단계를 작업으로 분해할까요?
```

#### Phase 2: Task Breakdown (Claude Code)

```
User: 네, 작업으로 나눠줘.

Claude:
tasks/user-registration-001-db-migration.md
tasks/user-registration-002-api-endpoint.md
tasks/user-registration-003-validation.md
...
각 작업은 독립적으로 테스트 가능합니다.
```

#### Phase 3: Implementation (Cursor - "대리")

Cursor로 전환:
```bash
# Cursor에서 각 작업 파일 열기
```

Cursor Agent Mode:
```
User: tasks/user-registration-001-db-migration.md 구현해줘.

Cursor: [빠르게 마이그레이션 파일 생성, 테스트 실행]
완료. 다음 작업으로 넘어갈까요?
```

중간에 발견한 이슈:
```
User: 이 테이블에 created_at 컬럼도 필요할 것 같은데, 
백로그에 "add timestamps to all tables" 추가해줘.

Cursor: backlog/add-timestamps.md 생성했습니다.
현재 작업 계속할까요?

User: 네.
```

#### Phase 4: Review (Codex - "상무")

작업 완료 후:
```bash
# ChatGPT Plus / Codex CLI
codex --effort xhigh

User: 방금 구현한 사용자 등록 기능을 리뷰해줘.
특히 보안 취약점과 엣지 케이스를 중점적으로.

Codex: [상세한 분석]
1. Critical: 비밀번호가 로그에 기록될 수 있음 (line 45)
2. Warning: 동시 등록 시 race condition (이메일 중복 체크)
3. Suggestion: rate limiting 없음
...
```

수정:
```
User (to Cursor): Codex가 지적한 이슈들 수정해줘.
```

#### Phase 5: Documentation Update

```bash
# Claude Code로 돌아와서
claude

User: 이 기능 구현이 끝났어. 
CLAUDE.md와 관련 문서 업데이트해줘.

Claude:
1. API 문서에 POST /auth/register 추가
2. CLAUDE.md에 "비밀번호는 절대 로그에 기록하지 않음" 규칙 추가
3. spec/user-registration.md를 /docs/features/로 이동 (완료된 기능 문서화)
```

### 문제 발생 시 워크플로우

#### 같은 에러 반복

```markdown
# CLAUDE.md에 즉시 추가

## Common Mistakes

### Database Connections
WRONG: Opening new connection in every route
RIGHT: Use connection pool from /src/db/pool.ts
Previous incidents: 2026-01-03 "too many connections" error
```

#### 복잡한 디버깅

```
User (to Codex in xhigh mode):
이 버그를 2번 시도했는데 해결 안 돼. 근본 원인 분석해줘.

Codex: [깊은 분석]
문제는 X가 아니라 Y입니다.
근본 원인: 비동기 처리 순서 가정이 잘못됨
...
```

### 프로젝트 전반 점검

주기적으로 (주 1회):

```bash
# Claude Code
claude

User: 백로그 검토하고 우선순위 정해줘.

Claude:
High Priority (이번 주):
- [ ] Add timestamps to tables (technical debt)
- [ ] Rate limiting for auth endpoints (security)

Medium Priority (다음 주):
- [ ] User profile page UI improvements
...
```

## 비용 최적화: 현실적 전략

### 월 $60 예산 (Cursor + Claude Code + Codex)

**역할 분담 최적화**:
- Cursor (40% 사용): 단순 반복, UI 조정, 빠른 수정
- Claude Code (40% 사용): 설계, 복잡한 로직, 리팩토링
- Codex (20% 사용): 최종 리뷰, Critical 버그 디버깅만

**세션 관리**:
- 작업 전환 시 `/clear`로 컨텍스트 초기화 (토큰 절약)
- 긴 작업은 작은 단위로 나눠서 여러 세션으로
- CLAUDE.md 최적화 (200 lines 이하 유지)

**모델 선택**:
- Claude Code: 기본 Sonnet, 복잡한 계획만 Opus
- Codex: 일반 작업 medium effort, Critical만 xhigh

### 월 $20 예산 (Cursor만)

**전략**:
- CLAUDE.md를 매우 상세하게 작성 (Cursor Rules)
- Plan Mode 적극 활용
- 백로그로 집중력 유지 (범위 확장 방지)
- 디버깅은 웹 검색 + 수동 분석

**한계 인식**:
- 복잡한 아키텍처 결정에서 약할 수 있음
- 깊은 리뷰는 어려움
- 대신 속도로 보완: 빠르게 반복하며 수렴

### ROI 계산

**생산성 향상** (보수적 추정):
- Cursor만: 2x (기존 대비)
- Cursor + Claude Code: 3x
- 세 가지 모두: 3.5x

**시간 가치** (개발자 $50/hour 가정):
- 월 40시간 코딩 → Cursor로 20시간 절약 = $1,000 가치
- $20 투자로 $1,000 생산 = 50x ROI

**첫 달부터 흑자**: 
- 비용은 매달 고정
- 가치는 CLAUDE.md 누적으로 복리 증가

## 최종 권장사항: 단계별 로드맵

### Level 1: 바이브코딩 입문 (첫 1-2개월)

**필수 투자**: Cursor ($20/월)

**학습 목표**:
1. AI와 대화하는 법 배우기
2. 명확한 프롬프팅 연습
3. 단순 프로젝트로 감 잡기

**핵심 실천**:
- 간단한 CLAUDE.md 작성
- 백로그로 집중력 유지
- 실수를 두려워하지 않기

### Level 2: 구조화 (3-6개월)

**추가 투자**: Claude Code ($20-100/월)

**학습 목표**:
1. Plan Mode 활용
2. SDD 기초 (spec → plan → tasks)
3. 역할 분담 (Cursor vs Claude Code)

**핵심 실천**:
- CLAUDE.md 지속 개선
- 중대형 기능은 SDD 적용
- 문서 계층화 (영구 vs 일시)

### Level 3: 최적화 (6개월 이상)

**추가 투자**: Codex ($20/월) 또는 선택적

**학습 목표**:
1. 하이브리드 워크플로우 마스터
2. 자동화 (GitHub Actions, hooks)
3. 팀 협업 (공유 CLAUDE.md)

**핵심 실천**:
- Compounding Engineering (지식 누적)
- 메트릭 추적 (생산성, 품질)
- 커뮤니티 기여 (발견 공유)

## 결론: 바이브코딩은 스킬입니다

바이브코딩은 "AI에게 맡기고 커피 마시기"가 아닙니다. 이것은 숙련이 필요한 새로운 개발 스킬입니다.

**핵심 스킬**:
1. **전략적 분업**: 어떤 도구에 어떤 작업을 맡길지 판단
2. **효과적 프롬프팅**: 명확하고 구체적으로 의도 전달
3. **컨텍스트 관리**: CLAUDE.md, 백로그, 문서 계층
4. **품질 관리**: 적절한 검증과 리뷰
5. **지속적 개선**: 실수로부터 학습, 시스템 개선

**성공의 지표**:
- CLAUDE.md 라인 수 증가 (지식 누적)
- 같은 실수 반복 빈도 감소
- 프로젝트 완성률 향상
- 즐거움 증가 (지루한 작업 → AI, 창의적 작업 → 인간)

**마지막 조언**:
- 완벽을 추구하지 마세요. 빠르게 반복하며 개선하세요.
- 도구에 집착하지 마세요. 자신에게 맞는 것을 찾으세요.
- 커뮤니티와 나누세요. 모두가 배우고 있습니다.
- 즐기세요. 이것은 소프트웨어 개발의 새로운 시대입니다.

귀하의 4개 프로젝트 경험은 많은 개발자들이 수개월 걸려 배우는 것을 이미 습득했음을 보여줍니다. 계속 실험하고, 발견을 공유하고, 이 새로운 시대를 즐기시기 바랍니다.

---

**문서 작성**: 2026-01-03 
 
**검증 방법**: 실전 경험 + 웹 검색 + 공식 문서 분석  

**주요 참조**: Anthropic 공식 문서, GitHub 블로그, Boris Cherny 사례, DoltHub 벤치마크, OpenAI 발표, Thoughtworks 분석, Martin Fowler 리뷰

**대상 독자**: 바이브코딩을 실전에서 활용하려는 모든 개발자
