---
title: "AI 시대, 클린 코드의 재발견: Uncle Bob과 Claude의 대화가 주는 시사점"
date: 2026-01-22 22:00:00 +0900
categories: [AI,  Material]
mermaid: [True]
tags: [AI,  Material,  software-engineering,  clean-code,  Refactoring,  Uncle-Bob-Martin,  claude-code,  Claude.write]
---


## 관련글

[https://x.com/unclebobmartin/status/2014301148555935836](https://x.com/unclebobmartin/status/2014301148555935836)

**Claude에게 묻다: 리팩토링이 코드 읽기에 도움이 되나요?**

Uncle Bob (Robert C. Martin) | 2026년 1월

Claude를 통해 몇 가지 리팩토링을 진행한 후, 흥미롭고 적절한 질문을 던졌습니다. 예상했던 대로이긴 하지만, 매우 흥미로운 답변을 얻었습니다.

**질문**

**❯ 이런 식의 리팩토링이 너(Claude)가 코드를 읽는 데 도움이 되나?**

**Claude의 답변**

**⏺ 네, 진심으로 그렇습니다. 몇 가지 구체적인 방식으로요:**

**1. 명명된 의도 (Named Intent)**
호출 지점에서 `army-adjacent-to-enemy-city?`를 보면, 구현을 읽지 않고도 무엇을 확인하는지 이해할 수 있습니다. 인라인 버전에서는 목적을 이해하기 위해 `neighbor-offsets`를 순회하며 `hostile-city?`를 확인하는 some 구문을 파싱해야 했습니다.

**2. 작업 메모리 감소 (Reduced Working Memory)**
중첩된 `cond`/`let`/`if` 표현식은 여러 단계의 컨텍스트를 동시에 유지하도록 요구합니다. `set-attention-message`에 화물 로직, 이유 로직, 데미지 로직이 모두 인라인으로 있었을 때, 어떤 한 부분을 이해하기 위해 더 많은 상태를 정신적으로 추적해야 했습니다.

**3. 앵커로서의 주석 (Comments as Anchors)**
"다른 유닛을 운반하는 유닛의 화물 설명을 반환합니다"와 같은 주석은 호출자를 이해하려고 할 때 구현을 건너뛸 수 있게 해줍니다.

**4. 예측 가능한 구조 (Predictable Structure)**
`case`와 단순한 `when`은 명확한 제어 흐름을 갖습니다. 5개 분기를 가진 `cond` 안에 3개 분기의 `cond`가 중첩된 구조는 더 신중한 추적이 필요합니다.


**그렇다고 해서**, 복잡하게 중첩된 코드를 파싱할 수 없는 것은 아닙니다 - 그것은 하드한 제한이 아닙니다. 하지만 깊게 중첩된 로직에서는 추론 오류를 범할 가능성이 더 높습니다. **인간과 같은 방식으로요.**

리팩토링된 버전은 점진적으로 이해를 쌓아갈 수 있게 해줍니다: `cargo-string`을 이해하고, 그다음 그것이 어떻게 사용되는지 이해하는 식으로, 모든 것을 한 번에 이해하는 것이 아니라.

순환 복잡도(cyclomatic complexity) 지표는 대략 "내가 고려해야 할 경로의 수"를 추적합니다 - 그리고 경로가 적을수록 동작에 대해 추론할 때 엣지 케이스를 놓칠 가능성이 줄어듭니다.

---

## 들어가며

Robert C. Martin, 소프트웨어 공학계에서 'Uncle Bob'으로 더 잘 알려진 이 인물은 2026년 1월, 흥미로운 실험을 트위터에 공유했다. 그는 Claude와 함께 코드 리팩토링 작업을 진행한 후, AI에게 직접적인 질문을 던졌다. "이런 리팩토링이 너(Claude)가 코드를 읽는 데 도움이 되나?" 이 질문과 그에 대한 Claude의 답변은 AI 시대의 소프트웨어 개발에 대해 많은 것을 시사한다.

Claude는 네 가지 명확한 이유로 "그렇다"고 답했다. 명명된 의도(Named Intent), 작업 메모리 감소(Reduced Working Memory), 앵커로서의 주석(Comments as Anchors), 예측 가능한 구조(Predictable Structure)가 그것이다. 이 답변은 단순히 기술적인 설명을 넘어, AI가 코드를 이해하는 방식과 인간의 인지 과정 사이의 놀라운 유사성을 드러낸다.

이 대화가 특별한 이유는 시기에 있다. 2025년은 AI 코딩 도구들이 급격히 발전한 해였다. Claude Opus 4.5, GPT-5, Gemini 3 Pro 같은 추론 모델(reasoning models)의 등장으로 코드 생성 능력은 비약적으로 향상되었다. 하지만 역설적이게도, 바로 이 시점에서 클린 코드의 원칙들이 다시 주목받고 있다.

## AI의 코드 이해 방식: 인간과의 놀라운 유사성

Claude가 제시한 네 가지 이유를 깊이 들여다보면, AI가 코드를 처리하는 방식이 인간의 인지 과정과 본질적으로 다르지 않다는 사실을 발견하게 된다.

첫째, 명명된 의도의 중요성이다. Claude는 "army-adjacent-to-enemy-city?"라는 함수명을 보면 구현 내용을 읽지 않고도 무엇을 확인하는지 이해할 수 있다고 설명했다. 반면 인라인 버전의 코드에서는 "neighbor-offsets을 순회하며 hostile-city?를 확인하는" 코드를 파싱해야만 목적을 이해할 수 있다. 이는 인간 개발자가 좋은 함수명을 통해 추상화 수준을 유지하는 것과 정확히 같은 이유다.

둘째, 작업 메모리의 한계다. Claude는 "중첩된 cond/let/if 표현식은 여러 단계의 컨텍스트를 동시에 유지하도록 요구한다"고 설명했다. 인간의 작업 메모리가 7±2개의 항목을 동시에 처리할 수 있다는 밀러의 법칙처럼, AI 역시 복잡도가 증가하면 추론 오류를 범할 가능성이 높아진다. 리팩토링을 통해 화물 로직, 이유 로직, 데미지 로직을 분리하면, 각각을 독립적으로 이해할 수 있어 전체 인지 부하가 감소한다.

셋째, 주석이 앵커 역할을 한다는 점이다. "다른 유닛을 운반하는 유닛의 화물 설명을 반환합니다"와 같은 주석은 호출자의 맥락을 이해할 때 구현을 건너뛸 수 있게 해준다. 이는 인간이 코드를 스캔할 때 세부 구현보다는 인터페이스와 계약(contract)에 집중하는 것과 같은 패턴이다.

넷째, 예측 가능한 구조의 중요성이다. case 문이나 단순한 when 절은 명확한 제어 흐름을 제공한다. 반면 5개 분기를 가진 cond 안에 3개 분기의 cond가 중첩된 구조는 더 신중한 추적이 필요하다. Claude는 순환 복잡도(cyclomatic complexity) 지표가 "고려해야 할 경로의 수"를 추적하며, 경로가 적을수록 엣지 케이스를 놓칠 가능성이 줄어든다고 설명했다.

특히 주목할 점은 Claude의 마지막 언급이다. "복잡하게 중첩된 코드를 파싱할 수 있다. 그것은 하드한 제한이 아니다. 하지만 깊게 중첩된 로직에서는 추론 오류를 범할 가능성이 높다. 인간과 같은 방식으로." 이 문장은 AI가 자신의 한계를 인식하고 있으며, 그 한계가 인간의 인지적 제약과 유사하다는 것을 명시적으로 인정한다.

## 2025-2026년 AI 코딩 도구 생태계: 능력의 폭발과 한계의 재발견

2025년은 AI 코딩 도구의 능력이 극적으로 향상된 해였다. Anthropic의 Claude Code에서 일하는 엔지니어들은 현재 Claude Code 자체 코드의 약 90%를 AI가 작성한다고 보고했다. 그러나 Addy Osmani가 지적했듯이, "LLM을 프로그래밍에 사용하는 것은 버튼 하나 누르는 마법 같은 경험이 아니다. 어렵고 직관적이지 않으며, 좋은 결과를 얻으려면 새로운 패턴을 배워야 한다."

2025년 후반부터 등장한 추론 모델들은 게임 체인저였다. OpenAI의 o-시리즈, Claude Opus 4.5, Gemini 3 Pro는 단순한 코드 완성을 넘어 복잡한 문제 해결에서 인간 수준의 성능을 보여주기 시작했다. SWE-bench Verified에서 GPT-5는 74.9%의 정확도를, Aider Polyglot에서는 88%의 점수를 달성했다. Claude Opus 4.5는 Aider Polyglot에서 89.4%로 최고 성능을 기록했다.

그러나 이런 인상적인 벤치마크 점수에도 불구하고, 실제 기업 환경에서의 채택률은 예상보다 보수적이다. Google은 내부 코드의 약 25%가 AI로 생성되고 있으며, Microsoft는 20-30% 수준을 보고했다. Anthropic이 예측한 "90% AI 생성 코드" 시대는 아직 도래하지 않았다. 그 이유는 무엇일까?

Atlassian의 2025년 연구는 흥미로운 답을 제공한다. 그들은 118명의 개발자를 대상으로 설문조사를 진행하고, 144개의 실제 Jira 이슈와 250개의 파일을 분석했다. 결과는 놀라웠다. 개발자의 81%가 "LLM 시대에도 코드 가독성은 여전히 중요하다"고 답했으며, 가장 큰 동기는 "장기적 유지보수 비용 절감"이었다.

더 흥미로운 것은 AI 생성 코드와 인간 작성 코드의 실제 가독성 비교 결과다. Atlassian의 RovoDev가 생성한 코드는 Java, Kotlin, Go, Scala에서 인간이 작성한 코드와 거의 차이가 없었다. TypeScript와 Python에서는 약간 더 길고 유지보수성이 낮았지만, 그 차이는 미미했다. 코드 복잡도나 주석 품질에서도 유의미한 차이가 없었다. 흥미롭게도 개발자의 39%는 LLM 생성 코드가 인간 코드보다 더 읽기 쉽다고 답했고, 34%는 비슷하다고 답했다.

이 결과가 시사하는 바는 명확하다. AI가 생성하는 코드의 품질은 이미 인간 수준에 도달했다. 문제는 AI가 나쁜 코드를 생성한다는 것이 아니라, AI조차도 잘 구조화되고 읽기 쉬운 코드를 선호한다는 것이다. Uncle Bob과 Claude의 대화는 바로 이 지점을 포착한다.

## 클린 코드 원칙의 부활: AI 시대의 역설

2026년 초 현재, 소프트웨어 개발 커뮤니티에서 흥미로운 현상이 관찰되고 있다. AI가 더 많은 코드를 작성할수록, 클린 코드 원칙에 대한 관심이 오히려 증가하고 있다는 것이다. 이는 역설적으로 보이지만, 깊이 들여다보면 필연적인 귀결이다.

먼저, AI 도구의 효과성이 코드베이스의 품질에 크게 의존한다는 사실이 명확해졌다. Simon Willison은 2025년 회고에서 "최신 코딩 에이전트들은 기존 테스트 스위트를 제공받으면 놀랍도록 효과적이다"라고 지적했다. 그는 이를 "적합성 스위트(conformance suites)"라고 부르며, html5lib 테스트, MicroQuickJS 테스트 스위트, WebAssembly 스펙 테스트 등에서 성공을 거두었다고 보고했다.

이는 중요한 통찰을 제공한다. AI가 잘 작동하려면 명확한 사양과 테스트가 필요하다. 그리고 명확한 사양과 테스트는 잘 구조화된 코드에서만 가능하다. Uncle Bob이 수십 년 동안 주장해온 TDD(Test-Driven Development)와 클린 코드 원칙이 AI 시대에 더욱 중요해지는 이유다.

둘째, AI가 생성한 코드를 검토하고 유지보수하는 것은 여전히 인간의 몫이다. Atlassian 연구에서 개발자들이 가독성을 중시하는 가장 큰 이유가 "유지보수 비용 절감"이었다는 점은 시사적이다. AI가 코드를 빠르게 생성할 수 있어도, 그 코드를 이해하고 수정하고 확장하는 것은 인간이다. 읽기 쉬운 코드는 이 과정을 훨씬 효율적으로 만든다.

셋째, AI 자체가 클린 코드를 선호한다는 Uncle Bob의 실험 결과는 자기 강화 루프를 만든다. 개발자가 클린 코드 원칙을 따르면 → AI가 코드를 더 잘 이해하고 → 더 나은 제안과 리팩토링을 제공하고 → 결과적으로 더 깨끗한 코드베이스가 만들어진다. 이 선순환은 팀의 생산성을 지속적으로 향상시킨다.

Addy Osmani는 2026년으로 향하는 자신의 워크플로우에서 이렇게 강조했다. "AI 도구는 당신의 전문성을 증폭시킨다. 나는 AI가 내 일자리를 빼앗을까 두렵지 않다. 오히려 AI가 지루한 작업에서 나를 해방시켜 창의적이고 복잡한 소프트웨어 엔지니어링 측면에 더 많은 시간을 쓸 수 있게 해준다는 점에 흥분한다. 하지만 견고한 기반이 없는 사람들에게는 AI가 '스테로이드를 맞은 더닝-크루거 효과'를 초래할 수 있다."

## 실무적 함의: 개발자는 무엇을 준비해야 하는가

Uncle Bob과 Claude의 대화, 그리고 2025-2026년의 AI 코딩 도구 발전은 개발자들에게 몇 가지 중요한 교훈을 제공한다.

첫째, 추상화 능력이 더욱 중요해졌다. AI 시대의 개발자는 구문(syntax)보다는 에이전트, 컨텍스트, 메모리, 워크플로우 같은 더 높은 수준의 추상화 계층을 다루어야 한다. 좋은 함수명, 명확한 책임 분리, 예측 가능한 구조는 이런 추상화를 가능하게 하는 기반이다.

둘째, 코드 리뷰와 아키텍처 설계 능력이 핵심 역량이 되었다. AllAboutAI의 2026년 분석에 따르면, 성공적인 스타트업의 78%는 하이브리드 전략을 사용한다. GitHub Copilot로 실시간 완성을, Claude/GPT로 복잡한 추론을, 커스텀 LLM으로 도메인 특화 작업을 처리한다. 이 모든 도구를 효과적으로 조율하려면 시니어 개발자 수준의 아키텍처 사고가 필요하다.

셋째, AI 친화적인 워크플로우 구축이 필수가 되었다. Addy Osmani가 강조했듯이, "더 많은 테스트, 더 많은 모니터링, 어쩌면 AI가 AI를 검토하는 코드 리뷰"가 필요하다. 자동화된 품질 게이트는 AI가 생성한 코드의 정직성을 유지하는 핵심 메커니즘이다.

넷째, 기본기의 중요성이 오히려 증가했다. AI 도구는 전문성을 증폭시키지만, 전문성을 대체하지는 않는다. 견고한 소프트웨어 공학 기초가 있는 개발자는 AI의 생산성 향상 효과를 몇 배로 누릴 수 있다. 반면 기초가 약한 개발자는 AI가 생성한 코드를 제대로 평가하지 못해 장기적으로 더 큰 문제를 만들 수 있다.

## 한국 개발 생태계에의 시사점

한국의 기업 환경에서 이런 변화는 특별한 의미를 갖는다. 한국 기업들은 전통적으로 빠른 개발과 신속한 출시를 중시해왔다. AI 도구의 등장으로 이런 속도가 더욱 빨라질 것으로 기대되지만, Uncle Bob과 Claude의 대화는 다른 메시지를 전한다.

속도와 품질은 트레이드오프가 아니라는 것이다. 오히려 클린 코드 원칙을 따르면 AI가 더 효과적으로 작동하고, 결과적으로 더 빠르고 안정적인 개발이 가능하다. 한국의 많은 기업들이 기술 부채 문제로 고생하는 상황에서, AI 시대는 이를 해결할 기회이자 더 심화시킬 위험이 동시에 존재한다.

한국 개발자 커뮤니티는 Claude Code, Cursor, GitHub Copilot 같은 도구를 빠르게 채택하고 있다. 하지만 도구 자체보다 중요한 것은 이 도구들을 어떻게 사용하느냐다. Anthropic의 Claude Code 팀이 자신들의 코드를 90% AI로 작성할 수 있는 이유는 더 나은 AI 때문이 아니라, 더 나은 코드 구조와 테스트 스위트, 그리고 명확한 아키텍처 원칙 때문이다.

## 맺음말: 본질로의 회귀

Uncle Bob과 Claude의 짧은 대화는 AI 시대 소프트웨어 개발의 본질을 드러낸다. 기술이 아무리 발전해도, 좋은 코드의 원칙은 변하지 않는다. 아니, 더 정확히 말하면, 기술이 발전할수록 그 원칙의 중요성이 더욱 부각된다.

명확한 의도를 가진 이름, 단순한 구조, 적절한 추상화, 명시적인 계약. 이것들은 1960년대 Edsger Dijkstra가 구조적 프로그래밍을 제안했을 때부터, 2000년대 Uncle Bob이 클린 코드를 강조했을 때부터, 그리고 2026년 AI가 코드를 읽고 쓰는 지금까지 변하지 않는 원칙이다.

Claude가 "인간과 같은 방식으로" 리팩토링된 코드를 더 잘 이해한다는 고백은, 결국 우리가 인간을 위해 작성해온 코드 품질의 원칙이 AI 시대에도 그대로 적용된다는 것을 보여준다. 어쩌면 AI는 우리에게 우리가 이미 알고 있던 진리를 다시 한번 상기시키는 거울인지도 모른다.

2026년, 개발자의 역할은 코드를 타이핑하는 사람에서 AI를 조율하는 아키텍트로 진화하고 있다. 하지만 그 아키텍트가 다루는 재료는 여전히 코드이고, 그 코드의 품질을 결정하는 원칙은 수십 년 전과 크게 다르지 않다. Uncle Bob이 평생 주장해온 "장인 정신(craftsmanship)"은 AI 시대에 더욱 필수적인 덕목이 되었다.

결국, 우리는 본질로 돌아가야 한다. 더 나은 도구를 얻었지만, 더 나은 코드를 작성하는 것은 여전히 우리의 책임이다. 그리고 그 책임을 다하는 방법은 예나 지금이나 같다. 읽기 쉽고, 이해하기 쉽고, 변경하기 쉬운 코드를 작성하는 것. Claude도 인정했듯이, 그것이 인간에게 좋은 것은 AI에게도 좋다.

---

**작성일자: 2026-01-22**
